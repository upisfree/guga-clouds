var Sd = Object.defineProperty;
var Bd = (i, e, t) => e in i ? Sd(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var Y = (i, e, t) => Bd(i, typeof e != "symbol" ? e + "" : e, t);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const To = "173";
const Pl = "attached", Td = "detached";
const xn = "", Rt = "srgb", Ut = "srgb-linear", Kr = "linear", at = "srgb";
const Ll = "300 es";
class Pt {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    const n = this._listeners;
    return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    const n = this._listeners;
    if (n === void 0) return;
    const s = n[e];
    if (s !== void 0) {
      const r = s.indexOf(t);
      r !== -1 && s.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const n = t[e.type];
    if (n !== void 0) {
      e.target = this;
      const s = n.slice(0);
      for (let r = 0, a = s.length; r < a; r++)
        s[r].call(this, e);
      e.target = null;
    }
  }
}
const Ft = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Fl = 1234567;
const Hs = Math.PI / 180, ds = 180 / Math.PI;
function En() {
  const i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (Ft[i & 255] + Ft[i >> 8 & 255] + Ft[i >> 16 & 255] + Ft[i >> 24 & 255] + "-" + Ft[e & 255] + Ft[e >> 8 & 255] + "-" + Ft[e >> 16 & 15 | 64] + Ft[e >> 24 & 255] + "-" + Ft[t & 63 | 128] + Ft[t >> 8 & 255] + "-" + Ft[t >> 16 & 255] + Ft[t >> 24 & 255] + Ft[n & 255] + Ft[n >> 8 & 255] + Ft[n >> 16 & 255] + Ft[n >> 24 & 255]).toLowerCase();
}
function Qe(i, e, t) {
  return Math.max(e, Math.min(t, i));
}
function Ro(i, e) {
  return (i % e + e) % e;
}
function Rd(i, e, t, n, s) {
  return n + (i - e) * (s - n) / (t - e);
}
function Dd(i, e, t) {
  return i !== e ? (t - i) / (e - i) : 0;
}
function Vs(i, e, t) {
  return (1 - t) * i + t * e;
}
function Pd(i, e, t, n) {
  return Vs(i, e, 1 - Math.exp(-t * n));
}
function Ld(i, e = 1) {
  return e - Math.abs(Ro(i, e * 2) - e);
}
function Fd(i, e, t) {
  return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * (3 - 2 * i));
}
function Nd(i, e, t) {
  return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * i * (i * (i * 6 - 15) + 10));
}
function Ud(i, e) {
  return i + Math.floor(Math.random() * (e - i + 1));
}
function Qd(i, e) {
  return i + Math.random() * (e - i);
}
function kd(i) {
  return i * (0.5 - Math.random());
}
function _d(i) {
  i !== void 0 && (Fl = i);
  let e = Fl += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function Od(i) {
  return i * Hs;
}
function Gd(i) {
  return i * ds;
}
function Hd(i) {
  return (i & i - 1) === 0 && i !== 0;
}
function Vd(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
function zd(i) {
  return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
function qd(i, e, t, n, s) {
  const r = Math.cos, a = Math.sin, o = r(t / 2), l = a(t / 2), c = r((e + n) / 2), h = a((e + n) / 2), u = r((e - n) / 2), d = a((e - n) / 2), A = r((n - e) / 2), m = a((n - e) / 2);
  switch (s) {
    case "XYX":
      i.set(o * h, l * u, l * d, o * c);
      break;
    case "YZY":
      i.set(l * d, o * h, l * u, o * c);
      break;
    case "ZXZ":
      i.set(l * u, l * d, o * h, o * c);
      break;
    case "XZX":
      i.set(o * h, l * m, l * A, o * c);
      break;
    case "YXY":
      i.set(l * A, o * h, l * m, o * c);
      break;
    case "ZYZ":
      i.set(l * m, l * A, o * h, o * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function bn(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return i / 4294967295;
    case Uint16Array:
      return i / 65535;
    case Uint8Array:
      return i / 255;
    case Int32Array:
      return Math.max(i / 2147483647, -1);
    case Int16Array:
      return Math.max(i / 32767, -1);
    case Int8Array:
      return Math.max(i / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function st(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return Math.round(i * 4294967295);
    case Uint16Array:
      return Math.round(i * 65535);
    case Uint8Array:
      return Math.round(i * 255);
    case Int32Array:
      return Math.round(i * 2147483647);
    case Int16Array:
      return Math.round(i * 32767);
    case Int8Array:
      return Math.round(i * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Wd = {
  DEG2RAD: Hs,
  RAD2DEG: ds,
  generateUUID: En,
  clamp: Qe,
  euclideanModulo: Ro,
  mapLinear: Rd,
  inverseLerp: Dd,
  lerp: Vs,
  damp: Pd,
  pingpong: Ld,
  smoothstep: Fd,
  smootherstep: Nd,
  randInt: Ud,
  randFloat: Qd,
  randFloatSpread: kd,
  seededRandom: _d,
  degToRad: Od,
  radToDeg: Gd,
  isPowerOfTwo: Hd,
  ceilPowerOfTwo: Vd,
  floorPowerOfTwo: zd,
  setQuaternionFromProperEuler: qd,
  normalize: st,
  denormalize: bn
};
class Ie {
  constructor(e = 0, t = 0) {
    Ie.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * t + s[3] * n + s[6], this.y = s[1] * t + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Qe(this.x, e.x, t.x), this.y = Qe(this.y, e.y, t.y), this;
  }
  clampScalar(e, t) {
    return this.x = Qe(this.x, e, t), this.y = Qe(this.y, e, t), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Qe(n, e, t));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Qe(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), s = Math.sin(t), r = this.x - e.x, a = this.y - e.y;
    return this.x = r * n - a * s + e.x, this.y = r * s + a * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Fe {
  constructor(e, t, n, s, r, a, o, l, c) {
    Fe.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, s, r, a, o, l, c);
  }
  set(e, t, n, s, r, a, o, l, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = o, h[3] = t, h[4] = r, h[5] = l, h[6] = n, h[7] = a, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, s = t.elements, r = this.elements, a = n[0], o = n[3], l = n[6], c = n[1], h = n[4], u = n[7], d = n[2], A = n[5], m = n[8], g = s[0], f = s[3], p = s[6], v = s[1], E = s[4], b = s[7], S = s[2], I = s[5], B = s[8];
    return r[0] = a * g + o * v + l * S, r[3] = a * f + o * E + l * I, r[6] = a * p + o * b + l * B, r[1] = c * g + h * v + u * S, r[4] = c * f + h * E + u * I, r[7] = c * p + h * b + u * B, r[2] = d * g + A * v + m * S, r[5] = d * f + A * E + m * I, r[8] = d * p + A * b + m * B, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8];
    return t * a * h - t * o * c - n * r * h + n * o * l + s * r * c - s * a * l;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8], u = h * a - o * c, d = o * l - h * r, A = c * r - a * l, m = t * u + n * d + s * A;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const g = 1 / m;
    return e[0] = u * g, e[1] = (s * c - h * n) * g, e[2] = (o * n - s * a) * g, e[3] = d * g, e[4] = (h * t - s * l) * g, e[5] = (s * r - o * t) * g, e[6] = A * g, e[7] = (n * l - c * t) * g, e[8] = (a * t - n * r) * g, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, s, r, a, o) {
    const l = Math.cos(r), c = Math.sin(r);
    return this.set(
      n * l,
      n * c,
      -n * (l * a + c * o) + a + e,
      -s * c,
      s * l,
      -s * (-c * a + l * o) + o + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(fa.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(fa.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(fa.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (t[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const fa = /* @__PURE__ */ new Fe();
function Rh(i) {
  for (let e = i.length - 1; e >= 0; --e)
    if (i[e] >= 65535) return !0;
  return !1;
}
function Ys(i) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", i);
}
function Yd() {
  const i = Ys("canvas");
  return i.style.display = "block", i;
}
const Nl = {};
function as(i) {
  i in Nl || (Nl[i] = !0, console.warn(i));
}
function Kd(i, e, t) {
  return new Promise(function(n, s) {
    function r() {
      switch (i.clientWaitSync(e, i.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case i.WAIT_FAILED:
          s();
          break;
        case i.TIMEOUT_EXPIRED:
          setTimeout(r, t);
          break;
        default:
          n();
      }
    }
    setTimeout(r, t);
  });
}
function Xd(i) {
  const e = i.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function jd(i) {
  const e = i.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const Ul = /* @__PURE__ */ new Fe().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), Ql = /* @__PURE__ */ new Fe().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function Jd() {
  const i = {
    enabled: !0,
    workingColorSpace: Ut,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(s, r, a) {
      return this.enabled === !1 || r === a || !r || !a || (this.spaces[r].transfer === at && (s.r = Wn(s.r), s.g = Wn(s.g), s.b = Wn(s.b)), this.spaces[r].primaries !== this.spaces[a].primaries && (s.applyMatrix3(this.spaces[r].toXYZ), s.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === at && (s.r = ls(s.r), s.g = ls(s.g), s.b = ls(s.b))), s;
    },
    fromWorkingColorSpace: function(s, r) {
      return this.convert(s, this.workingColorSpace, r);
    },
    toWorkingColorSpace: function(s, r) {
      return this.convert(s, r, this.workingColorSpace);
    },
    getPrimaries: function(s) {
      return this.spaces[s].primaries;
    },
    getTransfer: function(s) {
      return s === xn ? Kr : this.spaces[s].transfer;
    },
    getLuminanceCoefficients: function(s, r = this.workingColorSpace) {
      return s.fromArray(this.spaces[r].luminanceCoefficients);
    },
    define: function(s) {
      Object.assign(this.spaces, s);
    },
    // Internal APIs
    _getMatrix: function(s, r, a) {
      return s.copy(this.spaces[r].toXYZ).multiply(this.spaces[a].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(s) {
      return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(s = this.workingColorSpace) {
      return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
    }
  }, e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], t = [0.2126, 0.7152, 0.0722], n = [0.3127, 0.329];
  return i.define({
    [Ut]: {
      primaries: e,
      whitePoint: n,
      transfer: Kr,
      toXYZ: Ul,
      fromXYZ: Ql,
      luminanceCoefficients: t,
      workingColorSpaceConfig: { unpackColorSpace: Rt },
      outputColorSpaceConfig: { drawingBufferColorSpace: Rt }
    },
    [Rt]: {
      primaries: e,
      whitePoint: n,
      transfer: at,
      toXYZ: Ul,
      fromXYZ: Ql,
      luminanceCoefficients: t,
      outputColorSpaceConfig: { drawingBufferColorSpace: Rt }
    }
  }), i;
}
const We = /* @__PURE__ */ Jd();
function Wn(i) {
  return i < 0.04045 ? i * 0.0773993808 : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
}
function ls(i) {
  return i < 31308e-7 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
let Hi;
class Zd {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Hi === void 0 && (Hi = Ys("canvas")), Hi.width = e.width, Hi.height = e.height;
      const n = Hi.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Hi;
    }
    return t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = Ys("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const s = n.getImageData(0, 0, e.width, e.height), r = s.data;
      for (let a = 0; a < r.length; a++)
        r[a] = Wn(r[a] / 255) * 255;
      return n.putImageData(s, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Wn(t[n] / 255) * 255) : t[n] = Wn(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let $d = 0;
class Dh {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: $d++ }), this.uuid = En(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, s = this.data;
    if (s !== null) {
      let r;
      if (Array.isArray(s)) {
        r = [];
        for (let a = 0, o = s.length; a < o; a++)
          s[a].isDataTexture ? r.push(ma(s[a].image)) : r.push(ma(s[a]));
      } else
        r = ma(s);
      n.url = r;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function ma(i) {
  return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? Zd.getDataURL(i) : i.data ? {
    data: Array.from(i.data),
    width: i.width,
    height: i.height,
    type: i.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let ep = 0;
class It extends Pt {
  constructor(e = It.DEFAULT_IMAGE, t = It.DEFAULT_MAPPING, n = 1001, s = 1001, r = 1006, a = 1008, o = 1023, l = 1009, c = It.DEFAULT_ANISOTROPY, h = xn) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: ep++ }), this.uuid = En(), this.name = "", this.source = new Dh(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = r, this.minFilter = a, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new Ie(0, 0), this.repeat = new Ie(1, 1), this.center = new Ie(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Fe(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== 300) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case 1e3:
          e.x = e.x - Math.floor(e.x);
          break;
        case 1001:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case 1002:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case 1e3:
          e.y = e.y - Math.floor(e.y);
          break;
        case 1001:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case 1002:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
It.DEFAULT_IMAGE = null;
It.DEFAULT_MAPPING = 300;
It.DEFAULT_ANISOTROPY = 1;
class $e {
  constructor(e = 0, t = 0, n = 0, s = 1) {
    $e.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, s) {
    return this.x = e, this.y = t, this.z = n, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, s = this.z, r = this.w, a = e.elements;
    return this.x = a[0] * t + a[4] * n + a[8] * s + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * s + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * s + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * s + a[15] * r, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, s, r;
    const l = e.elements, c = l[0], h = l[4], u = l[8], d = l[1], A = l[5], m = l[9], g = l[2], f = l[6], p = l[10];
    if (Math.abs(h - d) < 0.01 && Math.abs(u - g) < 0.01 && Math.abs(m - f) < 0.01) {
      if (Math.abs(h + d) < 0.1 && Math.abs(u + g) < 0.1 && Math.abs(m + f) < 0.1 && Math.abs(c + A + p - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const E = (c + 1) / 2, b = (A + 1) / 2, S = (p + 1) / 2, I = (h + d) / 4, B = (u + g) / 4, R = (m + f) / 4;
      return E > b && E > S ? E < 0.01 ? (n = 0, s = 0.707106781, r = 0.707106781) : (n = Math.sqrt(E), s = I / n, r = B / n) : b > S ? b < 0.01 ? (n = 0.707106781, s = 0, r = 0.707106781) : (s = Math.sqrt(b), n = I / s, r = R / s) : S < 0.01 ? (n = 0.707106781, s = 0.707106781, r = 0) : (r = Math.sqrt(S), n = B / r, s = R / r), this.set(n, s, r, t), this;
    }
    let v = Math.sqrt((f - m) * (f - m) + (u - g) * (u - g) + (d - h) * (d - h));
    return Math.abs(v) < 1e-3 && (v = 1), this.x = (f - m) / v, this.y = (u - g) / v, this.z = (d - h) / v, this.w = Math.acos((c + A + p - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Qe(this.x, e.x, t.x), this.y = Qe(this.y, e.y, t.y), this.z = Qe(this.z, e.z, t.z), this.w = Qe(this.w, e.w, t.w), this;
  }
  clampScalar(e, t) {
    return this.x = Qe(this.x, e, t), this.y = Qe(this.y, e, t), this.z = Qe(this.z, e, t), this.w = Qe(this.w, e, t), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Qe(n, e, t));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class tp extends Pt {
  constructor(e = 1, t = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new $e(0, 0, e, t), this.scissorTest = !1, this.viewport = new $e(0, 0, e, t);
    const s = { width: e, height: t, depth: 1 };
    n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: 1006,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, n);
    const r = new It(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
    r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
    const a = n.count;
    for (let o = 0; o < a; o++)
      this.textures[o] = r.clone(), this.textures[o].isRenderTargetTexture = !0, this.textures[o].renderTarget = this;
    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let s = 0, r = this.textures.length; s < r; s++)
        this.textures[s].image.width = e, this.textures[s].image.height = t, this.textures[s].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let n = 0, s = e.textures.length; n < s; n++)
      this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0, this.textures[n].renderTarget = this;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new Dh(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Kn extends tp {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
class Ph extends It {
  constructor(e = null, t = 1, n = 1, s = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: s }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Lh extends It {
  constructor(e = null, t = 1, n = 1, s = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: s }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class dn {
  constructor(e = 0, t = 0, n = 0, s = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = s;
  }
  static slerpFlat(e, t, n, s, r, a, o) {
    let l = n[s + 0], c = n[s + 1], h = n[s + 2], u = n[s + 3];
    const d = r[a + 0], A = r[a + 1], m = r[a + 2], g = r[a + 3];
    if (o === 0) {
      e[t + 0] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = u;
      return;
    }
    if (o === 1) {
      e[t + 0] = d, e[t + 1] = A, e[t + 2] = m, e[t + 3] = g;
      return;
    }
    if (u !== g || l !== d || c !== A || h !== m) {
      let f = 1 - o;
      const p = l * d + c * A + h * m + u * g, v = p >= 0 ? 1 : -1, E = 1 - p * p;
      if (E > Number.EPSILON) {
        const S = Math.sqrt(E), I = Math.atan2(S, p * v);
        f = Math.sin(f * I) / S, o = Math.sin(o * I) / S;
      }
      const b = o * v;
      if (l = l * f + d * b, c = c * f + A * b, h = h * f + m * b, u = u * f + g * b, f === 1 - o) {
        const S = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
        l *= S, c *= S, h *= S, u *= S;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = u;
  }
  static multiplyQuaternionsFlat(e, t, n, s, r, a) {
    const o = n[s], l = n[s + 1], c = n[s + 2], h = n[s + 3], u = r[a], d = r[a + 1], A = r[a + 2], m = r[a + 3];
    return e[t] = o * m + h * u + l * A - c * d, e[t + 1] = l * m + h * d + c * u - o * A, e[t + 2] = c * m + h * A + o * d - l * u, e[t + 3] = h * m - o * u - l * d - c * A, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, s) {
    return this._x = e, this._y = t, this._z = n, this._w = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = !0) {
    const n = e._x, s = e._y, r = e._z, a = e._order, o = Math.cos, l = Math.sin, c = o(n / 2), h = o(s / 2), u = o(r / 2), d = l(n / 2), A = l(s / 2), m = l(r / 2);
    switch (a) {
      case "XYZ":
        this._x = d * h * u + c * A * m, this._y = c * A * u - d * h * m, this._z = c * h * m + d * A * u, this._w = c * h * u - d * A * m;
        break;
      case "YXZ":
        this._x = d * h * u + c * A * m, this._y = c * A * u - d * h * m, this._z = c * h * m - d * A * u, this._w = c * h * u + d * A * m;
        break;
      case "ZXY":
        this._x = d * h * u - c * A * m, this._y = c * A * u + d * h * m, this._z = c * h * m + d * A * u, this._w = c * h * u - d * A * m;
        break;
      case "ZYX":
        this._x = d * h * u - c * A * m, this._y = c * A * u + d * h * m, this._z = c * h * m - d * A * u, this._w = c * h * u + d * A * m;
        break;
      case "YZX":
        this._x = d * h * u + c * A * m, this._y = c * A * u + d * h * m, this._z = c * h * m - d * A * u, this._w = c * h * u - d * A * m;
        break;
      case "XZY":
        this._x = d * h * u - c * A * m, this._y = c * A * u - d * h * m, this._z = c * h * m + d * A * u, this._w = c * h * u + d * A * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, s = Math.sin(n);
    return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], s = t[4], r = t[8], a = t[1], o = t[5], l = t[9], c = t[2], h = t[6], u = t[10], d = n + o + u;
    if (d > 0) {
      const A = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / A, this._x = (h - l) * A, this._y = (r - c) * A, this._z = (a - s) * A;
    } else if (n > o && n > u) {
      const A = 2 * Math.sqrt(1 + n - o - u);
      this._w = (h - l) / A, this._x = 0.25 * A, this._y = (s + a) / A, this._z = (r + c) / A;
    } else if (o > u) {
      const A = 2 * Math.sqrt(1 + o - n - u);
      this._w = (r - c) / A, this._x = (s + a) / A, this._y = 0.25 * A, this._z = (l + h) / A;
    } else {
      const A = 2 * Math.sqrt(1 + u - n - o);
      this._w = (a - s) / A, this._x = (r + c) / A, this._y = (l + h) / A, this._z = 0.25 * A;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Qe(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const s = Math.min(1, t / n);
    return this.slerp(e, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, s = e._y, r = e._z, a = e._w, o = t._x, l = t._y, c = t._z, h = t._w;
    return this._x = n * h + a * o + s * c - r * l, this._y = s * h + a * l + r * o - n * c, this._z = r * h + a * c + n * l - s * o, this._w = a * h - n * o - s * l - r * c, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x, s = this._y, r = this._z, a = this._w;
    let o = a * e._w + n * e._x + s * e._y + r * e._z;
    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1)
      return this._w = a, this._x = n, this._y = s, this._z = r, this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const A = 1 - t;
      return this._w = A * a + t * this._w, this._x = A * n + t * this._x, this._y = A * s + t * this._y, this._z = A * r + t * this._z, this.normalize(), this;
    }
    const c = Math.sqrt(l), h = Math.atan2(c, o), u = Math.sin((1 - t) * h) / c, d = Math.sin(t * h) / c;
    return this._w = a * u + this._w * d, this._x = n * u + this._x * d, this._y = s * u + this._y * d, this._z = r * u + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), s = Math.sqrt(1 - n), r = Math.sqrt(n);
    return this.set(
      s * Math.sin(e),
      s * Math.cos(e),
      r * Math.sin(t),
      r * Math.cos(t)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class T {
  constructor(e = 0, t = 0, n = 0) {
    T.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(kl.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(kl.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, s = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * n + r[6] * s, this.y = r[1] * t + r[4] * n + r[7] * s, this.z = r[2] * t + r[5] * n + r[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, s = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * n + r[11] * s + r[15]);
    return this.x = (r[0] * t + r[4] * n + r[8] * s + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * s + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * s + r[14]) * a, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, s = this.z, r = e.x, a = e.y, o = e.z, l = e.w, c = 2 * (a * s - o * n), h = 2 * (o * t - r * s), u = 2 * (r * n - a * t);
    return this.x = t + l * c + a * u - o * h, this.y = n + l * h + o * c - r * u, this.z = s + l * u + r * h - a * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, s = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * n + r[8] * s, this.y = r[1] * t + r[5] * n + r[9] * s, this.z = r[2] * t + r[6] * n + r[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Qe(this.x, e.x, t.x), this.y = Qe(this.y, e.y, t.y), this.z = Qe(this.z, e.z, t.z), this;
  }
  clampScalar(e, t) {
    return this.x = Qe(this.x, e, t), this.y = Qe(this.y, e, t), this.z = Qe(this.z, e, t), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Qe(n, e, t));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, s = e.y, r = e.z, a = t.x, o = t.y, l = t.z;
    return this.x = s * l - r * o, this.y = r * a - n * l, this.z = n * o - s * a, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return ga.copy(this).projectOnVector(e), this.sub(ga);
  }
  reflect(e) {
    return this.sub(ga.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Qe(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
    return t * t + n * n + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const s = Math.sin(t) * e;
    return this.x = s * Math.sin(n), this.y = Math.cos(t) * e, this.z = s * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = s, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
    return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const ga = /* @__PURE__ */ new T(), kl = /* @__PURE__ */ new dn();
class Jn {
  constructor(e = new T(1 / 0, 1 / 0, 1 / 0), t = new T(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(fn.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(fn.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = fn.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const r = n.getAttribute("position");
      if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, o = r.count; a < o; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, fn) : fn.fromBufferAttribute(r, a), fn.applyMatrix4(e.matrixWorld), this.expandByPoint(fn);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Ar.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Ar.copy(n.boundingBox)), Ar.applyMatrix4(e.matrixWorld), this.union(Ar);
    }
    const s = e.children;
    for (let r = 0, a = s.length; r < a; r++)
      this.expandByObject(s[r], t);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, fn), fn.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Ss), fr.subVectors(this.max, Ss), Vi.subVectors(e.a, Ss), zi.subVectors(e.b, Ss), qi.subVectors(e.c, Ss), $n.subVectors(zi, Vi), ei.subVectors(qi, zi), gi.subVectors(Vi, qi);
    let t = [
      0,
      -$n.z,
      $n.y,
      0,
      -ei.z,
      ei.y,
      0,
      -gi.z,
      gi.y,
      $n.z,
      0,
      -$n.x,
      ei.z,
      0,
      -ei.x,
      gi.z,
      0,
      -gi.x,
      -$n.y,
      $n.x,
      0,
      -ei.y,
      ei.x,
      0,
      -gi.y,
      gi.x,
      0
    ];
    return !ba(t, Vi, zi, qi, fr) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !ba(t, Vi, zi, qi, fr)) ? !1 : (mr.crossVectors($n, ei), t = [mr.x, mr.y, mr.z], ba(t, Vi, zi, qi, fr));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, fn).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(fn).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Ln[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ln[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ln[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ln[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ln[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ln[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ln[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ln[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ln), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ln = [
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T(),
  /* @__PURE__ */ new T()
], fn = /* @__PURE__ */ new T(), Ar = /* @__PURE__ */ new Jn(), Vi = /* @__PURE__ */ new T(), zi = /* @__PURE__ */ new T(), qi = /* @__PURE__ */ new T(), $n = /* @__PURE__ */ new T(), ei = /* @__PURE__ */ new T(), gi = /* @__PURE__ */ new T(), Ss = /* @__PURE__ */ new T(), fr = /* @__PURE__ */ new T(), mr = /* @__PURE__ */ new T(), bi = /* @__PURE__ */ new T();
function ba(i, e, t, n, s) {
  for (let r = 0, a = i.length - 3; r <= a; r += 3) {
    bi.fromArray(i, r);
    const o = s.x * Math.abs(bi.x) + s.y * Math.abs(bi.y) + s.z * Math.abs(bi.z), l = e.dot(bi), c = t.dot(bi), h = n.dot(bi);
    if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > o)
      return !1;
  }
  return !0;
}
const np = /* @__PURE__ */ new Jn(), Bs = /* @__PURE__ */ new T(), va = /* @__PURE__ */ new T();
class Tn {
  constructor(e = new T(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : np.setFromPoints(e).getCenter(n);
    let s = 0;
    for (let r = 0, a = e.length; r < a; r++)
      s = Math.max(s, n.distanceToSquared(e[r]));
    return this.radius = Math.sqrt(s), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Bs.subVectors(e, this.center);
    const t = Bs.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), s = (n - this.radius) * 0.5;
      this.center.addScaledVector(Bs, s / n), this.radius += s;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (va.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Bs.copy(e.center).add(va)), this.expandByPoint(Bs.copy(e.center).sub(va))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Fn = /* @__PURE__ */ new T(), Ea = /* @__PURE__ */ new T(), gr = /* @__PURE__ */ new T(), ti = /* @__PURE__ */ new T(), Ca = /* @__PURE__ */ new T(), br = /* @__PURE__ */ new T(), xa = /* @__PURE__ */ new T();
class ia {
  constructor(e = new T(), t = new T(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Fn)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Fn.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (Fn.copy(this.origin).addScaledVector(this.direction, t), Fn.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, s) {
    Ea.copy(e).add(t).multiplyScalar(0.5), gr.copy(t).sub(e).normalize(), ti.copy(this.origin).sub(Ea);
    const r = e.distanceTo(t) * 0.5, a = -this.direction.dot(gr), o = ti.dot(this.direction), l = -ti.dot(gr), c = ti.lengthSq(), h = Math.abs(1 - a * a);
    let u, d, A, m;
    if (h > 0)
      if (u = a * l - o, d = a * o - l, m = r * h, u >= 0)
        if (d >= -m)
          if (d <= m) {
            const g = 1 / h;
            u *= g, d *= g, A = u * (u + a * d + 2 * o) + d * (a * u + d + 2 * l) + c;
          } else
            d = r, u = Math.max(0, -(a * d + o)), A = -u * u + d * (d + 2 * l) + c;
        else
          d = -r, u = Math.max(0, -(a * d + o)), A = -u * u + d * (d + 2 * l) + c;
      else
        d <= -m ? (u = Math.max(0, -(-a * r + o)), d = u > 0 ? -r : Math.min(Math.max(-r, -l), r), A = -u * u + d * (d + 2 * l) + c) : d <= m ? (u = 0, d = Math.min(Math.max(-r, -l), r), A = d * (d + 2 * l) + c) : (u = Math.max(0, -(a * r + o)), d = u > 0 ? r : Math.min(Math.max(-r, -l), r), A = -u * u + d * (d + 2 * l) + c);
    else
      d = a > 0 ? -r : r, u = Math.max(0, -(a * d + o)), A = -u * u + d * (d + 2 * l) + c;
    return n && n.copy(this.origin).addScaledVector(this.direction, u), s && s.copy(Ea).addScaledVector(gr, d), A;
  }
  intersectSphere(e, t) {
    Fn.subVectors(e.center, this.origin);
    const n = Fn.dot(this.direction), s = Fn.dot(Fn) - n * n, r = e.radius * e.radius;
    if (s > r) return null;
    const a = Math.sqrt(r - s), o = n - a, l = n + a;
    return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, s, r, a, o, l;
    const c = 1 / this.direction.x, h = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin;
    return c >= 0 ? (n = (e.min.x - d.x) * c, s = (e.max.x - d.x) * c) : (n = (e.max.x - d.x) * c, s = (e.min.x - d.x) * c), h >= 0 ? (r = (e.min.y - d.y) * h, a = (e.max.y - d.y) * h) : (r = (e.max.y - d.y) * h, a = (e.min.y - d.y) * h), n > a || r > s || ((r > n || isNaN(n)) && (n = r), (a < s || isNaN(s)) && (s = a), u >= 0 ? (o = (e.min.z - d.z) * u, l = (e.max.z - d.z) * u) : (o = (e.max.z - d.z) * u, l = (e.min.z - d.z) * u), n > l || o > s) || ((o > n || n !== n) && (n = o), (l < s || s !== s) && (s = l), s < 0) ? null : this.at(n >= 0 ? n : s, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Fn) !== null;
  }
  intersectTriangle(e, t, n, s, r) {
    Ca.subVectors(t, e), br.subVectors(n, e), xa.crossVectors(Ca, br);
    let a = this.direction.dot(xa), o;
    if (a > 0) {
      if (s) return null;
      o = 1;
    } else if (a < 0)
      o = -1, a = -a;
    else
      return null;
    ti.subVectors(this.origin, e);
    const l = o * this.direction.dot(br.crossVectors(ti, br));
    if (l < 0)
      return null;
    const c = o * this.direction.dot(Ca.cross(ti));
    if (c < 0 || l + c > a)
      return null;
    const h = -o * ti.dot(xa);
    return h < 0 ? null : this.at(h / a, r);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Pe {
  constructor(e, t, n, s, r, a, o, l, c, h, u, d, A, m, g, f) {
    Pe.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, s, r, a, o, l, c, h, u, d, A, m, g, f);
  }
  set(e, t, n, s, r, a, o, l, c, h, u, d, A, m, g, f) {
    const p = this.elements;
    return p[0] = e, p[4] = t, p[8] = n, p[12] = s, p[1] = r, p[5] = a, p[9] = o, p[13] = l, p[2] = c, p[6] = h, p[10] = u, p[14] = d, p[3] = A, p[7] = m, p[11] = g, p[15] = f, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Pe().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, s = 1 / Wi.setFromMatrixColumn(e, 0).length(), r = 1 / Wi.setFromMatrixColumn(e, 1).length(), a = 1 / Wi.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * s, t[1] = n[1] * s, t[2] = n[2] * s, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, s = e.y, r = e.z, a = Math.cos(n), o = Math.sin(n), l = Math.cos(s), c = Math.sin(s), h = Math.cos(r), u = Math.sin(r);
    if (e.order === "XYZ") {
      const d = a * h, A = a * u, m = o * h, g = o * u;
      t[0] = l * h, t[4] = -l * u, t[8] = c, t[1] = A + m * c, t[5] = d - g * c, t[9] = -o * l, t[2] = g - d * c, t[6] = m + A * c, t[10] = a * l;
    } else if (e.order === "YXZ") {
      const d = l * h, A = l * u, m = c * h, g = c * u;
      t[0] = d + g * o, t[4] = m * o - A, t[8] = a * c, t[1] = a * u, t[5] = a * h, t[9] = -o, t[2] = A * o - m, t[6] = g + d * o, t[10] = a * l;
    } else if (e.order === "ZXY") {
      const d = l * h, A = l * u, m = c * h, g = c * u;
      t[0] = d - g * o, t[4] = -a * u, t[8] = m + A * o, t[1] = A + m * o, t[5] = a * h, t[9] = g - d * o, t[2] = -a * c, t[6] = o, t[10] = a * l;
    } else if (e.order === "ZYX") {
      const d = a * h, A = a * u, m = o * h, g = o * u;
      t[0] = l * h, t[4] = m * c - A, t[8] = d * c + g, t[1] = l * u, t[5] = g * c + d, t[9] = A * c - m, t[2] = -c, t[6] = o * l, t[10] = a * l;
    } else if (e.order === "YZX") {
      const d = a * l, A = a * c, m = o * l, g = o * c;
      t[0] = l * h, t[4] = g - d * u, t[8] = m * u + A, t[1] = u, t[5] = a * h, t[9] = -o * h, t[2] = -c * h, t[6] = A * u + m, t[10] = d - g * u;
    } else if (e.order === "XZY") {
      const d = a * l, A = a * c, m = o * l, g = o * c;
      t[0] = l * h, t[4] = -u, t[8] = c * h, t[1] = d * u + g, t[5] = a * h, t[9] = A * u - m, t[2] = m * u - A, t[6] = o * h, t[10] = g * u + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(ip, e, sp);
  }
  lookAt(e, t, n) {
    const s = this.elements;
    return Jt.subVectors(e, t), Jt.lengthSq() === 0 && (Jt.z = 1), Jt.normalize(), ni.crossVectors(n, Jt), ni.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Jt.x += 1e-4 : Jt.z += 1e-4, Jt.normalize(), ni.crossVectors(n, Jt)), ni.normalize(), vr.crossVectors(Jt, ni), s[0] = ni.x, s[4] = vr.x, s[8] = Jt.x, s[1] = ni.y, s[5] = vr.y, s[9] = Jt.y, s[2] = ni.z, s[6] = vr.z, s[10] = Jt.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, s = t.elements, r = this.elements, a = n[0], o = n[4], l = n[8], c = n[12], h = n[1], u = n[5], d = n[9], A = n[13], m = n[2], g = n[6], f = n[10], p = n[14], v = n[3], E = n[7], b = n[11], S = n[15], I = s[0], B = s[4], R = s[8], w = s[12], C = s[1], D = s[5], _ = s[9], Q = s[13], H = s[2], j = s[6], V = s[10], J = s[14], G = s[3], te = s[7], le = s[11], me = s[15];
    return r[0] = a * I + o * C + l * H + c * G, r[4] = a * B + o * D + l * j + c * te, r[8] = a * R + o * _ + l * V + c * le, r[12] = a * w + o * Q + l * J + c * me, r[1] = h * I + u * C + d * H + A * G, r[5] = h * B + u * D + d * j + A * te, r[9] = h * R + u * _ + d * V + A * le, r[13] = h * w + u * Q + d * J + A * me, r[2] = m * I + g * C + f * H + p * G, r[6] = m * B + g * D + f * j + p * te, r[10] = m * R + g * _ + f * V + p * le, r[14] = m * w + g * Q + f * J + p * me, r[3] = v * I + E * C + b * H + S * G, r[7] = v * B + E * D + b * j + S * te, r[11] = v * R + E * _ + b * V + S * le, r[15] = v * w + E * Q + b * J + S * me, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], s = e[8], r = e[12], a = e[1], o = e[5], l = e[9], c = e[13], h = e[2], u = e[6], d = e[10], A = e[14], m = e[3], g = e[7], f = e[11], p = e[15];
    return m * (+r * l * u - s * c * u - r * o * d + n * c * d + s * o * A - n * l * A) + g * (+t * l * A - t * c * d + r * a * d - s * a * A + s * c * h - r * l * h) + f * (+t * c * u - t * o * A - r * a * u + n * a * A + r * o * h - n * c * h) + p * (-s * o * h - t * l * u + t * o * d + s * a * u - n * a * d + n * l * h);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = t, s[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8], u = e[9], d = e[10], A = e[11], m = e[12], g = e[13], f = e[14], p = e[15], v = u * f * c - g * d * c + g * l * A - o * f * A - u * l * p + o * d * p, E = m * d * c - h * f * c - m * l * A + a * f * A + h * l * p - a * d * p, b = h * g * c - m * u * c + m * o * A - a * g * A - h * o * p + a * u * p, S = m * u * l - h * g * l - m * o * d + a * g * d + h * o * f - a * u * f, I = t * v + n * E + s * b + r * S;
    if (I === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const B = 1 / I;
    return e[0] = v * B, e[1] = (g * d * r - u * f * r - g * s * A + n * f * A + u * s * p - n * d * p) * B, e[2] = (o * f * r - g * l * r + g * s * c - n * f * c - o * s * p + n * l * p) * B, e[3] = (u * l * r - o * d * r - u * s * c + n * d * c + o * s * A - n * l * A) * B, e[4] = E * B, e[5] = (h * f * r - m * d * r + m * s * A - t * f * A - h * s * p + t * d * p) * B, e[6] = (m * l * r - a * f * r - m * s * c + t * f * c + a * s * p - t * l * p) * B, e[7] = (a * d * r - h * l * r + h * s * c - t * d * c - a * s * A + t * l * A) * B, e[8] = b * B, e[9] = (m * u * r - h * g * r - m * n * A + t * g * A + h * n * p - t * u * p) * B, e[10] = (a * g * r - m * o * r + m * n * c - t * g * c - a * n * p + t * o * p) * B, e[11] = (h * o * r - a * u * r - h * n * c + t * u * c + a * n * A - t * o * A) * B, e[12] = S * B, e[13] = (h * g * s - m * u * s + m * n * d - t * g * d - h * n * f + t * u * f) * B, e[14] = (m * o * s - a * g * s - m * n * l + t * g * l + a * n * f - t * o * f) * B, e[15] = (a * u * s - h * o * s + h * n * l - t * u * l - a * n * d + t * o * d) * B, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, s = e.y, r = e.z;
    return t[0] *= n, t[4] *= s, t[8] *= r, t[1] *= n, t[5] *= s, t[9] *= r, t[2] *= n, t[6] *= s, t[10] *= r, t[3] *= n, t[7] *= s, t[11] *= r, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, s));
  }
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), s = Math.sin(t), r = 1 - n, a = e.x, o = e.y, l = e.z, c = r * a, h = r * o;
    return this.set(
      c * a + n,
      c * o - s * l,
      c * l + s * o,
      0,
      c * o + s * l,
      h * o + n,
      h * l - s * a,
      0,
      c * l - s * o,
      h * l + s * a,
      r * l * l + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, n, s, r, a) {
    return this.set(
      1,
      n,
      r,
      0,
      e,
      1,
      a,
      0,
      t,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, n) {
    const s = this.elements, r = t._x, a = t._y, o = t._z, l = t._w, c = r + r, h = a + a, u = o + o, d = r * c, A = r * h, m = r * u, g = a * h, f = a * u, p = o * u, v = l * c, E = l * h, b = l * u, S = n.x, I = n.y, B = n.z;
    return s[0] = (1 - (g + p)) * S, s[1] = (A + b) * S, s[2] = (m - E) * S, s[3] = 0, s[4] = (A - b) * I, s[5] = (1 - (d + p)) * I, s[6] = (f + v) * I, s[7] = 0, s[8] = (m + E) * B, s[9] = (f - v) * B, s[10] = (1 - (d + g)) * B, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, t, n) {
    const s = this.elements;
    let r = Wi.set(s[0], s[1], s[2]).length();
    const a = Wi.set(s[4], s[5], s[6]).length(), o = Wi.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (r = -r), e.x = s[12], e.y = s[13], e.z = s[14], mn.copy(this);
    const c = 1 / r, h = 1 / a, u = 1 / o;
    return mn.elements[0] *= c, mn.elements[1] *= c, mn.elements[2] *= c, mn.elements[4] *= h, mn.elements[5] *= h, mn.elements[6] *= h, mn.elements[8] *= u, mn.elements[9] *= u, mn.elements[10] *= u, t.setFromRotationMatrix(mn), n.x = r, n.y = a, n.z = o, this;
  }
  makePerspective(e, t, n, s, r, a, o = 2e3) {
    const l = this.elements, c = 2 * r / (t - e), h = 2 * r / (n - s), u = (t + e) / (t - e), d = (n + s) / (n - s);
    let A, m;
    if (o === 2e3)
      A = -(a + r) / (a - r), m = -2 * a * r / (a - r);
    else if (o === 2001)
      A = -a / (a - r), m = -a * r / (a - r);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
    return l[0] = c, l[4] = 0, l[8] = u, l[12] = 0, l[1] = 0, l[5] = h, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = A, l[14] = m, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(e, t, n, s, r, a, o = 2e3) {
    const l = this.elements, c = 1 / (t - e), h = 1 / (n - s), u = 1 / (a - r), d = (t + e) * c, A = (n + s) * h;
    let m, g;
    if (o === 2e3)
      m = (a + r) * u, g = -2 * u;
    else if (o === 2001)
      m = r * u, g = -1 * u;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
    return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -A, l[2] = 0, l[6] = 0, l[10] = g, l[14] = -m, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let s = 0; s < 16; s++)
      if (t[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const Wi = /* @__PURE__ */ new T(), mn = /* @__PURE__ */ new Pe(), ip = /* @__PURE__ */ new T(0, 0, 0), sp = /* @__PURE__ */ new T(1, 1, 1), ni = /* @__PURE__ */ new T(), vr = /* @__PURE__ */ new T(), Jt = /* @__PURE__ */ new T(), _l = /* @__PURE__ */ new Pe(), Ol = /* @__PURE__ */ new dn();
class In {
  constructor(e = 0, t = 0, n = 0, s = In.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, s = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const s = e.elements, r = s[0], a = s[4], o = s[8], l = s[1], c = s[5], h = s[9], u = s[2], d = s[6], A = s[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Qe(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-h, A), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(d, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Qe(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(o, A), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Qe(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-u, A), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, r));
        break;
      case "ZYX":
        this._y = Math.asin(-Qe(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(d, A), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-a, c));
        break;
      case "YZX":
        this._z = Math.asin(Qe(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(o, A));
        break;
      case "XZY":
        this._z = Math.asin(-Qe(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-h, A), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return _l.makeRotationFromQuaternion(e), this.setFromRotationMatrix(_l, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return Ol.setFromEuler(this), this.setFromQuaternion(Ol, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
In.DEFAULT_ORDER = "XYZ";
class Fh {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let rp = 0;
const Gl = /* @__PURE__ */ new T(), Yi = /* @__PURE__ */ new dn(), Nn = /* @__PURE__ */ new Pe(), Er = /* @__PURE__ */ new T(), Ts = /* @__PURE__ */ new T(), ap = /* @__PURE__ */ new T(), op = /* @__PURE__ */ new dn(), Hl = /* @__PURE__ */ new T(1, 0, 0), Vl = /* @__PURE__ */ new T(0, 1, 0), zl = /* @__PURE__ */ new T(0, 0, 1), ql = { type: "added" }, lp = { type: "removed" }, Ki = { type: "childadded", child: null }, wa = { type: "childremoved", child: null };
class At extends Pt {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: rp++ }), this.uuid = En(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = At.DEFAULT_UP.clone();
    const e = new T(), t = new In(), n = new dn(), s = new T(1, 1, 1);
    function r() {
      n.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(r), n._onChange(a), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      modelViewMatrix: {
        value: new Pe()
      },
      normalMatrix: {
        value: new Fe()
      }
    }), this.matrix = new Pe(), this.matrixWorld = new Pe(), this.matrixAutoUpdate = At.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = At.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Fh(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Yi.setFromAxisAngle(e, t), this.quaternion.multiply(Yi), this;
  }
  rotateOnWorldAxis(e, t) {
    return Yi.setFromAxisAngle(e, t), this.quaternion.premultiply(Yi), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Hl, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Vl, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(zl, e);
  }
  translateOnAxis(e, t) {
    return Gl.copy(e).applyQuaternion(this.quaternion), this.position.add(Gl.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(Hl, e);
  }
  translateY(e) {
    return this.translateOnAxis(Vl, e);
  }
  translateZ(e) {
    return this.translateOnAxis(zl, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Nn.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? Er.copy(e) : Er.set(e, t, n);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), Ts.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Nn.lookAt(Ts, Er, this.up) : Nn.lookAt(Er, Ts, this.up), this.quaternion.setFromRotationMatrix(Nn), s && (Nn.extractRotation(s.matrixWorld), Yi.setFromRotationMatrix(Nn), this.quaternion.premultiply(Yi.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(ql), Ki.child = e, this.dispatchEvent(Ki), Ki.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(lp), wa.child = e, this.dispatchEvent(wa), wa.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Nn.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Nn.multiply(e.parent.matrixWorld)), e.applyMatrix4(Nn), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(ql), Ki.child = e, this.dispatchEvent(Ki), Ki.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, s = this.children.length; n < s; n++) {
      const a = this.children[n].getObjectByProperty(e, t);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const s = this.children;
    for (let r = 0, a = s.length; r < a; r++)
      s[r].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ts, e, ap), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ts, op, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, s = t.length; n < s; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, s = t.length; n < s; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, s = t.length; n < s; n++)
      t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
      const s = this.children;
      for (let r = 0, a = s.length; r < a; r++)
        s[r].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((o) => ({
      boxInitialized: o.boxInitialized,
      boxMin: o.box.min.toArray(),
      boxMax: o.box.max.toArray(),
      sphereInitialized: o.sphereInitialized,
      sphereRadius: o.sphere.radius,
      sphereCenter: o.sphere.center.toArray()
    })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
      center: s.boundingSphere.center.toArray(),
      radius: s.boundingSphere.radius
    }), this.boundingBox !== null && (s.boundingBox = {
      min: s.boundingBox.min.toArray(),
      max: s.boundingBox.max.toArray()
    }));
    function r(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = r(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, h = l.length; c < h; c++) {
            const u = l[c];
            r(e.shapes, u);
          }
        else
          r(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(r(e.materials, this.material[l]));
        s.material = o;
      } else
        s.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let o = 0; o < this.children.length; o++)
        s.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        s.animations.push(r(e.animations, l));
      }
    }
    if (t) {
      const o = a(e.geometries), l = a(e.materials), c = a(e.textures), h = a(e.images), u = a(e.shapes), d = a(e.skeletons), A = a(e.animations), m = a(e.nodes);
      o.length > 0 && (n.geometries = o), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), u.length > 0 && (n.shapes = u), d.length > 0 && (n.skeletons = d), A.length > 0 && (n.animations = A), m.length > 0 && (n.nodes = m);
    }
    return n.object = s, n;
    function a(o) {
      const l = [];
      for (const c in o) {
        const h = o[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const s = e.children[n];
        this.add(s.clone());
      }
    return this;
  }
}
At.DEFAULT_UP = /* @__PURE__ */ new T(0, 1, 0);
At.DEFAULT_MATRIX_AUTO_UPDATE = !0;
At.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const gn = /* @__PURE__ */ new T(), Un = /* @__PURE__ */ new T(), ya = /* @__PURE__ */ new T(), Qn = /* @__PURE__ */ new T(), Xi = /* @__PURE__ */ new T(), ji = /* @__PURE__ */ new T(), Wl = /* @__PURE__ */ new T(), Ia = /* @__PURE__ */ new T(), Ma = /* @__PURE__ */ new T(), Sa = /* @__PURE__ */ new T(), Ba = /* @__PURE__ */ new $e(), Ta = /* @__PURE__ */ new $e(), Ra = /* @__PURE__ */ new $e();
class vn {
  constructor(e = new T(), t = new T(), n = new T()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, s) {
    s.subVectors(n, t), gn.subVectors(e, t), s.cross(gn);
    const r = s.lengthSq();
    return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, n, s, r) {
    gn.subVectors(s, t), Un.subVectors(n, t), ya.subVectors(e, t);
    const a = gn.dot(gn), o = gn.dot(Un), l = gn.dot(ya), c = Un.dot(Un), h = Un.dot(ya), u = a * c - o * o;
    if (u === 0)
      return r.set(0, 0, 0), null;
    const d = 1 / u, A = (c * l - o * h) * d, m = (a * h - o * l) * d;
    return r.set(1 - A - m, m, A);
  }
  static containsPoint(e, t, n, s) {
    return this.getBarycoord(e, t, n, s, Qn) === null ? !1 : Qn.x >= 0 && Qn.y >= 0 && Qn.x + Qn.y <= 1;
  }
  static getInterpolation(e, t, n, s, r, a, o, l) {
    return this.getBarycoord(e, t, n, s, Qn) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r, Qn.x), l.addScaledVector(a, Qn.y), l.addScaledVector(o, Qn.z), l);
  }
  static getInterpolatedAttribute(e, t, n, s, r, a) {
    return Ba.setScalar(0), Ta.setScalar(0), Ra.setScalar(0), Ba.fromBufferAttribute(e, t), Ta.fromBufferAttribute(e, n), Ra.fromBufferAttribute(e, s), a.setScalar(0), a.addScaledVector(Ba, r.x), a.addScaledVector(Ta, r.y), a.addScaledVector(Ra, r.z), a;
  }
  static isFrontFacing(e, t, n, s) {
    return gn.subVectors(n, t), Un.subVectors(e, t), gn.cross(Un).dot(s) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, s) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, t, n, s) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return gn.subVectors(this.c, this.b), Un.subVectors(this.a, this.b), gn.cross(Un).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return vn.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return vn.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, s, r) {
    return vn.getInterpolation(e, this.a, this.b, this.c, t, n, s, r);
  }
  containsPoint(e) {
    return vn.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return vn.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, s = this.b, r = this.c;
    let a, o;
    Xi.subVectors(s, n), ji.subVectors(r, n), Ia.subVectors(e, n);
    const l = Xi.dot(Ia), c = ji.dot(Ia);
    if (l <= 0 && c <= 0)
      return t.copy(n);
    Ma.subVectors(e, s);
    const h = Xi.dot(Ma), u = ji.dot(Ma);
    if (h >= 0 && u <= h)
      return t.copy(s);
    const d = l * u - h * c;
    if (d <= 0 && l >= 0 && h <= 0)
      return a = l / (l - h), t.copy(n).addScaledVector(Xi, a);
    Sa.subVectors(e, r);
    const A = Xi.dot(Sa), m = ji.dot(Sa);
    if (m >= 0 && A <= m)
      return t.copy(r);
    const g = A * c - l * m;
    if (g <= 0 && c >= 0 && m <= 0)
      return o = c / (c - m), t.copy(n).addScaledVector(ji, o);
    const f = h * m - A * u;
    if (f <= 0 && u - h >= 0 && A - m >= 0)
      return Wl.subVectors(r, s), o = (u - h) / (u - h + (A - m)), t.copy(s).addScaledVector(Wl, o);
    const p = 1 / (f + g + d);
    return a = g * p, o = d * p, t.copy(n).addScaledVector(Xi, a).addScaledVector(ji, o);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const Nh = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, ii = { h: 0, s: 0, l: 0 }, Cr = { h: 0, s: 0, l: 0 };
function Da(i, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i;
}
class we {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const s = e;
      s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = Rt) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, We.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, s = We.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, We.toWorkingColorSpace(this, s), this;
  }
  setHSL(e, t, n, s = We.workingColorSpace) {
    if (e = Ro(e, 1), t = Qe(t, 0, 1), n = Qe(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const r = n <= 0.5 ? n * (1 + t) : n + t - n * t, a = 2 * n - r;
      this.r = Da(a, r, e + 1 / 3), this.g = Da(a, r, e), this.b = Da(a, r, e - 1 / 3);
    }
    return We.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, t = Rt) {
    function n(r) {
      r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let r;
      const a = s[1], o = s[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setRGB(
              Math.min(255, parseInt(r[1], 10)) / 255,
              Math.min(255, parseInt(r[2], 10)) / 255,
              Math.min(255, parseInt(r[3], 10)) / 255,
              t
            );
          if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setRGB(
              Math.min(100, parseInt(r[1], 10)) / 100,
              Math.min(100, parseInt(r[2], 10)) / 100,
              Math.min(100, parseInt(r[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setHSL(
              parseFloat(r[1]) / 360,
              parseFloat(r[2]) / 100,
              parseFloat(r[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const r = s[1], a = r.length;
      if (a === 3)
        return this.setRGB(
          parseInt(r.charAt(0), 16) / 15,
          parseInt(r.charAt(1), 16) / 15,
          parseInt(r.charAt(2), 16) / 15,
          t
        );
      if (a === 6)
        return this.setHex(parseInt(r, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Rt) {
    const n = Nh[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Wn(e.r), this.g = Wn(e.g), this.b = Wn(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = ls(e.r), this.g = ls(e.g), this.b = ls(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Rt) {
    return We.fromWorkingColorSpace(Nt.copy(this), e), Math.round(Qe(Nt.r * 255, 0, 255)) * 65536 + Math.round(Qe(Nt.g * 255, 0, 255)) * 256 + Math.round(Qe(Nt.b * 255, 0, 255));
  }
  getHexString(e = Rt) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = We.workingColorSpace) {
    We.fromWorkingColorSpace(Nt.copy(this), t);
    const n = Nt.r, s = Nt.g, r = Nt.b, a = Math.max(n, s, r), o = Math.min(n, s, r);
    let l, c;
    const h = (o + a) / 2;
    if (o === a)
      l = 0, c = 0;
    else {
      const u = a - o;
      switch (c = h <= 0.5 ? u / (a + o) : u / (2 - a - o), a) {
        case n:
          l = (s - r) / u + (s < r ? 6 : 0);
          break;
        case s:
          l = (r - n) / u + 2;
          break;
        case r:
          l = (n - s) / u + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = h, e;
  }
  getRGB(e, t = We.workingColorSpace) {
    return We.fromWorkingColorSpace(Nt.copy(this), t), e.r = Nt.r, e.g = Nt.g, e.b = Nt.b, e;
  }
  getStyle(e = Rt) {
    We.fromWorkingColorSpace(Nt.copy(this), e);
    const t = Nt.r, n = Nt.g, s = Nt.b;
    return e !== Rt ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(ii), this.setHSL(ii.h + e, ii.s + t, ii.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(ii), e.getHSL(Cr);
    const n = Vs(ii.h, Cr.h, t), s = Vs(ii.s, Cr.s, t), r = Vs(ii.l, Cr.l, t);
    return this.setHSL(n, s, r), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, s = this.b, r = e.elements;
    return this.r = r[0] * t + r[3] * n + r[6] * s, this.g = r[1] * t + r[4] * n + r[7] * s, this.b = r[2] * t + r[5] * n + r[8] * s, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Nt = /* @__PURE__ */ new we();
we.NAMES = Nh;
let cp = 0;
class yn extends Pt {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: cp++ }), this.uuid = En(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new we(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const s = this[t];
        if (s === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[t] = n;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n.blending = this.blending), this.side !== 0 && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== 204 && (n.blendSrc = this.blendSrc), this.blendDst !== 205 && (n.blendDst = this.blendDst), this.blendEquation !== 100 && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== 3 && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== 519 && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== 7680 && (n.stencilFail = this.stencilFail), this.stencilZFail !== 7680 && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== 7680 && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function s(r) {
      const a = [];
      for (const o in r) {
        const l = r[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (t) {
      const r = s(e.textures), a = s(e.images);
      r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const s = t.length;
      n = new Array(s);
      for (let r = 0; r !== s; ++r)
        n[r] = t[r].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class Hn extends yn {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new we(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new In(), this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Ct = /* @__PURE__ */ new T(), xr = /* @__PURE__ */ new Ie();
let hp = 0;
class Ht {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: hp++ }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = 35044, this.updateRanges = [], this.gpuType = 1015, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let s = 0, r = this.itemSize; s < r; s++)
      this.array[e + s] = t.array[n + s];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        xr.fromBufferAttribute(this, t), xr.applyMatrix3(e), this.setXY(t, xr.x, xr.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        Ct.fromBufferAttribute(this, t), Ct.applyMatrix3(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ct.fromBufferAttribute(this, t), Ct.applyMatrix4(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ct.fromBufferAttribute(this, t), Ct.applyNormalMatrix(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ct.fromBufferAttribute(this, t), Ct.transformDirection(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = bn(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = st(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = bn(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = st(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = bn(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = st(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = bn(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = st(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = bn(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = st(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = st(t, this.array), n = st(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, s) {
    return e *= this.itemSize, this.normalized && (t = st(t, this.array), n = st(n, this.array), s = st(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = s, this;
  }
  setXYZW(e, t, n, s, r) {
    return e *= this.itemSize, this.normalized && (t = st(t, this.array), n = st(n, this.array), s = st(s, this.array), r = st(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = s, this.array[e + 3] = r, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== 35044 && (e.usage = this.usage), e;
  }
}
class Uh extends Ht {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class Qh extends Ht {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class Oe extends Ht {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let up = 0;
const rn = /* @__PURE__ */ new Pe(), Pa = /* @__PURE__ */ new At(), Ji = /* @__PURE__ */ new T(), Zt = /* @__PURE__ */ new Jn(), Rs = /* @__PURE__ */ new Jn(), Tt = /* @__PURE__ */ new T();
class Bt extends Pt {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: up++ }), this.uuid = En(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (Rh(e) ? Qh : Uh)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new Fe().getNormalMatrix(e);
      n.applyNormalMatrix(r), n.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return rn.makeRotationFromQuaternion(e), this.applyMatrix4(rn), this;
  }
  rotateX(e) {
    return rn.makeRotationX(e), this.applyMatrix4(rn), this;
  }
  rotateY(e) {
    return rn.makeRotationY(e), this.applyMatrix4(rn), this;
  }
  rotateZ(e) {
    return rn.makeRotationZ(e), this.applyMatrix4(rn), this;
  }
  translate(e, t, n) {
    return rn.makeTranslation(e, t, n), this.applyMatrix4(rn), this;
  }
  scale(e, t, n) {
    return rn.makeScale(e, t, n), this.applyMatrix4(rn), this;
  }
  lookAt(e) {
    return Pa.lookAt(e), Pa.updateMatrix(), this.applyMatrix4(Pa.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Ji).negate(), this.translate(Ji.x, Ji.y, Ji.z), this;
  }
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const n = [];
      for (let s = 0, r = e.length; s < r; s++) {
        const a = e[s];
        n.push(a.x, a.y, a.z || 0);
      }
      this.setAttribute("position", new Oe(n, 3));
    } else {
      const n = Math.min(e.length, t.count);
      for (let s = 0; s < n; s++) {
        const r = e[s];
        t.setXYZ(s, r.x, r.y, r.z || 0);
      }
      e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Jn());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new T(-1 / 0, -1 / 0, -1 / 0),
        new T(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, s = t.length; n < s; n++) {
          const r = t[n];
          Zt.setFromBufferAttribute(r), this.morphTargetsRelative ? (Tt.addVectors(this.boundingBox.min, Zt.min), this.boundingBox.expandByPoint(Tt), Tt.addVectors(this.boundingBox.max, Zt.max), this.boundingBox.expandByPoint(Tt)) : (this.boundingBox.expandByPoint(Zt.min), this.boundingBox.expandByPoint(Zt.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Tn());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new T(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (Zt.setFromBufferAttribute(e), t)
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r];
          Rs.setFromBufferAttribute(o), this.morphTargetsRelative ? (Tt.addVectors(Zt.min, Rs.min), Zt.expandByPoint(Tt), Tt.addVectors(Zt.max, Rs.max), Zt.expandByPoint(Tt)) : (Zt.expandByPoint(Rs.min), Zt.expandByPoint(Rs.max));
        }
      Zt.getCenter(n);
      let s = 0;
      for (let r = 0, a = e.count; r < a; r++)
        Tt.fromBufferAttribute(e, r), s = Math.max(s, n.distanceToSquared(Tt));
      if (t)
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r], l = this.morphTargetsRelative;
          for (let c = 0, h = o.count; c < h; c++)
            Tt.fromBufferAttribute(o, c), l && (Ji.fromBufferAttribute(e, c), Tt.add(Ji)), s = Math.max(s, n.distanceToSquared(Tt));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = t.position, s = t.normal, r = t.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ht(new Float32Array(4 * n.count), 4));
    const a = this.getAttribute("tangent"), o = [], l = [];
    for (let R = 0; R < n.count; R++)
      o[R] = new T(), l[R] = new T();
    const c = new T(), h = new T(), u = new T(), d = new Ie(), A = new Ie(), m = new Ie(), g = new T(), f = new T();
    function p(R, w, C) {
      c.fromBufferAttribute(n, R), h.fromBufferAttribute(n, w), u.fromBufferAttribute(n, C), d.fromBufferAttribute(r, R), A.fromBufferAttribute(r, w), m.fromBufferAttribute(r, C), h.sub(c), u.sub(c), A.sub(d), m.sub(d);
      const D = 1 / (A.x * m.y - m.x * A.y);
      isFinite(D) && (g.copy(h).multiplyScalar(m.y).addScaledVector(u, -A.y).multiplyScalar(D), f.copy(u).multiplyScalar(A.x).addScaledVector(h, -m.x).multiplyScalar(D), o[R].add(g), o[w].add(g), o[C].add(g), l[R].add(f), l[w].add(f), l[C].add(f));
    }
    let v = this.groups;
    v.length === 0 && (v = [{
      start: 0,
      count: e.count
    }]);
    for (let R = 0, w = v.length; R < w; ++R) {
      const C = v[R], D = C.start, _ = C.count;
      for (let Q = D, H = D + _; Q < H; Q += 3)
        p(
          e.getX(Q + 0),
          e.getX(Q + 1),
          e.getX(Q + 2)
        );
    }
    const E = new T(), b = new T(), S = new T(), I = new T();
    function B(R) {
      S.fromBufferAttribute(s, R), I.copy(S);
      const w = o[R];
      E.copy(w), E.sub(S.multiplyScalar(S.dot(w))).normalize(), b.crossVectors(I, w);
      const D = b.dot(l[R]) < 0 ? -1 : 1;
      a.setXYZW(R, E.x, E.y, E.z, D);
    }
    for (let R = 0, w = v.length; R < w; ++R) {
      const C = v[R], D = C.start, _ = C.count;
      for (let Q = D, H = D + _; Q < H; Q += 3)
        B(e.getX(Q + 0)), B(e.getX(Q + 1)), B(e.getX(Q + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Ht(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let d = 0, A = n.count; d < A; d++)
          n.setXYZ(d, 0, 0, 0);
      const s = new T(), r = new T(), a = new T(), o = new T(), l = new T(), c = new T(), h = new T(), u = new T();
      if (e)
        for (let d = 0, A = e.count; d < A; d += 3) {
          const m = e.getX(d + 0), g = e.getX(d + 1), f = e.getX(d + 2);
          s.fromBufferAttribute(t, m), r.fromBufferAttribute(t, g), a.fromBufferAttribute(t, f), h.subVectors(a, r), u.subVectors(s, r), h.cross(u), o.fromBufferAttribute(n, m), l.fromBufferAttribute(n, g), c.fromBufferAttribute(n, f), o.add(h), l.add(h), c.add(h), n.setXYZ(m, o.x, o.y, o.z), n.setXYZ(g, l.x, l.y, l.z), n.setXYZ(f, c.x, c.y, c.z);
        }
      else
        for (let d = 0, A = t.count; d < A; d += 3)
          s.fromBufferAttribute(t, d + 0), r.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), h.subVectors(a, r), u.subVectors(s, r), h.cross(u), n.setXYZ(d + 0, h.x, h.y, h.z), n.setXYZ(d + 1, h.x, h.y, h.z), n.setXYZ(d + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Tt.fromBufferAttribute(e, t), Tt.normalize(), e.setXYZ(t, Tt.x, Tt.y, Tt.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array, h = o.itemSize, u = o.normalized, d = new c.constructor(l.length * h);
      let A = 0, m = 0;
      for (let g = 0, f = l.length; g < f; g++) {
        o.isInterleavedBufferAttribute ? A = l[g] * o.data.stride + o.offset : A = l[g] * h;
        for (let p = 0; p < h; p++)
          d[m++] = c[A++];
      }
      return new Ht(d, h, u);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Bt(), n = this.index.array, s = this.attributes;
    for (const o in s) {
      const l = s[o], c = e(l, n);
      t.setAttribute(o, c);
    }
    const r = this.morphAttributes;
    for (const o in r) {
      const l = [], c = r[o];
      for (let h = 0, u = c.length; h < u; h++) {
        const d = c[h], A = e(d, n);
        l.push(A);
      }
      t.morphAttributes[o] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const s = {};
    let r = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], h = [];
      for (let u = 0, d = c.length; u < d; u++) {
        const A = c[u];
        h.push(A.toJSON(e.data));
      }
      h.length > 0 && (s[l] = h, r = !0);
    }
    r && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return o !== null && (e.data.boundingSphere = {
      center: o.center.toArray(),
      radius: o.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const s = e.attributes;
    for (const c in s) {
      const h = s[c];
      this.setAttribute(c, h.clone(t));
    }
    const r = e.morphAttributes;
    for (const c in r) {
      const h = [], u = r[c];
      for (let d = 0, A = u.length; d < A; d++)
        h.push(u[d].clone(t));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, h = a.length; c < h; c++) {
      const u = a[c];
      this.addGroup(u.start, u.count, u.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Yl = /* @__PURE__ */ new Pe(), vi = /* @__PURE__ */ new ia(), wr = /* @__PURE__ */ new Tn(), Kl = /* @__PURE__ */ new T(), yr = /* @__PURE__ */ new T(), Ir = /* @__PURE__ */ new T(), Mr = /* @__PURE__ */ new T(), La = /* @__PURE__ */ new T(), Sr = /* @__PURE__ */ new T(), Xl = /* @__PURE__ */ new T(), Br = /* @__PURE__ */ new T();
class ot extends At {
  constructor(e = new Bt(), t = new Hn()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const s = t[n[0]];
      if (s !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = s.length; r < a; r++) {
          const o = s[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry, s = n.attributes.position, r = n.morphAttributes.position, a = n.morphTargetsRelative;
    t.fromBufferAttribute(s, e);
    const o = this.morphTargetInfluences;
    if (r && o) {
      Sr.set(0, 0, 0);
      for (let l = 0, c = r.length; l < c; l++) {
        const h = o[l], u = r[l];
        h !== 0 && (La.fromBufferAttribute(u, e), a ? Sr.addScaledVector(La, h) : Sr.addScaledVector(La.sub(t), h));
      }
      t.add(Sr);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry, s = this.material, r = this.matrixWorld;
    s !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), wr.copy(n.boundingSphere), wr.applyMatrix4(r), vi.copy(e.ray).recast(e.near), !(wr.containsPoint(vi.origin) === !1 && (vi.intersectSphere(wr, Kl) === null || vi.origin.distanceToSquared(Kl) > (e.far - e.near) ** 2)) && (Yl.copy(r).invert(), vi.copy(e.ray).applyMatrix4(Yl), !(n.boundingBox !== null && vi.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, vi)));
  }
  _computeIntersections(e, t, n) {
    let s;
    const r = this.geometry, a = this.material, o = r.index, l = r.attributes.position, c = r.attributes.uv, h = r.attributes.uv1, u = r.attributes.normal, d = r.groups, A = r.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let m = 0, g = d.length; m < g; m++) {
          const f = d[m], p = a[f.materialIndex], v = Math.max(f.start, A.start), E = Math.min(o.count, Math.min(f.start + f.count, A.start + A.count));
          for (let b = v, S = E; b < S; b += 3) {
            const I = o.getX(b), B = o.getX(b + 1), R = o.getX(b + 2);
            s = Tr(this, p, e, n, c, h, u, I, B, R), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = f.materialIndex, t.push(s));
          }
        }
      else {
        const m = Math.max(0, A.start), g = Math.min(o.count, A.start + A.count);
        for (let f = m, p = g; f < p; f += 3) {
          const v = o.getX(f), E = o.getX(f + 1), b = o.getX(f + 2);
          s = Tr(this, a, e, n, c, h, u, v, E, b), s && (s.faceIndex = Math.floor(f / 3), t.push(s));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let m = 0, g = d.length; m < g; m++) {
          const f = d[m], p = a[f.materialIndex], v = Math.max(f.start, A.start), E = Math.min(l.count, Math.min(f.start + f.count, A.start + A.count));
          for (let b = v, S = E; b < S; b += 3) {
            const I = b, B = b + 1, R = b + 2;
            s = Tr(this, p, e, n, c, h, u, I, B, R), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = f.materialIndex, t.push(s));
          }
        }
      else {
        const m = Math.max(0, A.start), g = Math.min(l.count, A.start + A.count);
        for (let f = m, p = g; f < p; f += 3) {
          const v = f, E = f + 1, b = f + 2;
          s = Tr(this, a, e, n, c, h, u, v, E, b), s && (s.faceIndex = Math.floor(f / 3), t.push(s));
        }
      }
  }
}
function dp(i, e, t, n, s, r, a, o) {
  let l;
  if (e.side === 1 ? l = n.intersectTriangle(a, r, s, !0, o) : l = n.intersectTriangle(s, r, a, e.side === 0, o), l === null) return null;
  Br.copy(o), Br.applyMatrix4(i.matrixWorld);
  const c = t.ray.origin.distanceTo(Br);
  return c < t.near || c > t.far ? null : {
    distance: c,
    point: Br.clone(),
    object: i
  };
}
function Tr(i, e, t, n, s, r, a, o, l, c) {
  i.getVertexPosition(o, yr), i.getVertexPosition(l, Ir), i.getVertexPosition(c, Mr);
  const h = dp(i, e, t, n, yr, Ir, Mr, Xl);
  if (h) {
    const u = new T();
    vn.getBarycoord(Xl, yr, Ir, Mr, u), s && (h.uv = vn.getInterpolatedAttribute(s, o, l, c, u, new Ie())), r && (h.uv1 = vn.getInterpolatedAttribute(r, o, l, c, u, new Ie())), a && (h.normal = vn.getInterpolatedAttribute(a, o, l, c, u, new T()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const d = {
      a: o,
      b: l,
      c,
      normal: new T(),
      materialIndex: 0
    };
    vn.getNormal(yr, Ir, Mr, d.normal), h.face = d, h.barycoord = u;
  }
  return h;
}
class bs extends Bt {
  constructor(e = 1, t = 1, n = 1, s = 1, r = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: s,
      heightSegments: r,
      depthSegments: a
    };
    const o = this;
    s = Math.floor(s), r = Math.floor(r), a = Math.floor(a);
    const l = [], c = [], h = [], u = [];
    let d = 0, A = 0;
    m("z", "y", "x", -1, -1, n, t, e, a, r, 0), m("z", "y", "x", 1, -1, n, t, -e, a, r, 1), m("x", "z", "y", 1, 1, e, n, t, s, a, 2), m("x", "z", "y", 1, -1, e, n, -t, s, a, 3), m("x", "y", "z", 1, -1, e, t, n, s, r, 4), m("x", "y", "z", -1, -1, e, t, -n, s, r, 5), this.setIndex(l), this.setAttribute("position", new Oe(c, 3)), this.setAttribute("normal", new Oe(h, 3)), this.setAttribute("uv", new Oe(u, 2));
    function m(g, f, p, v, E, b, S, I, B, R, w) {
      const C = b / B, D = S / R, _ = b / 2, Q = S / 2, H = I / 2, j = B + 1, V = R + 1;
      let J = 0, G = 0;
      const te = new T();
      for (let le = 0; le < V; le++) {
        const me = le * D - Q;
        for (let Re = 0; Re < j; Re++) {
          const Ge = Re * C - _;
          te[g] = Ge * v, te[f] = me * E, te[p] = H, c.push(te.x, te.y, te.z), te[g] = 0, te[f] = 0, te[p] = I > 0 ? 1 : -1, h.push(te.x, te.y, te.z), u.push(Re / B), u.push(1 - le / R), J += 1;
        }
      }
      for (let le = 0; le < R; le++)
        for (let me = 0; me < B; me++) {
          const Re = d + me + j * le, Ge = d + me + j * (le + 1), q = d + (me + 1) + j * (le + 1), ne = d + (me + 1) + j * le;
          l.push(Re, Ge, ne), l.push(Ge, q, ne), G += 6;
        }
      o.addGroup(A, G, w), A += G, d += J;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new bs(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function ps(i) {
  const e = {};
  for (const t in i) {
    e[t] = {};
    for (const n in i[t]) {
      const s = i[t][n];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = s.clone() : Array.isArray(s) ? e[t][n] = s.slice() : e[t][n] = s;
    }
  }
  return e;
}
function Ot(i) {
  const e = {};
  for (let t = 0; t < i.length; t++) {
    const n = ps(i[t]);
    for (const s in n)
      e[s] = n[s];
  }
  return e;
}
function pp(i) {
  const e = [];
  for (let t = 0; t < i.length; t++)
    e.push(i[t].clone());
  return e;
}
function kh(i) {
  const e = i.getRenderTarget();
  return e === null ? i.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : We.workingColorSpace;
}
const Ap = { clone: ps, merge: Ot };
var fp = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, mp = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Mn extends yn {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = fp, this.fragmentShader = mp, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ps(e.uniforms), this.uniformsGroups = pp(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const s in this.uniforms) {
      const a = this.uniforms[s].value;
      a && a.isTexture ? t.uniforms[s] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? t.uniforms[s] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? t.uniforms[s] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? t.uniforms[s] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? t.uniforms[s] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? t.uniforms[s] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? t.uniforms[s] = {
        type: "m4",
        value: a.toArray()
      } : t.uniforms[s] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const s in this.extensions)
      this.extensions[s] === !0 && (n[s] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class _h extends At {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Pe(), this.projectionMatrix = new Pe(), this.projectionMatrixInverse = new Pe(), this.coordinateSystem = 2e3;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const si = /* @__PURE__ */ new T(), jl = /* @__PURE__ */ new Ie(), Jl = /* @__PURE__ */ new Ie();
class Gt extends _h {
  constructor(e = 50, t = 1, n = 0.1, s = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = s, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = ds * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   *
   * @returns {number}
   */
  getFocalLength() {
    const e = Math.tan(Hs * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return ds * 2 * Math.atan(
      Math.tan(Hs * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   *
   * @param {number} distance
   * @param {Vector2} minTarget
   * @param {Vector2} maxTarget
   */
  getViewBounds(e, t, n) {
    si.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(si.x, si.y).multiplyScalar(-e / si.z), si.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(si.x, si.y).multiplyScalar(-e / si.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   *
   * @param {number} distance
   * @param {Vector2} target - Vector2 target used to store result where x is width and y is height.
   * @returns {Vector2}
   */
  getViewSize(e, t) {
    return this.getViewBounds(e, jl, Jl), t.subVectors(Jl, jl);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param {number} fullWidth
   * @param {number} fullHeight
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   */
  setViewOffset(e, t, n, s, r, a) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(Hs * 0.5 * this.fov) / this.zoom, n = 2 * t, s = this.aspect * n, r = -0.5 * s;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth, c = a.fullHeight;
      r += a.offsetX * s / l, t -= a.offsetY * n / c, s *= a.width / l, n *= a.height / c;
    }
    const o = this.filmOffset;
    o !== 0 && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + s, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const Zi = -90, $i = 1;
class gp extends At {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const s = new Gt(Zi, $i, e, t);
    s.layers = this.layers, this.add(s);
    const r = new Gt(Zi, $i, e, t);
    r.layers = this.layers, this.add(r);
    const a = new Gt(Zi, $i, e, t);
    a.layers = this.layers, this.add(a);
    const o = new Gt(Zi, $i, e, t);
    o.layers = this.layers, this.add(o);
    const l = new Gt(Zi, $i, e, t);
    l.layers = this.layers, this.add(l);
    const c = new Gt(Zi, $i, e, t);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, s, r, a, o, l] = t;
    for (const c of t) this.remove(c);
    if (e === 2e3)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (e === 2001)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const c of t)
      this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: s } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [r, a, o, l, c, h] = this.children, u = e.getRenderTarget(), d = e.getActiveCubeFace(), A = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = !1;
    const g = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, s), e.render(t, r), e.setRenderTarget(n, 1, s), e.render(t, a), e.setRenderTarget(n, 2, s), e.render(t, o), e.setRenderTarget(n, 3, s), e.render(t, l), e.setRenderTarget(n, 4, s), e.render(t, c), n.texture.generateMipmaps = g, e.setRenderTarget(n, 5, s), e.render(t, h), e.setRenderTarget(u, d, A), e.xr.enabled = m, n.texture.needsPMREMUpdate = !0;
  }
}
class Oh extends It {
  constructor(e, t, n, s, r, a, o, l, c, h) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : 301, super(e, t, n, s, r, a, o, l, c, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class bp extends Kn {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, s = [n, n, n, n, n, n];
    this.texture = new Oh(s, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : 1006;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, s = new bs(5, 5, 5), r = new Mn({
      name: "CubemapFromEquirect",
      uniforms: ps(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: 1,
      blending: 0
    });
    r.uniforms.tEquirect.value = t;
    const a = new ot(s, r), o = t.minFilter;
    return t.minFilter === 1008 && (t.minFilter = 1006), new gp(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(e, t, n, s) {
    const r = e.getRenderTarget();
    for (let a = 0; a < 6; a++)
      e.setRenderTarget(this, a), e.clear(t, n, s);
    e.setRenderTarget(r);
  }
}
class Bi extends At {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const vp = { type: "move" };
class Fa {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Bi(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Bi(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new T(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new T()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Bi(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new T(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new T()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let s = null, r = null, a = null;
    const o = this._targetRay, l = this._grip, c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const g of e.hand.values()) {
          const f = t.getJointPose(g, n), p = this._getHandJoint(c, g);
          f !== null && (p.matrix.fromArray(f.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = !0, p.jointRadius = f.radius), p.visible = f !== null;
        }
        const h = c.joints["index-finger-tip"], u = c.joints["thumb-tip"], d = h.position.distanceTo(u.position), A = 0.02, m = 5e-3;
        c.inputState.pinching && d > A + m ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && d <= A - m && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
      o !== null && (s = t.getPose(e.targetRaySpace, n), s === null && r !== null && (s = r), s !== null && (o.matrix.fromArray(s.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(s.linearVelocity)) : o.hasLinearVelocity = !1, s.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(s.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(vp)));
    }
    return o !== null && (o.visible = s !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = a !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new Bi();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class Na extends At {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new In(), this.environmentIntensity = 1, this.environmentRotation = new In(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
}
class Ep {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = 35044, this.updateRanges = [], this.version = 0, this.uuid = En();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let s = 0, r = this.stride; s < r; s++)
      this.array[e + s] = t.array[n + s];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = En()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = En()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const kt = /* @__PURE__ */ new T();
class Do {
  constructor(e, t, n, s = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = s;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      kt.fromBufferAttribute(this, t), kt.applyMatrix4(e), this.setXYZ(t, kt.x, kt.y, kt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      kt.fromBufferAttribute(this, t), kt.applyNormalMatrix(e), this.setXYZ(t, kt.x, kt.y, kt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      kt.fromBufferAttribute(this, t), kt.transformDirection(e), this.setXYZ(t, kt.x, kt.y, kt.z);
    return this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = bn(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = st(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
  }
  setX(e, t) {
    return this.normalized && (t = st(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = st(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = st(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = st(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = bn(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = bn(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = bn(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = bn(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = st(t, this.array), n = st(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = st(t, this.array), n = st(n, this.array), s = st(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
  }
  setXYZW(e, t, n, s, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = st(t, this.array), n = st(n, this.array), s = st(s, this.array), r = st(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = r, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[s + r]);
      }
      return new Ht(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Do(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[s + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
const Zl = /* @__PURE__ */ new T(), $l = /* @__PURE__ */ new $e(), ec = /* @__PURE__ */ new $e(), Cp = /* @__PURE__ */ new T(), tc = /* @__PURE__ */ new Pe(), Rr = /* @__PURE__ */ new T(), Ua = /* @__PURE__ */ new Tn(), nc = /* @__PURE__ */ new Pe(), Qa = /* @__PURE__ */ new ia();
class xp extends ot {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Pl, this.bindMatrix = new Pe(), this.bindMatrixInverse = new Pe(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Jn()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Rr), this.boundingBox.expandByPoint(Rr);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Tn()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Rr), this.boundingSphere.expandByPoint(Rr);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const n = this.material, s = this.matrixWorld;
    n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ua.copy(this.boundingSphere), Ua.applyMatrix4(s), e.ray.intersectsSphere(Ua) !== !1 && (nc.copy(s).invert(), Qa.copy(e.ray).applyMatrix4(nc), !(this.boundingBox !== null && Qa.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Qa)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new $e(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, s = t.count; n < s; n++) {
      e.fromBufferAttribute(t, n);
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === Pl ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Td ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton, s = this.geometry;
    $l.fromBufferAttribute(s.attributes.skinIndex, e), ec.fromBufferAttribute(s.attributes.skinWeight, e), Zl.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const a = ec.getComponent(r);
      if (a !== 0) {
        const o = $l.getComponent(r);
        tc.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(Cp.copy(Zl).applyMatrix4(tc), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class Gh extends At {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Po extends It {
  constructor(e = null, t = 1, n = 1, s, r, a, o, l, c = 1003, h = 1003, u, d) {
    super(null, a, o, l, c, h, s, r, u, d), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const ic = /* @__PURE__ */ new Pe(), wp = /* @__PURE__ */ new Pe();
class Lo {
  constructor(e = [], t = []) {
    this.uuid = En(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, s = this.bones.length; n < s; n++)
        this.boneInverses.push(new Pe());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new Pe();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, s = this.boneTexture;
    for (let r = 0, a = e.length; r < a; r++) {
      const o = e[r] ? e[r].matrixWorld : wp;
      ic.multiplyMatrices(o, t[r]), ic.toArray(n, r * 16);
    }
    s !== null && (s.needsUpdate = !0);
  }
  clone() {
    return new Lo(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Po(t, e, e, 1023, 1015);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const s = this.bones[t];
      if (s.name === e)
        return s;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, s = e.bones.length; n < s; n++) {
      const r = e.bones[n];
      let a = t[r];
      a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new Gh()), this.bones.push(a), this.boneInverses.push(new Pe().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let s = 0, r = t.length; s < r; s++) {
      const a = t[s];
      e.bones.push(a.uuid);
      const o = n[s];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class mo extends Ht {
  constructor(e, t, n, s = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const es = /* @__PURE__ */ new Pe(), sc = /* @__PURE__ */ new Pe(), Dr = [], rc = /* @__PURE__ */ new Jn(), yp = /* @__PURE__ */ new Pe(), Ds = /* @__PURE__ */ new ot(), Ps = /* @__PURE__ */ new Tn();
class Ip extends ot {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new mo(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let s = 0; s < n; s++)
      this.setMatrixAt(s, yp);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new Jn()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, es), rc.copy(e.boundingBox).applyMatrix4(es), this.boundingBox.union(rc);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Tn()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, es), Ps.copy(e.boundingSphere).applyMatrix4(es), this.boundingSphere.union(Ps);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const n = t.morphTargetInfluences, s = this.morphTexture.source.data.data, r = n.length + 1, a = e * r + 1;
    for (let o = 0; o < n.length; o++)
      n[o] = s[a + o];
  }
  raycast(e, t) {
    const n = this.matrixWorld, s = this.count;
    if (Ds.geometry = this.geometry, Ds.material = this.material, Ds.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ps.copy(this.boundingSphere), Ps.applyMatrix4(n), e.ray.intersectsSphere(Ps) !== !1))
      for (let r = 0; r < s; r++) {
        this.getMatrixAt(r, es), sc.multiplyMatrices(n, es), Ds.matrixWorld = sc, Ds.raycast(e, Dr);
        for (let a = 0, o = Dr.length; a < o; a++) {
          const l = Dr[a];
          l.instanceId = r, l.object = this, t.push(l);
        }
        Dr.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new mo(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const n = t.morphTargetInfluences, s = n.length + 1;
    this.morphTexture === null && (this.morphTexture = new Po(new Float32Array(s * this.count), s, this.count, 1028, 1015));
    const r = this.morphTexture.source.data.data;
    let a = 0;
    for (let c = 0; c < n.length; c++)
      a += n[c];
    const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, l = s * e;
    r[l] = o, r.set(n, l + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
  }
}
const ka = /* @__PURE__ */ new T(), Mp = /* @__PURE__ */ new T(), Sp = /* @__PURE__ */ new Fe();
class Ii {
  constructor(e = new T(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, s) {
    return this.normal.set(e, t, n), this.constant = s, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const s = ka.subVectors(n, t).cross(Mp.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(ka), s = this.normal.dot(n);
    if (s === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / s;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || Sp.getNormalMatrix(e), s = this.coplanarPoint(ka).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
    return this.constant = -s.dot(r), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ei = /* @__PURE__ */ new Tn(), Pr = /* @__PURE__ */ new T();
class Fo {
  constructor(e = new Ii(), t = new Ii(), n = new Ii(), s = new Ii(), r = new Ii(), a = new Ii()) {
    this.planes = [e, t, n, s, r, a];
  }
  set(e, t, n, s, r, a) {
    const o = this.planes;
    return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(s), o[4].copy(r), o[5].copy(a), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = 2e3) {
    const n = this.planes, s = e.elements, r = s[0], a = s[1], o = s[2], l = s[3], c = s[4], h = s[5], u = s[6], d = s[7], A = s[8], m = s[9], g = s[10], f = s[11], p = s[12], v = s[13], E = s[14], b = s[15];
    if (n[0].setComponents(l - r, d - c, f - A, b - p).normalize(), n[1].setComponents(l + r, d + c, f + A, b + p).normalize(), n[2].setComponents(l + a, d + h, f + m, b + v).normalize(), n[3].setComponents(l - a, d - h, f - m, b - v).normalize(), n[4].setComponents(l - o, d - u, f - g, b - E).normalize(), t === 2e3)
      n[5].setComponents(l + o, d + u, f + g, b + E).normalize();
    else if (t === 2001)
      n[5].setComponents(o, u, g, E).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Ei.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), Ei.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Ei);
  }
  intersectsSprite(e) {
    return Ei.center.set(0, 0, 0), Ei.radius = 0.7071067811865476, Ei.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ei);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, s = -e.radius;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(n) < s)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const s = t[n];
      if (Pr.x = s.normal.x > 0 ? e.max.x : e.min.x, Pr.y = s.normal.y > 0 ? e.max.y : e.min.y, Pr.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(Pr) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class No extends yn {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new we(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const Xr = /* @__PURE__ */ new T(), jr = /* @__PURE__ */ new T(), ac = /* @__PURE__ */ new Pe(), Ls = /* @__PURE__ */ new ia(), Lr = /* @__PURE__ */ new Tn(), _a = /* @__PURE__ */ new T(), oc = /* @__PURE__ */ new T();
class Uo extends At {
  constructor(e = new Bt(), t = new No()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let s = 1, r = t.count; s < r; s++)
        Xr.fromBufferAttribute(t, s - 1), jr.fromBufferAttribute(t, s), n[s] = n[s - 1], n[s] += Xr.distanceTo(jr);
      e.setAttribute("lineDistance", new Oe(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, s = this.matrixWorld, r = e.params.Line.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Lr.copy(n.boundingSphere), Lr.applyMatrix4(s), Lr.radius += r, e.ray.intersectsSphere(Lr) === !1) return;
    ac.copy(s).invert(), Ls.copy(e.ray).applyMatrix4(ac);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = this.isLineSegments ? 2 : 1, h = n.index, d = n.attributes.position;
    if (h !== null) {
      const A = Math.max(0, a.start), m = Math.min(h.count, a.start + a.count);
      for (let g = A, f = m - 1; g < f; g += c) {
        const p = h.getX(g), v = h.getX(g + 1), E = Fr(this, e, Ls, l, p, v, g);
        E && t.push(E);
      }
      if (this.isLineLoop) {
        const g = h.getX(m - 1), f = h.getX(A), p = Fr(this, e, Ls, l, g, f, m - 1);
        p && t.push(p);
      }
    } else {
      const A = Math.max(0, a.start), m = Math.min(d.count, a.start + a.count);
      for (let g = A, f = m - 1; g < f; g += c) {
        const p = Fr(this, e, Ls, l, g, g + 1, g);
        p && t.push(p);
      }
      if (this.isLineLoop) {
        const g = Fr(this, e, Ls, l, m - 1, A, m - 1);
        g && t.push(g);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const s = t[n[0]];
      if (s !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = s.length; r < a; r++) {
          const o = s[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
}
function Fr(i, e, t, n, s, r, a) {
  const o = i.geometry.attributes.position;
  if (Xr.fromBufferAttribute(o, s), jr.fromBufferAttribute(o, r), t.distanceSqToSegment(Xr, jr, _a, oc) > n) return;
  _a.applyMatrix4(i.matrixWorld);
  const c = e.ray.origin.distanceTo(_a);
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: oc.clone().applyMatrix4(i.matrixWorld),
      index: a,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: i
    };
}
const lc = /* @__PURE__ */ new T(), cc = /* @__PURE__ */ new T();
class Hh extends Uo {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let s = 0, r = t.count; s < r; s += 2)
        lc.fromBufferAttribute(t, s), cc.fromBufferAttribute(t, s + 1), n[s] = s === 0 ? 0 : n[s - 1], n[s + 1] = n[s] + lc.distanceTo(cc);
      e.setAttribute("lineDistance", new Oe(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class Bp extends Uo {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class Vh extends yn {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new we(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const hc = /* @__PURE__ */ new Pe(), go = /* @__PURE__ */ new ia(), Nr = /* @__PURE__ */ new Tn(), Ur = /* @__PURE__ */ new T();
class Tp extends At {
  constructor(e = new Bt(), t = new Vh()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, s = this.matrixWorld, r = e.params.Points.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Nr.copy(n.boundingSphere), Nr.applyMatrix4(s), Nr.radius += r, e.ray.intersectsSphere(Nr) === !1) return;
    hc.copy(s).invert(), go.copy(e.ray).applyMatrix4(hc);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = n.index, u = n.attributes.position;
    if (c !== null) {
      const d = Math.max(0, a.start), A = Math.min(c.count, a.start + a.count);
      for (let m = d, g = A; m < g; m++) {
        const f = c.getX(m);
        Ur.fromBufferAttribute(u, f), uc(Ur, f, l, s, e, t, this);
      }
    } else {
      const d = Math.max(0, a.start), A = Math.min(u.count, a.start + a.count);
      for (let m = d, g = A; m < g; m++)
        Ur.fromBufferAttribute(u, m), uc(Ur, m, l, s, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const s = t[n[0]];
      if (s !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = s.length; r < a; r++) {
          const o = s[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
}
function uc(i, e, t, n, s, r, a) {
  const o = go.distanceSqToPoint(i);
  if (o < t) {
    const l = new T();
    go.closestPointToPoint(i, l), l.applyMatrix4(n);
    const c = s.ray.origin.distanceTo(l);
    if (c < s.near || c > s.far) return;
    r.push({
      distance: c,
      distanceToRay: Math.sqrt(o),
      point: l,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: a
    });
  }
}
class sa extends It {
  constructor(e, t, n, s, r, a, o, l, c, h, u, d) {
    super(null, a, o, l, c, h, s, r, u, d), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class Rp extends sa {
  constructor(e, t, n, s, r, a) {
    super(e, t, n, r, a), this.isCompressedArrayTexture = !0, this.image.depth = s, this.wrapR = 1001, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Dp extends sa {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, 301), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class Qo extends It {
  constructor(e, t, n, s, r, a, o, l, c, h = 1026) {
    if (h !== 1026 && h !== 1027)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && h === 1026 && (n = 1014), n === void 0 && h === 1027 && (n = 1020), super(null, s, r, a, o, l, h, n, c), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = o !== void 0 ? o : 1003, this.minFilter = l !== void 0 ? l : 1003, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
class ko extends Bt {
  constructor(e = [new Ie(0, -0.5), new Ie(0.5, 0), new Ie(0, 0.5)], t = 12, n = 0, s = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: n,
      phiLength: s
    }, t = Math.floor(t), s = Qe(s, 0, Math.PI * 2);
    const r = [], a = [], o = [], l = [], c = [], h = 1 / t, u = new T(), d = new Ie(), A = new T(), m = new T(), g = new T();
    let f = 0, p = 0;
    for (let v = 0; v <= e.length - 1; v++)
      switch (v) {
        case 0:
          f = e[v + 1].x - e[v].x, p = e[v + 1].y - e[v].y, A.x = p * 1, A.y = -f, A.z = p * 0, g.copy(A), A.normalize(), l.push(A.x, A.y, A.z);
          break;
        case e.length - 1:
          l.push(g.x, g.y, g.z);
          break;
        default:
          f = e[v + 1].x - e[v].x, p = e[v + 1].y - e[v].y, A.x = p * 1, A.y = -f, A.z = p * 0, m.copy(A), A.x += g.x, A.y += g.y, A.z += g.z, A.normalize(), l.push(A.x, A.y, A.z), g.copy(m);
      }
    for (let v = 0; v <= t; v++) {
      const E = n + v * h * s, b = Math.sin(E), S = Math.cos(E);
      for (let I = 0; I <= e.length - 1; I++) {
        u.x = e[I].x * b, u.y = e[I].y, u.z = e[I].x * S, a.push(u.x, u.y, u.z), d.x = v / t, d.y = I / (e.length - 1), o.push(d.x, d.y);
        const B = l[3 * I + 0] * b, R = l[3 * I + 1], w = l[3 * I + 0] * S;
        c.push(B, R, w);
      }
    }
    for (let v = 0; v < t; v++)
      for (let E = 0; E < e.length - 1; E++) {
        const b = E + v * e.length, S = b, I = b + e.length, B = b + e.length + 1, R = b + 1;
        r.push(S, I, R), r.push(B, R, I);
      }
    this.setIndex(r), this.setAttribute("position", new Oe(a, 3)), this.setAttribute("uv", new Oe(o, 2)), this.setAttribute("normal", new Oe(c, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ko(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class _o extends Bt {
  constructor(e = 1, t = 32, n = 0, s = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: n,
      thetaLength: s
    }, t = Math.max(3, t);
    const r = [], a = [], o = [], l = [], c = new T(), h = new Ie();
    a.push(0, 0, 0), o.push(0, 0, 1), l.push(0.5, 0.5);
    for (let u = 0, d = 3; u <= t; u++, d += 3) {
      const A = n + u / t * s;
      c.x = e * Math.cos(A), c.y = e * Math.sin(A), a.push(c.x, c.y, c.z), o.push(0, 0, 1), h.x = (a[d] / e + 1) / 2, h.y = (a[d + 1] / e + 1) / 2, l.push(h.x, h.y);
    }
    for (let u = 1; u <= t; u++)
      r.push(u, u + 1, 0);
    this.setIndex(r), this.setAttribute("position", new Oe(a, 3)), this.setAttribute("normal", new Oe(o, 3)), this.setAttribute("uv", new Oe(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new _o(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Oo extends Bt {
  constructor(e = 1, t = 1, n = 1, s = 32, r = 1, a = !1, o = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: s,
      heightSegments: r,
      openEnded: a,
      thetaStart: o,
      thetaLength: l
    };
    const c = this;
    s = Math.floor(s), r = Math.floor(r);
    const h = [], u = [], d = [], A = [];
    let m = 0;
    const g = [], f = n / 2;
    let p = 0;
    v(), a === !1 && (e > 0 && E(!0), t > 0 && E(!1)), this.setIndex(h), this.setAttribute("position", new Oe(u, 3)), this.setAttribute("normal", new Oe(d, 3)), this.setAttribute("uv", new Oe(A, 2));
    function v() {
      const b = new T(), S = new T();
      let I = 0;
      const B = (t - e) / n;
      for (let R = 0; R <= r; R++) {
        const w = [], C = R / r, D = C * (t - e) + e;
        for (let _ = 0; _ <= s; _++) {
          const Q = _ / s, H = Q * l + o, j = Math.sin(H), V = Math.cos(H);
          S.x = D * j, S.y = -C * n + f, S.z = D * V, u.push(S.x, S.y, S.z), b.set(j, B, V).normalize(), d.push(b.x, b.y, b.z), A.push(Q, 1 - C), w.push(m++);
        }
        g.push(w);
      }
      for (let R = 0; R < s; R++)
        for (let w = 0; w < r; w++) {
          const C = g[w][R], D = g[w + 1][R], _ = g[w + 1][R + 1], Q = g[w][R + 1];
          (e > 0 || w !== 0) && (h.push(C, D, Q), I += 3), (t > 0 || w !== r - 1) && (h.push(D, _, Q), I += 3);
        }
      c.addGroup(p, I, 0), p += I;
    }
    function E(b) {
      const S = m, I = new Ie(), B = new T();
      let R = 0;
      const w = b === !0 ? e : t, C = b === !0 ? 1 : -1;
      for (let _ = 1; _ <= s; _++)
        u.push(0, f * C, 0), d.push(0, C, 0), A.push(0.5, 0.5), m++;
      const D = m;
      for (let _ = 0; _ <= s; _++) {
        const H = _ / s * l + o, j = Math.cos(H), V = Math.sin(H);
        B.x = w * V, B.y = f * C, B.z = w * j, u.push(B.x, B.y, B.z), d.push(0, C, 0), I.x = j * 0.5 + 0.5, I.y = V * 0.5 * C + 0.5, A.push(I.x, I.y), m++;
      }
      for (let _ = 0; _ < s; _++) {
        const Q = S + _, H = D + _;
        b === !0 ? h.push(H, H + 1, Q) : h.push(H + 1, H, Q), R += 3;
      }
      c.addGroup(p, R, b === !0 ? 1 : 2), p += R;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Oo(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class er extends Bt {
  constructor(e = [], t = [], n = 1, s = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: n,
      detail: s
    };
    const r = [], a = [];
    o(s), c(n), h(), this.setAttribute("position", new Oe(r, 3)), this.setAttribute("normal", new Oe(r.slice(), 3)), this.setAttribute("uv", new Oe(a, 2)), s === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function o(v) {
      const E = new T(), b = new T(), S = new T();
      for (let I = 0; I < t.length; I += 3)
        A(t[I + 0], E), A(t[I + 1], b), A(t[I + 2], S), l(E, b, S, v);
    }
    function l(v, E, b, S) {
      const I = S + 1, B = [];
      for (let R = 0; R <= I; R++) {
        B[R] = [];
        const w = v.clone().lerp(b, R / I), C = E.clone().lerp(b, R / I), D = I - R;
        for (let _ = 0; _ <= D; _++)
          _ === 0 && R === I ? B[R][_] = w : B[R][_] = w.clone().lerp(C, _ / D);
      }
      for (let R = 0; R < I; R++)
        for (let w = 0; w < 2 * (I - R) - 1; w++) {
          const C = Math.floor(w / 2);
          w % 2 === 0 ? (d(B[R][C + 1]), d(B[R + 1][C]), d(B[R][C])) : (d(B[R][C + 1]), d(B[R + 1][C + 1]), d(B[R + 1][C]));
        }
    }
    function c(v) {
      const E = new T();
      for (let b = 0; b < r.length; b += 3)
        E.x = r[b + 0], E.y = r[b + 1], E.z = r[b + 2], E.normalize().multiplyScalar(v), r[b + 0] = E.x, r[b + 1] = E.y, r[b + 2] = E.z;
    }
    function h() {
      const v = new T();
      for (let E = 0; E < r.length; E += 3) {
        v.x = r[E + 0], v.y = r[E + 1], v.z = r[E + 2];
        const b = f(v) / 2 / Math.PI + 0.5, S = p(v) / Math.PI + 0.5;
        a.push(b, 1 - S);
      }
      m(), u();
    }
    function u() {
      for (let v = 0; v < a.length; v += 6) {
        const E = a[v + 0], b = a[v + 2], S = a[v + 4], I = Math.max(E, b, S), B = Math.min(E, b, S);
        I > 0.9 && B < 0.1 && (E < 0.2 && (a[v + 0] += 1), b < 0.2 && (a[v + 2] += 1), S < 0.2 && (a[v + 4] += 1));
      }
    }
    function d(v) {
      r.push(v.x, v.y, v.z);
    }
    function A(v, E) {
      const b = v * 3;
      E.x = e[b + 0], E.y = e[b + 1], E.z = e[b + 2];
    }
    function m() {
      const v = new T(), E = new T(), b = new T(), S = new T(), I = new Ie(), B = new Ie(), R = new Ie();
      for (let w = 0, C = 0; w < r.length; w += 9, C += 6) {
        v.set(r[w + 0], r[w + 1], r[w + 2]), E.set(r[w + 3], r[w + 4], r[w + 5]), b.set(r[w + 6], r[w + 7], r[w + 8]), I.set(a[C + 0], a[C + 1]), B.set(a[C + 2], a[C + 3]), R.set(a[C + 4], a[C + 5]), S.copy(v).add(E).add(b).divideScalar(3);
        const D = f(S);
        g(I, C + 0, v, D), g(B, C + 2, E, D), g(R, C + 4, b, D);
      }
    }
    function g(v, E, b, S) {
      S < 0 && v.x === 1 && (a[E] = v.x - 1), b.x === 0 && b.z === 0 && (a[E] = S / 2 / Math.PI + 0.5);
    }
    function f(v) {
      return Math.atan2(v.z, -v.x);
    }
    function p(v) {
      return Math.atan2(-v.y, Math.sqrt(v.x * v.x + v.z * v.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new er(e.vertices, e.indices, e.radius, e.details);
  }
}
class Go extends er {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, s = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1
    ], r = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(s, r, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Go(e.radius, e.detail);
  }
}
class Ho extends er {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], s = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(n, s, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Ho(e.radius, e.detail);
  }
}
class Li extends Bt {
  constructor(e = 1, t = 1, n = 1, s = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: s
    };
    const r = e / 2, a = t / 2, o = Math.floor(n), l = Math.floor(s), c = o + 1, h = l + 1, u = e / o, d = t / l, A = [], m = [], g = [], f = [];
    for (let p = 0; p < h; p++) {
      const v = p * d - a;
      for (let E = 0; E < c; E++) {
        const b = E * u - r;
        m.push(b, -v, 0), g.push(0, 0, 1), f.push(E / o), f.push(1 - p / l);
      }
    }
    for (let p = 0; p < l; p++)
      for (let v = 0; v < o; v++) {
        const E = v + c * p, b = v + c * (p + 1), S = v + 1 + c * (p + 1), I = v + 1 + c * p;
        A.push(E, b, I), A.push(b, S, I);
      }
    this.setIndex(A), this.setAttribute("position", new Oe(m, 3)), this.setAttribute("normal", new Oe(g, 3)), this.setAttribute("uv", new Oe(f, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Li(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class Vo extends Bt {
  constructor(e = 0.5, t = 1, n = 32, s = 1, r = 0, a = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: n,
      phiSegments: s,
      thetaStart: r,
      thetaLength: a
    }, n = Math.max(3, n), s = Math.max(1, s);
    const o = [], l = [], c = [], h = [];
    let u = e;
    const d = (t - e) / s, A = new T(), m = new Ie();
    for (let g = 0; g <= s; g++) {
      for (let f = 0; f <= n; f++) {
        const p = r + f / n * a;
        A.x = u * Math.cos(p), A.y = u * Math.sin(p), l.push(A.x, A.y, A.z), c.push(0, 0, 1), m.x = (A.x / t + 1) / 2, m.y = (A.y / t + 1) / 2, h.push(m.x, m.y);
      }
      u += d;
    }
    for (let g = 0; g < s; g++) {
      const f = g * (n + 1);
      for (let p = 0; p < n; p++) {
        const v = p + f, E = v, b = v + n + 1, S = v + n + 2, I = v + 1;
        o.push(E, b, I), o.push(b, S, I);
      }
    }
    this.setIndex(o), this.setAttribute("position", new Oe(l, 3)), this.setAttribute("normal", new Oe(c, 3)), this.setAttribute("uv", new Oe(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Vo(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class zo extends Bt {
  constructor(e = 1, t = 32, n = 16, s = 0, r = Math.PI * 2, a = 0, o = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: s,
      phiLength: r,
      thetaStart: a,
      thetaLength: o
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const l = Math.min(a + o, Math.PI);
    let c = 0;
    const h = [], u = new T(), d = new T(), A = [], m = [], g = [], f = [];
    for (let p = 0; p <= n; p++) {
      const v = [], E = p / n;
      let b = 0;
      p === 0 && a === 0 ? b = 0.5 / t : p === n && l === Math.PI && (b = -0.5 / t);
      for (let S = 0; S <= t; S++) {
        const I = S / t;
        u.x = -e * Math.cos(s + I * r) * Math.sin(a + E * o), u.y = e * Math.cos(a + E * o), u.z = e * Math.sin(s + I * r) * Math.sin(a + E * o), m.push(u.x, u.y, u.z), d.copy(u).normalize(), g.push(d.x, d.y, d.z), f.push(I + b, 1 - E), v.push(c++);
      }
      h.push(v);
    }
    for (let p = 0; p < n; p++)
      for (let v = 0; v < t; v++) {
        const E = h[p][v + 1], b = h[p][v], S = h[p + 1][v], I = h[p + 1][v + 1];
        (p !== 0 || a > 0) && A.push(E, b, I), (p !== n - 1 || l < Math.PI) && A.push(b, S, I);
      }
    this.setIndex(A), this.setAttribute("position", new Oe(m, 3)), this.setAttribute("normal", new Oe(g, 3)), this.setAttribute("uv", new Oe(f, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new zo(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class qo extends er {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], s = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(n, s, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new qo(e.radius, e.detail);
  }
}
class Wo extends Bt {
  constructor(e = 1, t = 0.4, n = 12, s = 48, r = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: n,
      tubularSegments: s,
      arc: r
    }, n = Math.floor(n), s = Math.floor(s);
    const a = [], o = [], l = [], c = [], h = new T(), u = new T(), d = new T();
    for (let A = 0; A <= n; A++)
      for (let m = 0; m <= s; m++) {
        const g = m / s * r, f = A / n * Math.PI * 2;
        u.x = (e + t * Math.cos(f)) * Math.cos(g), u.y = (e + t * Math.cos(f)) * Math.sin(g), u.z = t * Math.sin(f), o.push(u.x, u.y, u.z), h.x = e * Math.cos(g), h.y = e * Math.sin(g), d.subVectors(u, h).normalize(), l.push(d.x, d.y, d.z), c.push(m / s), c.push(A / n);
      }
    for (let A = 1; A <= n; A++)
      for (let m = 1; m <= s; m++) {
        const g = (s + 1) * A + m - 1, f = (s + 1) * (A - 1) + m - 1, p = (s + 1) * (A - 1) + m, v = (s + 1) * A + m;
        a.push(g, f, v), a.push(f, p, v);
      }
    this.setIndex(a), this.setAttribute("position", new Oe(o, 3)), this.setAttribute("normal", new Oe(l, 3)), this.setAttribute("uv", new Oe(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Wo(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Jr extends Bt {
  constructor(e = 1, t = 0.4, n = 64, s = 8, r = 2, a = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: n,
      radialSegments: s,
      p: r,
      q: a
    }, n = Math.floor(n), s = Math.floor(s);
    const o = [], l = [], c = [], h = [], u = new T(), d = new T(), A = new T(), m = new T(), g = new T(), f = new T(), p = new T();
    for (let E = 0; E <= n; ++E) {
      const b = E / n * r * Math.PI * 2;
      v(b, r, a, e, A), v(b + 0.01, r, a, e, m), f.subVectors(m, A), p.addVectors(m, A), g.crossVectors(f, p), p.crossVectors(g, f), g.normalize(), p.normalize();
      for (let S = 0; S <= s; ++S) {
        const I = S / s * Math.PI * 2, B = -t * Math.cos(I), R = t * Math.sin(I);
        u.x = A.x + (B * p.x + R * g.x), u.y = A.y + (B * p.y + R * g.y), u.z = A.z + (B * p.z + R * g.z), l.push(u.x, u.y, u.z), d.subVectors(u, A).normalize(), c.push(d.x, d.y, d.z), h.push(E / n), h.push(S / s);
      }
    }
    for (let E = 1; E <= n; E++)
      for (let b = 1; b <= s; b++) {
        const S = (s + 1) * (E - 1) + (b - 1), I = (s + 1) * E + (b - 1), B = (s + 1) * E + b, R = (s + 1) * (E - 1) + b;
        o.push(S, I, R), o.push(I, B, R);
      }
    this.setIndex(o), this.setAttribute("position", new Oe(l, 3)), this.setAttribute("normal", new Oe(c, 3)), this.setAttribute("uv", new Oe(h, 2));
    function v(E, b, S, I, B) {
      const R = Math.cos(E), w = Math.sin(E), C = S / b * E, D = Math.cos(C);
      B.x = I * (2 + D) * 0.5 * R, B.y = I * (2 + D) * w * 0.5, B.z = I * Math.sin(C) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Jr(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class ra extends yn {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new we(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new we(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new In(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Rn extends ra {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ie(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Qe(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new we(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new we(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new we(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class Pp extends yn {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class Lp extends yn {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
function Qr(i, e, t) {
  return !i || // let 'undefined' and 'null' pass
  !t && i.constructor === e ? i : typeof e.BYTES_PER_ELEMENT == "number" ? new e(i) : Array.prototype.slice.call(i);
}
function Fp(i) {
  return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function Np(i) {
  function e(s, r) {
    return i[s] - i[r];
  }
  const t = i.length, n = new Array(t);
  for (let s = 0; s !== t; ++s) n[s] = s;
  return n.sort(e), n;
}
function dc(i, e, t) {
  const n = i.length, s = new i.constructor(n);
  for (let r = 0, a = 0; a !== n; ++r) {
    const o = t[r] * e;
    for (let l = 0; l !== e; ++l)
      s[a++] = i[o + l];
  }
  return s;
}
function zh(i, e, t, n) {
  let s = 1, r = i[0];
  for (; r !== void 0 && r[n] === void 0; )
    r = i[s++];
  if (r === void 0) return;
  let a = r[n];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        a = r[n], a !== void 0 && (e.push(r.time), t.push.apply(t, a)), r = i[s++];
      while (r !== void 0);
    else if (a.toArray !== void 0)
      do
        a = r[n], a !== void 0 && (e.push(r.time), a.toArray(t, t.length)), r = i[s++];
      while (r !== void 0);
    else
      do
        a = r[n], a !== void 0 && (e.push(r.time), t.push(a)), r = i[s++];
      while (r !== void 0);
}
class tr {
  constructor(e, t, n, s) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = s !== void 0 ? s : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, s = t[n], r = t[n - 1];
    n: {
      e: {
        let a;
        t: {
          i: if (!(e < s)) {
            for (let o = n + 2; ; ) {
              if (s === void 0) {
                if (e < r) break i;
                return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
              }
              if (n === o) break;
              if (r = s, s = t[++n], e < s)
                break e;
            }
            a = t.length;
            break t;
          }
          if (!(e >= r)) {
            const o = t[1];
            e < o && (n = 2, r = o);
            for (let l = n - 2; ; ) {
              if (r === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === l) break;
              if (s = r, r = t[--n - 1], e >= r)
                break e;
            }
            a = n, n = 0;
            break t;
          }
          break n;
        }
        for (; n < a; ) {
          const o = n + a >>> 1;
          e < t[o] ? a = o : n = o + 1;
        }
        if (s = t[n], r = t[n - 1], r === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (s === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, r, s);
    }
    return this.interpolate_(n, r, e, s);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = e * s;
    for (let a = 0; a !== s; ++a)
      t[a] = n[r + a];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class Up extends tr {
  constructor(e, t, n, s) {
    super(e, t, n, s), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: 2400,
      endingEnd: 2400
    };
  }
  intervalChanged_(e, t, n) {
    const s = this.parameterPositions;
    let r = e - 2, a = e + 1, o = s[r], l = s[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case 2401:
          r = e, o = 2 * t - n;
          break;
        case 2402:
          r = s.length - 2, o = t + s[r] - s[r + 1];
          break;
        default:
          r = e, o = n;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case 2401:
          a = e, l = 2 * n - t;
          break;
        case 2402:
          a = 1, l = n + s[1] - s[0];
          break;
        default:
          a = e - 1, l = t;
      }
    const c = (n - t) * 0.5, h = this.valueSize;
    this._weightPrev = c / (t - o), this._weightNext = c / (l - n), this._offsetPrev = r * h, this._offsetNext = a * h;
  }
  interpolate_(e, t, n, s) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, h = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, A = this._weightNext, m = (n - t) / (s - t), g = m * m, f = g * m, p = -d * f + 2 * d * g - d * m, v = (1 + d) * f + (-1.5 - 2 * d) * g + (-0.5 + d) * m + 1, E = (-1 - A) * f + (1.5 + A) * g + 0.5 * m, b = A * f - A * g;
    for (let S = 0; S !== o; ++S)
      r[S] = p * a[h + S] + v * a[c + S] + E * a[l + S] + b * a[u + S];
    return r;
  }
}
class Qp extends tr {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  interpolate_(e, t, n, s) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, h = (n - t) / (s - t), u = 1 - h;
    for (let d = 0; d !== o; ++d)
      r[d] = a[c + d] * u + a[l + d] * h;
    return r;
  }
}
class kp extends tr {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Dn {
  constructor(e, t, n, s) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = Qr(t, this.TimeBufferType), this.values = Qr(n, this.ValueBufferType), this.setInterpolation(s || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: Qr(e.times, Array),
        values: Qr(e.values, Array)
      };
      const s = e.getInterpolation();
      s !== e.DefaultInterpolation && (n.interpolation = s);
    }
    return n.type = e.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new kp(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new Qp(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new Up(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case 2300:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case 2301:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case 2302:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;
      case this.InterpolantFactoryMethodLinear:
        return 2301;
      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, s = t.length; n !== s; ++n)
        t[n] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, s = t.length; n !== s; ++n)
        t[n] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const n = this.times, s = n.length;
    let r = 0, a = s - 1;
    for (; r !== s && n[r] < e; )
      ++r;
    for (; a !== -1 && n[a] > t; )
      --a;
    if (++a, r !== 0 || a !== s) {
      r >= a && (a = Math.max(a, 1), r = a - 1);
      const o = this.getValueSize();
      this.times = n.slice(r, a), this.values = this.values.slice(r * o, a * o);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, s = this.values, r = n.length;
    r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let a = null;
    for (let o = 0; o !== r; o++) {
      const l = n[o];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), e = !1;
        break;
      }
      if (a !== null && a > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a), e = !1;
        break;
      }
      a = l;
    }
    if (s !== void 0 && Fp(s))
      for (let o = 0, l = s.length; o !== l; ++o) {
        const c = s[o];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), s = this.getInterpolation() === 2302, r = e.length - 1;
    let a = 1;
    for (let o = 1; o < r; ++o) {
      let l = !1;
      const c = e[o], h = e[o + 1];
      if (c !== h && (o !== 1 || c !== e[0]))
        if (s)
          l = !0;
        else {
          const u = o * n, d = u - n, A = u + n;
          for (let m = 0; m !== n; ++m) {
            const g = t[u + m];
            if (g !== t[d + m] || g !== t[A + m]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (o !== a) {
          e[a] = e[o];
          const u = o * n, d = a * n;
          for (let A = 0; A !== n; ++A)
            t[d + A] = t[u + A];
        }
        ++a;
      }
    }
    if (r > 0) {
      e[a] = e[r];
      for (let o = r * n, l = a * n, c = 0; c !== n; ++c)
        t[l + c] = t[o + c];
      ++a;
    }
    return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), n = this.constructor, s = new n(this.name, e, t);
    return s.createInterpolant = this.createInterpolant, s;
  }
}
Dn.prototype.TimeBufferType = Float32Array;
Dn.prototype.ValueBufferType = Float32Array;
Dn.prototype.DefaultInterpolation = 2301;
class vs extends Dn {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(e, t, n) {
    super(e, t, n);
  }
}
vs.prototype.ValueTypeName = "bool";
vs.prototype.ValueBufferType = Array;
vs.prototype.DefaultInterpolation = 2300;
vs.prototype.InterpolantFactoryMethodLinear = void 0;
vs.prototype.InterpolantFactoryMethodSmooth = void 0;
class qh extends Dn {
}
qh.prototype.ValueTypeName = "color";
class As extends Dn {
}
As.prototype.ValueTypeName = "number";
class _p extends tr {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  interpolate_(e, t, n, s) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = (n - t) / (s - t);
    let c = e * o;
    for (let h = c + o; c !== h; c += 4)
      dn.slerpFlat(r, 0, a, c - o, a, c, l);
    return r;
  }
}
class fs extends Dn {
  InterpolantFactoryMethodLinear(e) {
    return new _p(this.times, this.values, this.getValueSize(), e);
  }
}
fs.prototype.ValueTypeName = "quaternion";
fs.prototype.InterpolantFactoryMethodSmooth = void 0;
class Es extends Dn {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(e, t, n) {
    super(e, t, n);
  }
}
Es.prototype.ValueTypeName = "string";
Es.prototype.ValueBufferType = Array;
Es.prototype.DefaultInterpolation = 2300;
Es.prototype.InterpolantFactoryMethodLinear = void 0;
Es.prototype.InterpolantFactoryMethodSmooth = void 0;
class ms extends Dn {
}
ms.prototype.ValueTypeName = "vector";
class Op {
  constructor(e = "", t = -1, n = [], s = 2500) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = s, this.uuid = En(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, s = 1 / (e.fps || 1);
    for (let a = 0, o = n.length; a !== o; ++a)
      t.push(Hp(n[a]).scale(s));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return r.uuid = e.uuid, r;
  }
  static toJSON(e) {
    const t = [], n = e.tracks, s = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let r = 0, a = n.length; r !== a; ++r)
      t.push(Dn.toJSON(n[r]));
    return s;
  }
  static CreateFromMorphTargetSequence(e, t, n, s) {
    const r = t.length, a = [];
    for (let o = 0; o < r; o++) {
      let l = [], c = [];
      l.push(
        (o + r - 1) % r,
        o,
        (o + 1) % r
      ), c.push(0, 1, 0);
      const h = Np(l);
      l = dc(l, 1, h), c = dc(c, 1, h), !s && l[0] === 0 && (l.push(r), c.push(c[0])), a.push(
        new As(
          ".morphTargetInfluences[" + t[o].name + "]",
          l,
          c
        ).scale(1 / n)
      );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const s = e;
      n = s.geometry && s.geometry.animations || s.animations;
    }
    for (let s = 0; s < n.length; s++)
      if (n[s].name === t)
        return n[s];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const s = {}, r = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o], h = c.name.match(r);
      if (h && h.length > 1) {
        const u = h[1];
        let d = s[u];
        d || (s[u] = d = []), d.push(c);
      }
    }
    const a = [];
    for (const o in s)
      a.push(this.CreateFromMorphTargetSequence(o, s[o], t, n));
    return a;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(u, d, A, m, g) {
      if (A.length !== 0) {
        const f = [], p = [];
        zh(A, f, p, m), f.length !== 0 && g.push(new u(d, f, p));
      }
    }, s = [], r = e.name || "default", a = e.fps || 30, o = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let u = 0; u < c.length; u++) {
      const d = c[u].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const A = {};
          let m;
          for (m = 0; m < d.length; m++)
            if (d[m].morphTargets)
              for (let g = 0; g < d[m].morphTargets.length; g++)
                A[d[m].morphTargets[g]] = -1;
          for (const g in A) {
            const f = [], p = [];
            for (let v = 0; v !== d[m].morphTargets.length; ++v) {
              const E = d[m];
              f.push(E.time), p.push(E.morphTarget === g ? 1 : 0);
            }
            s.push(new As(".morphTargetInfluence[" + g + "]", f, p));
          }
          l = A.length * a;
        } else {
          const A = ".bones[" + t[u].name + "]";
          n(
            ms,
            A + ".position",
            d,
            "pos",
            s
          ), n(
            fs,
            A + ".quaternion",
            d,
            "rot",
            s
          ), n(
            ms,
            A + ".scale",
            d,
            "scl",
            s
          );
        }
    }
    return s.length === 0 ? null : new this(r, l, s, o);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, s = e.length; n !== s; ++n) {
      const r = this.tracks[n];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function Gp(i) {
  switch (i.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return As;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return ms;
    case "color":
      return qh;
    case "quaternion":
      return fs;
    case "bool":
    case "boolean":
      return vs;
    case "string":
      return Es;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i);
}
function Hp(i) {
  if (i.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = Gp(i.type);
  if (i.times === void 0) {
    const t = [], n = [];
    zh(i.keys, t, n, "value"), i.times = t, i.values = n;
  }
  return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation);
}
const hi = {
  enabled: !1,
  files: {},
  add: function(i, e) {
    this.enabled !== !1 && (this.files[i] = e);
  },
  get: function(i) {
    if (this.enabled !== !1)
      return this.files[i];
  },
  remove: function(i) {
    delete this.files[i];
  },
  clear: function() {
    this.files = {};
  }
};
class Vp {
  constructor(e, t, n) {
    const s = this;
    let r = !1, a = 0, o = 0, l;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(h) {
      o++, r === !1 && s.onStart !== void 0 && s.onStart(h, a, o), r = !0;
    }, this.itemEnd = function(h) {
      a++, s.onProgress !== void 0 && s.onProgress(h, a, o), a === o && (r = !1, s.onLoad !== void 0 && s.onLoad());
    }, this.itemError = function(h) {
      s.onError !== void 0 && s.onError(h);
    }, this.resolveURL = function(h) {
      return l ? l(h) : h;
    }, this.setURLModifier = function(h) {
      return l = h, this;
    }, this.addHandler = function(h, u) {
      return c.push(h, u), this;
    }, this.removeHandler = function(h) {
      const u = c.indexOf(h);
      return u !== -1 && c.splice(u, 2), this;
    }, this.getHandler = function(h) {
      for (let u = 0, d = c.length; u < d; u += 2) {
        const A = c[u], m = c[u + 1];
        if (A.global && (A.lastIndex = 0), A.test(h))
          return m;
      }
      return null;
    };
  }
}
const zp = /* @__PURE__ */ new Vp();
class ki {
  constructor(e) {
    this.manager = e !== void 0 ? e : zp, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(s, r) {
      n.load(e, s, t, r);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
ki.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const kn = {};
class qp extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class zs extends ki {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = hi.get(e);
    if (r !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(r), this.manager.itemEnd(e);
      }, 0), r;
    if (kn[e] !== void 0) {
      kn[e].push({
        onLoad: t,
        onProgress: n,
        onError: s
      });
      return;
    }
    kn[e] = [], kn[e].push({
      onLoad: t,
      onProgress: n,
      onError: s
    });
    const a = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), o = this.mimeType, l = this.responseType;
    fetch(a).then((c) => {
      if (c.status === 200 || c.status === 0) {
        if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
          return c;
        const h = kn[e], u = c.body.getReader(), d = c.headers.get("X-File-Size") || c.headers.get("Content-Length"), A = d ? parseInt(d) : 0, m = A !== 0;
        let g = 0;
        const f = new ReadableStream({
          start(p) {
            v();
            function v() {
              u.read().then(({ done: E, value: b }) => {
                if (E)
                  p.close();
                else {
                  g += b.byteLength;
                  const S = new ProgressEvent("progress", { lengthComputable: m, loaded: g, total: A });
                  for (let I = 0, B = h.length; I < B; I++) {
                    const R = h[I];
                    R.onProgress && R.onProgress(S);
                  }
                  p.enqueue(b), v();
                }
              }, (E) => {
                p.error(E);
              });
            }
          }
        });
        return new Response(f);
      } else
        throw new qp(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
    }).then((c) => {
      switch (l) {
        case "arraybuffer":
          return c.arrayBuffer();
        case "blob":
          return c.blob();
        case "document":
          return c.text().then((h) => new DOMParser().parseFromString(h, o));
        case "json":
          return c.json();
        default:
          if (o === void 0)
            return c.text();
          {
            const u = /charset="?([^;"\s]*)"?/i.exec(o), d = u && u[1] ? u[1].toLowerCase() : void 0, A = new TextDecoder(d);
            return c.arrayBuffer().then((m) => A.decode(m));
          }
      }
    }).then((c) => {
      hi.add(e, c);
      const h = kn[e];
      delete kn[e];
      for (let u = 0, d = h.length; u < d; u++) {
        const A = h[u];
        A.onLoad && A.onLoad(c);
      }
    }).catch((c) => {
      const h = kn[e];
      if (h === void 0)
        throw this.manager.itemError(e), c;
      delete kn[e];
      for (let u = 0, d = h.length; u < d; u++) {
        const A = h[u];
        A.onError && A.onError(c);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class Wp extends ki {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, a = hi.get(e);
    if (a !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(a), r.manager.itemEnd(e);
      }, 0), a;
    const o = Ys("img");
    function l() {
      h(), hi.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function c(u) {
      h(), s && s(u), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function h() {
      o.removeEventListener("load", l, !1), o.removeEventListener("error", c, !1);
    }
    return o.addEventListener("load", l, !1), o.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o;
  }
}
class Wh extends ki {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const r = new It(), a = new Wp(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
      r.image = o, r.needsUpdate = !0, t !== void 0 && t(r);
    }, n, s), r;
  }
}
class aa extends At {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new we(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
  }
}
const Oa = /* @__PURE__ */ new Pe(), pc = /* @__PURE__ */ new T(), Ac = /* @__PURE__ */ new T();
class Yo {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ie(512, 512), this.map = null, this.mapPass = null, this.matrix = new Pe(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Fo(), this._frameExtents = new Ie(1, 1), this._viewportCount = 1, this._viewports = [
      new $e(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    pc.setFromMatrixPosition(e.matrixWorld), t.position.copy(pc), Ac.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Ac), t.updateMatrixWorld(), Oa.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Oa), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(Oa);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class Yp extends Yo {
  constructor() {
    super(new Gt(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = ds * 2 * e.angle * this.focus, s = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
    (n !== t.fov || s !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = s, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class Kp extends aa {
  constructor(e, t, n = 0, s = Math.PI / 3, r = 0, a = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(At.DEFAULT_UP), this.updateMatrix(), this.target = new At(), this.distance = n, this.angle = s, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new Yp();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const fc = /* @__PURE__ */ new Pe(), Fs = /* @__PURE__ */ new T(), Ga = /* @__PURE__ */ new T();
class Xp extends Yo {
  constructor() {
    super(new Gt(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Ie(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new $e(2, 1, 1, 1),
      // negative X
      new $e(0, 1, 1, 1),
      // positive Z
      new $e(3, 1, 1, 1),
      // negative Z
      new $e(1, 1, 1, 1),
      // positive Y
      new $e(3, 0, 1, 1),
      // negative Y
      new $e(1, 0, 1, 1)
    ], this._cubeDirections = [
      new T(1, 0, 0),
      new T(-1, 0, 0),
      new T(0, 0, 1),
      new T(0, 0, -1),
      new T(0, 1, 0),
      new T(0, -1, 0)
    ], this._cubeUps = [
      new T(0, 1, 0),
      new T(0, 1, 0),
      new T(0, 1, 0),
      new T(0, 1, 0),
      new T(0, 0, 1),
      new T(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, s = this.matrix, r = e.distance || n.far;
    r !== n.far && (n.far = r, n.updateProjectionMatrix()), Fs.setFromMatrixPosition(e.matrixWorld), n.position.copy(Fs), Ga.copy(n.position), Ga.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Ga), n.updateMatrixWorld(), s.makeTranslation(-Fs.x, -Fs.y, -Fs.z), fc.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(fc);
  }
}
class jp extends aa {
  constructor(e, t, n = 0, s = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = s, this.shadow = new Xp();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class oa extends _h {
  constructor(e = -1, t = 1, n = 1, s = -1, r = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = s, this.near = r, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, s, r, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
    let r = n - e, a = n + e, o = s + t, l = s - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += c * this.view.offsetX, a = r + c * this.view.width, o -= h * this.view.offsetY, l = o - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
class Jp extends Yo {
  constructor() {
    super(new oa(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class Zp extends aa {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(At.DEFAULT_UP), this.updateMatrix(), this.target = new At(), this.shadow = new Jp();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class $p extends aa {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class qs {
  static decodeText(e) {
    if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, s = e.length; n < s; n++)
      t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class eA extends ki {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, s) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, a = hi.get(e);
    if (a !== void 0) {
      if (r.manager.itemStart(e), a.then) {
        a.then((c) => {
          t && t(c), r.manager.itemEnd(e);
        }).catch((c) => {
          s && s(c);
        });
        return;
      }
      return setTimeout(function() {
        t && t(a), r.manager.itemEnd(e);
      }, 0), a;
    }
    const o = {};
    o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
    const l = fetch(e, o).then(function(c) {
      return c.blob();
    }).then(function(c) {
      return createImageBitmap(c, Object.assign(r.options, { colorSpaceConversion: "none" }));
    }).then(function(c) {
      return hi.add(e, c), t && t(c), r.manager.itemEnd(e), c;
    }).catch(function(c) {
      s && s(c), hi.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
    });
    hi.add(e, l), r.manager.itemStart(e);
  }
}
class tA extends Gt {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e, this.index = 0;
  }
}
class mc {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = gc(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = gc();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function gc() {
  return performance.now();
}
const Ko = "\\[\\]\\.:\\/", nA = new RegExp("[" + Ko + "]", "g"), Xo = "[^" + Ko + "]", iA = "[^" + Ko.replace("\\.", "") + "]", sA = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", Xo), rA = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", iA), aA = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Xo), oA = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Xo), lA = new RegExp(
  "^" + sA + rA + aA + oA + "$"
), cA = ["material", "materials", "bones", "map"];
class hA {
  constructor(e, t, n) {
    const s = n || rt.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, s);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, s = this._bindings[n];
    s !== void 0 && s.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let s = this._targetGroup.nCachedObjects_, r = n.length; s !== r; ++s)
      n[s].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class rt {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || rt.parseTrackName(t), this.node = rt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new rt.Composite(e, t, n) : new rt(e, t, n);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(nA, "");
  }
  static parseTrackName(e) {
    const t = lA.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, s = n.nodeName && n.nodeName.lastIndexOf(".");
    if (s !== void 0 && s !== -1) {
      const r = n.nodeName.substring(s + 1);
      cA.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, s), n.objectName = r);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(r) {
        for (let a = 0; a < r.length; a++) {
          const o = r[a];
          if (o.name === t || o.uuid === t)
            return o;
          const l = n(o.children);
          if (l) return l;
        }
        return null;
      }, s = n(e.children);
      if (s)
        return s;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let s = 0, r = n.length; s !== r; ++s)
      e[t++] = n[s];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let s = 0, r = n.length; s !== r; ++s)
      n[s] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let s = 0, r = n.length; s !== r; ++s)
      n[s] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let s = 0, r = n.length; s !== r; ++s)
      n[s] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, s = t.propertyName;
    let r = t.propertyIndex;
    if (e || (e = rt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n) {
      let c = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === c) {
              c = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[n];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[c];
      }
    }
    const a = e[s];
    if (a === void 0) {
      const c = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + s + " but it wasn't found.", e);
      return;
    }
    let o = this.Versioning.None;
    this.targetObject = e, e.isMaterial === !0 ? o = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (r !== void 0) {
      if (s === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r;
    } else a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = s;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
rt.Composite = hA;
rt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
rt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
rt.prototype.GetterByBindingType = [
  rt.prototype._getValue_direct,
  rt.prototype._getValue_array,
  rt.prototype._getValue_arrayElement,
  rt.prototype._getValue_toArray
];
rt.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    rt.prototype._setValue_direct,
    rt.prototype._setValue_direct_setNeedsUpdate,
    rt.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    rt.prototype._setValue_array,
    rt.prototype._setValue_array_setNeedsUpdate,
    rt.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    rt.prototype._setValue_arrayElement,
    rt.prototype._setValue_arrayElement_setNeedsUpdate,
    rt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    rt.prototype._setValue_fromArray,
    rt.prototype._setValue_fromArray_setNeedsUpdate,
    rt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class bc {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Qe(this.phi, 1e-6, Math.PI - 1e-6), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Qe(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class uA extends Hh {
  constructor(e = 10, t = 10, n = 4473924, s = 8947848) {
    n = new we(n), s = new we(s);
    const r = t / 2, a = e / t, o = e / 2, l = [], c = [];
    for (let d = 0, A = 0, m = -o; d <= t; d++, m += a) {
      l.push(-o, 0, m, o, 0, m), l.push(m, 0, -o, m, 0, o);
      const g = d === r ? n : s;
      g.toArray(c, A), A += 3, g.toArray(c, A), A += 3, g.toArray(c, A), A += 3, g.toArray(c, A), A += 3;
    }
    const h = new Bt();
    h.setAttribute("position", new Oe(l, 3)), h.setAttribute("color", new Oe(c, 3));
    const u = new No({ vertexColors: !0, toneMapped: !1 });
    super(h, u), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function vc(i, e, t, n) {
  const s = dA(n);
  switch (t) {
    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    case 1021:
      return i * e;
    case 1024:
      return i * e;
    case 1025:
      return i * e * 2;
    case 1028:
      return i * e / s.components * s.byteLength;
    case 1029:
      return i * e / s.components * s.byteLength;
    case 1030:
      return i * e * 2 / s.components * s.byteLength;
    case 1031:
      return i * e * 2 / s.components * s.byteLength;
    case 1022:
      return i * e * 3 / s.components * s.byteLength;
    case 1023:
      return i * e * 4 / s.components * s.byteLength;
    case 1033:
      return i * e * 4 / s.components * s.byteLength;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    case 33776:
    case 33777:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case 33778:
    case 33779:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    case 35841:
    case 35843:
      return Math.max(i, 16) * Math.max(e, 8) / 4;
    case 35840:
    case 35842:
      return Math.max(i, 8) * Math.max(e, 8) / 2;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
    case 36196:
    case 37492:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case 37496:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
    case 37808:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case 37809:
      return Math.floor((i + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case 37810:
      return Math.floor((i + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case 37811:
      return Math.floor((i + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case 37812:
      return Math.floor((i + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case 37813:
      return Math.floor((i + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case 37814:
      return Math.floor((i + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case 37815:
      return Math.floor((i + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case 37816:
      return Math.floor((i + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case 37817:
      return Math.floor((i + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case 37818:
      return Math.floor((i + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case 37819:
      return Math.floor((i + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case 37820:
      return Math.floor((i + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case 37821:
      return Math.floor((i + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
    case 36492:
    case 36494:
    case 36495:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
    case 36283:
    case 36284:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 8;
    case 36285:
    case 36286:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${t} format.`
  );
}
function dA(i) {
  switch (i) {
    case 1009:
    case 1010:
      return { byteLength: 1, components: 1 };
    case 1012:
    case 1011:
    case 1016:
      return { byteLength: 2, components: 1 };
    case 1017:
    case 1018:
      return { byteLength: 2, components: 4 };
    case 1014:
    case 1013:
    case 1015:
      return { byteLength: 4, components: 1 };
    case 35902:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${i}.`);
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: To
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = To);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function Yh() {
  let i = null, e = !1, t = null, n = null;
  function s(r, a) {
    t(r, a), n = i.requestAnimationFrame(s);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = i.requestAnimationFrame(s), e = !0);
    },
    stop: function() {
      i.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(r) {
      t = r;
    },
    setContext: function(r) {
      i = r;
    }
  };
}
function pA(i) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(o, l) {
    const c = o.array, h = o.usage, u = c.byteLength, d = i.createBuffer();
    i.bindBuffer(l, d), i.bufferData(l, c, h), o.onUploadCallback();
    let A;
    if (c instanceof Float32Array)
      A = i.FLOAT;
    else if (c instanceof Uint16Array)
      o.isFloat16BufferAttribute ? A = i.HALF_FLOAT : A = i.UNSIGNED_SHORT;
    else if (c instanceof Int16Array)
      A = i.SHORT;
    else if (c instanceof Uint32Array)
      A = i.UNSIGNED_INT;
    else if (c instanceof Int32Array)
      A = i.INT;
    else if (c instanceof Int8Array)
      A = i.BYTE;
    else if (c instanceof Uint8Array)
      A = i.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray)
      A = i.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
    return {
      buffer: d,
      type: A,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: o.version,
      size: u
    };
  }
  function n(o, l, c) {
    const h = l.array, u = l.updateRanges;
    if (i.bindBuffer(c, o), u.length === 0)
      i.bufferSubData(c, 0, h);
    else {
      u.sort((A, m) => A.start - m.start);
      let d = 0;
      for (let A = 1; A < u.length; A++) {
        const m = u[d], g = u[A];
        g.start <= m.start + m.count + 1 ? m.count = Math.max(
          m.count,
          g.start + g.count - m.start
        ) : (++d, u[d] = g);
      }
      u.length = d + 1;
      for (let A = 0, m = u.length; A < m; A++) {
        const g = u[A];
        i.bufferSubData(
          c,
          g.start * h.BYTES_PER_ELEMENT,
          h,
          g.start,
          g.count
        );
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  function s(o) {
    return o.isInterleavedBufferAttribute && (o = o.data), e.get(o);
  }
  function r(o) {
    o.isInterleavedBufferAttribute && (o = o.data);
    const l = e.get(o);
    l && (i.deleteBuffer(l.buffer), e.delete(o));
  }
  function a(o, l) {
    if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) {
      const h = e.get(o);
      (!h || h.version < o.version) && e.set(o, {
        buffer: o.buffer,
        type: o.type,
        bytesPerElement: o.elementSize,
        version: o.version
      });
      return;
    }
    const c = e.get(o);
    if (c === void 0)
      e.set(o, t(o, l));
    else if (c.version < o.version) {
      if (c.size !== o.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n(c.buffer, o, l), c.version = o.version;
    }
  }
  return {
    get: s,
    remove: r,
    update: a
  };
}
var AA = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, fA = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, mA = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, gA = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, bA = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, vA = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, EA = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, CA = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, xA = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, wA = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, yA = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, IA = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, MA = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, SA = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, BA = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, TA = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, RA = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, DA = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, PA = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, LA = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, FA = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, NA = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, UA = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, QA = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, kA = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, _A = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, OA = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, GA = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, HA = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, VA = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, zA = "gl_FragColor = linearToOutputTexel( gl_FragColor );", qA = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, WA = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, YA = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, KA = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, XA = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, jA = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, JA = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, ZA = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, $A = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, ef = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, tf = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, nf = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, sf = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, rf = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, af = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, of = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, lf = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, cf = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, hf = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, uf = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, df = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, pf = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Af = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, ff = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, mf = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, gf = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, bf = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, vf = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Ef = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, Cf = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, xf = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, wf = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, yf = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, If = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Mf = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Sf = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, Bf = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Tf = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Rf = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, Df = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Pf = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, Lf = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Ff = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Nf = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Uf = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Qf = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, kf = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, _f = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Of = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Gf = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Hf = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Vf = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, zf = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, qf = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Wf = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Yf = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Kf = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Xf = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, jf = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, Jf = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Zf = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, $f = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, em = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, tm = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, nm = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, im = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, sm = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, rm = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, am = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, om = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, lm = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, cm = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, hm = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, um = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, dm = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, pm = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Am = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, fm = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, mm = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, gm = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, bm = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, vm = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Em = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Cm = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, xm = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, wm = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, ym = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Im = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Mm = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Sm = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Bm = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Tm = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Rm = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Dm = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Pm = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, Lm = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Fm = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, Nm = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Um = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Qm = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, km = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, _m = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Om = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Gm = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Hm = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Vm = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, zm = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, qm = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Wm = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Ym = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Ue = {
  alphahash_fragment: AA,
  alphahash_pars_fragment: fA,
  alphamap_fragment: mA,
  alphamap_pars_fragment: gA,
  alphatest_fragment: bA,
  alphatest_pars_fragment: vA,
  aomap_fragment: EA,
  aomap_pars_fragment: CA,
  batching_pars_vertex: xA,
  batching_vertex: wA,
  begin_vertex: yA,
  beginnormal_vertex: IA,
  bsdfs: MA,
  iridescence_fragment: SA,
  bumpmap_pars_fragment: BA,
  clipping_planes_fragment: TA,
  clipping_planes_pars_fragment: RA,
  clipping_planes_pars_vertex: DA,
  clipping_planes_vertex: PA,
  color_fragment: LA,
  color_pars_fragment: FA,
  color_pars_vertex: NA,
  color_vertex: UA,
  common: QA,
  cube_uv_reflection_fragment: kA,
  defaultnormal_vertex: _A,
  displacementmap_pars_vertex: OA,
  displacementmap_vertex: GA,
  emissivemap_fragment: HA,
  emissivemap_pars_fragment: VA,
  colorspace_fragment: zA,
  colorspace_pars_fragment: qA,
  envmap_fragment: WA,
  envmap_common_pars_fragment: YA,
  envmap_pars_fragment: KA,
  envmap_pars_vertex: XA,
  envmap_physical_pars_fragment: of,
  envmap_vertex: jA,
  fog_vertex: JA,
  fog_pars_vertex: ZA,
  fog_fragment: $A,
  fog_pars_fragment: ef,
  gradientmap_pars_fragment: tf,
  lightmap_pars_fragment: nf,
  lights_lambert_fragment: sf,
  lights_lambert_pars_fragment: rf,
  lights_pars_begin: af,
  lights_toon_fragment: lf,
  lights_toon_pars_fragment: cf,
  lights_phong_fragment: hf,
  lights_phong_pars_fragment: uf,
  lights_physical_fragment: df,
  lights_physical_pars_fragment: pf,
  lights_fragment_begin: Af,
  lights_fragment_maps: ff,
  lights_fragment_end: mf,
  logdepthbuf_fragment: gf,
  logdepthbuf_pars_fragment: bf,
  logdepthbuf_pars_vertex: vf,
  logdepthbuf_vertex: Ef,
  map_fragment: Cf,
  map_pars_fragment: xf,
  map_particle_fragment: wf,
  map_particle_pars_fragment: yf,
  metalnessmap_fragment: If,
  metalnessmap_pars_fragment: Mf,
  morphinstance_vertex: Sf,
  morphcolor_vertex: Bf,
  morphnormal_vertex: Tf,
  morphtarget_pars_vertex: Rf,
  morphtarget_vertex: Df,
  normal_fragment_begin: Pf,
  normal_fragment_maps: Lf,
  normal_pars_fragment: Ff,
  normal_pars_vertex: Nf,
  normal_vertex: Uf,
  normalmap_pars_fragment: Qf,
  clearcoat_normal_fragment_begin: kf,
  clearcoat_normal_fragment_maps: _f,
  clearcoat_pars_fragment: Of,
  iridescence_pars_fragment: Gf,
  opaque_fragment: Hf,
  packing: Vf,
  premultiplied_alpha_fragment: zf,
  project_vertex: qf,
  dithering_fragment: Wf,
  dithering_pars_fragment: Yf,
  roughnessmap_fragment: Kf,
  roughnessmap_pars_fragment: Xf,
  shadowmap_pars_fragment: jf,
  shadowmap_pars_vertex: Jf,
  shadowmap_vertex: Zf,
  shadowmask_pars_fragment: $f,
  skinbase_vertex: em,
  skinning_pars_vertex: tm,
  skinning_vertex: nm,
  skinnormal_vertex: im,
  specularmap_fragment: sm,
  specularmap_pars_fragment: rm,
  tonemapping_fragment: am,
  tonemapping_pars_fragment: om,
  transmission_fragment: lm,
  transmission_pars_fragment: cm,
  uv_pars_fragment: hm,
  uv_pars_vertex: um,
  uv_vertex: dm,
  worldpos_vertex: pm,
  background_vert: Am,
  background_frag: fm,
  backgroundCube_vert: mm,
  backgroundCube_frag: gm,
  cube_vert: bm,
  cube_frag: vm,
  depth_vert: Em,
  depth_frag: Cm,
  distanceRGBA_vert: xm,
  distanceRGBA_frag: wm,
  equirect_vert: ym,
  equirect_frag: Im,
  linedashed_vert: Mm,
  linedashed_frag: Sm,
  meshbasic_vert: Bm,
  meshbasic_frag: Tm,
  meshlambert_vert: Rm,
  meshlambert_frag: Dm,
  meshmatcap_vert: Pm,
  meshmatcap_frag: Lm,
  meshnormal_vert: Fm,
  meshnormal_frag: Nm,
  meshphong_vert: Um,
  meshphong_frag: Qm,
  meshphysical_vert: km,
  meshphysical_frag: _m,
  meshtoon_vert: Om,
  meshtoon_frag: Gm,
  points_vert: Hm,
  points_frag: Vm,
  shadow_vert: zm,
  shadow_frag: qm,
  sprite_vert: Wm,
  sprite_frag: Ym
}, ie = {
  common: {
    diffuse: { value: /* @__PURE__ */ new we(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Fe() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Fe() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Fe() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Fe() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Fe() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Fe() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Fe() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Fe() },
    normalScale: { value: /* @__PURE__ */ new Ie(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Fe() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Fe() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Fe() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Fe() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new we(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new we(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Fe() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Fe() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new we(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Ie(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Fe() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Fe() },
    alphaTest: { value: 0 }
  }
}, Cn = {
  basic: {
    uniforms: /* @__PURE__ */ Ot([
      ie.common,
      ie.specularmap,
      ie.envmap,
      ie.aomap,
      ie.lightmap,
      ie.fog
    ]),
    vertexShader: Ue.meshbasic_vert,
    fragmentShader: Ue.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Ot([
      ie.common,
      ie.specularmap,
      ie.envmap,
      ie.aomap,
      ie.lightmap,
      ie.emissivemap,
      ie.bumpmap,
      ie.normalmap,
      ie.displacementmap,
      ie.fog,
      ie.lights,
      {
        emissive: { value: /* @__PURE__ */ new we(0) }
      }
    ]),
    vertexShader: Ue.meshlambert_vert,
    fragmentShader: Ue.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Ot([
      ie.common,
      ie.specularmap,
      ie.envmap,
      ie.aomap,
      ie.lightmap,
      ie.emissivemap,
      ie.bumpmap,
      ie.normalmap,
      ie.displacementmap,
      ie.fog,
      ie.lights,
      {
        emissive: { value: /* @__PURE__ */ new we(0) },
        specular: { value: /* @__PURE__ */ new we(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Ue.meshphong_vert,
    fragmentShader: Ue.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Ot([
      ie.common,
      ie.envmap,
      ie.aomap,
      ie.lightmap,
      ie.emissivemap,
      ie.bumpmap,
      ie.normalmap,
      ie.displacementmap,
      ie.roughnessmap,
      ie.metalnessmap,
      ie.fog,
      ie.lights,
      {
        emissive: { value: /* @__PURE__ */ new we(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Ue.meshphysical_vert,
    fragmentShader: Ue.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Ot([
      ie.common,
      ie.aomap,
      ie.lightmap,
      ie.emissivemap,
      ie.bumpmap,
      ie.normalmap,
      ie.displacementmap,
      ie.gradientmap,
      ie.fog,
      ie.lights,
      {
        emissive: { value: /* @__PURE__ */ new we(0) }
      }
    ]),
    vertexShader: Ue.meshtoon_vert,
    fragmentShader: Ue.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Ot([
      ie.common,
      ie.bumpmap,
      ie.normalmap,
      ie.displacementmap,
      ie.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Ue.meshmatcap_vert,
    fragmentShader: Ue.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Ot([
      ie.points,
      ie.fog
    ]),
    vertexShader: Ue.points_vert,
    fragmentShader: Ue.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Ot([
      ie.common,
      ie.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Ue.linedashed_vert,
    fragmentShader: Ue.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Ot([
      ie.common,
      ie.displacementmap
    ]),
    vertexShader: Ue.depth_vert,
    fragmentShader: Ue.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Ot([
      ie.common,
      ie.bumpmap,
      ie.normalmap,
      ie.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ue.meshnormal_vert,
    fragmentShader: Ue.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Ot([
      ie.sprite,
      ie.fog
    ]),
    vertexShader: Ue.sprite_vert,
    fragmentShader: Ue.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Fe() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Ue.background_vert,
    fragmentShader: Ue.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Fe() }
    },
    vertexShader: Ue.backgroundCube_vert,
    fragmentShader: Ue.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Ue.cube_vert,
    fragmentShader: Ue.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Ue.equirect_vert,
    fragmentShader: Ue.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Ot([
      ie.common,
      ie.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new T() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Ue.distanceRGBA_vert,
    fragmentShader: Ue.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Ot([
      ie.lights,
      ie.fog,
      {
        color: { value: /* @__PURE__ */ new we(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ue.shadow_vert,
    fragmentShader: Ue.shadow_frag
  }
};
Cn.physical = {
  uniforms: /* @__PURE__ */ Ot([
    Cn.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Fe() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Fe() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Ie(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Fe() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Fe() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Fe() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new we(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Fe() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Fe() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Fe() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Ie() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Fe() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new we(0) },
      specularColor: { value: /* @__PURE__ */ new we(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Fe() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Fe() },
      anisotropyVector: { value: /* @__PURE__ */ new Ie() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Fe() }
    }
  ]),
  vertexShader: Ue.meshphysical_vert,
  fragmentShader: Ue.meshphysical_frag
};
const kr = { r: 0, b: 0, g: 0 }, Ci = /* @__PURE__ */ new In(), Km = /* @__PURE__ */ new Pe();
function Xm(i, e, t, n, s, r, a) {
  const o = new we(0);
  let l = r === !0 ? 0 : 1, c, h, u = null, d = 0, A = null;
  function m(E) {
    let b = E.isScene === !0 ? E.background : null;
    return b && b.isTexture && (b = (E.backgroundBlurriness > 0 ? t : e).get(b)), b;
  }
  function g(E) {
    let b = !1;
    const S = m(E);
    S === null ? p(o, l) : S && S.isColor && (p(S, 1), b = !0);
    const I = i.xr.getEnvironmentBlendMode();
    I === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : I === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (i.autoClear || b) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil));
  }
  function f(E, b) {
    const S = m(b);
    S && (S.isCubeTexture || S.mapping === 306) ? (h === void 0 && (h = new ot(
      new bs(1, 1, 1),
      new Mn({
        name: "BackgroundCubeMaterial",
        uniforms: ps(Cn.backgroundCube.uniforms),
        vertexShader: Cn.backgroundCube.vertexShader,
        fragmentShader: Cn.backgroundCube.fragmentShader,
        side: 1,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(I, B, R) {
      this.matrixWorld.copyPosition(R.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), s.update(h)), Ci.copy(b.backgroundRotation), Ci.x *= -1, Ci.y *= -1, Ci.z *= -1, S.isCubeTexture && S.isRenderTargetTexture === !1 && (Ci.y *= -1, Ci.z *= -1), h.material.uniforms.envMap.value = S, h.material.uniforms.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = b.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = b.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(Km.makeRotationFromEuler(Ci)), h.material.toneMapped = We.getTransfer(S.colorSpace) !== at, (u !== S || d !== S.version || A !== i.toneMapping) && (h.material.needsUpdate = !0, u = S, d = S.version, A = i.toneMapping), h.layers.enableAll(), E.unshift(h, h.geometry, h.material, 0, 0, null)) : S && S.isTexture && (c === void 0 && (c = new ot(
      new Li(2, 2),
      new Mn({
        name: "BackgroundMaterial",
        uniforms: ps(Cn.background.uniforms),
        vertexShader: Cn.background.vertexShader,
        fragmentShader: Cn.background.fragmentShader,
        side: 0,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), s.update(c)), c.material.uniforms.t2D.value = S, c.material.uniforms.backgroundIntensity.value = b.backgroundIntensity, c.material.toneMapped = We.getTransfer(S.colorSpace) !== at, S.matrixAutoUpdate === !0 && S.updateMatrix(), c.material.uniforms.uvTransform.value.copy(S.matrix), (u !== S || d !== S.version || A !== i.toneMapping) && (c.material.needsUpdate = !0, u = S, d = S.version, A = i.toneMapping), c.layers.enableAll(), E.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function p(E, b) {
    E.getRGB(kr, kh(i)), n.buffers.color.setClear(kr.r, kr.g, kr.b, b, a);
  }
  function v() {
    h !== void 0 && (h.geometry.dispose(), h.material.dispose(), h = void 0), c !== void 0 && (c.geometry.dispose(), c.material.dispose(), c = void 0);
  }
  return {
    getClearColor: function() {
      return o;
    },
    setClearColor: function(E, b = 1) {
      o.set(E), l = b, p(o, l);
    },
    getClearAlpha: function() {
      return l;
    },
    setClearAlpha: function(E) {
      l = E, p(o, l);
    },
    render: g,
    addToRenderList: f,
    dispose: v
  };
}
function jm(i, e) {
  const t = i.getParameter(i.MAX_VERTEX_ATTRIBS), n = {}, s = d(null);
  let r = s, a = !1;
  function o(C, D, _, Q, H) {
    let j = !1;
    const V = u(Q, _, D);
    r !== V && (r = V, c(r.object)), j = A(C, Q, _, H), j && m(C, Q, _, H), H !== null && e.update(H, i.ELEMENT_ARRAY_BUFFER), (j || a) && (a = !1, b(C, D, _, Q), H !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.get(H).buffer));
  }
  function l() {
    return i.createVertexArray();
  }
  function c(C) {
    return i.bindVertexArray(C);
  }
  function h(C) {
    return i.deleteVertexArray(C);
  }
  function u(C, D, _) {
    const Q = _.wireframe === !0;
    let H = n[C.id];
    H === void 0 && (H = {}, n[C.id] = H);
    let j = H[D.id];
    j === void 0 && (j = {}, H[D.id] = j);
    let V = j[Q];
    return V === void 0 && (V = d(l()), j[Q] = V), V;
  }
  function d(C) {
    const D = [], _ = [], Q = [];
    for (let H = 0; H < t; H++)
      D[H] = 0, _[H] = 0, Q[H] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: D,
      enabledAttributes: _,
      attributeDivisors: Q,
      object: C,
      attributes: {},
      index: null
    };
  }
  function A(C, D, _, Q) {
    const H = r.attributes, j = D.attributes;
    let V = 0;
    const J = _.getAttributes();
    for (const G in J)
      if (J[G].location >= 0) {
        const le = H[G];
        let me = j[G];
        if (me === void 0 && (G === "instanceMatrix" && C.instanceMatrix && (me = C.instanceMatrix), G === "instanceColor" && C.instanceColor && (me = C.instanceColor)), le === void 0 || le.attribute !== me || me && le.data !== me.data) return !0;
        V++;
      }
    return r.attributesNum !== V || r.index !== Q;
  }
  function m(C, D, _, Q) {
    const H = {}, j = D.attributes;
    let V = 0;
    const J = _.getAttributes();
    for (const G in J)
      if (J[G].location >= 0) {
        let le = j[G];
        le === void 0 && (G === "instanceMatrix" && C.instanceMatrix && (le = C.instanceMatrix), G === "instanceColor" && C.instanceColor && (le = C.instanceColor));
        const me = {};
        me.attribute = le, le && le.data && (me.data = le.data), H[G] = me, V++;
      }
    r.attributes = H, r.attributesNum = V, r.index = Q;
  }
  function g() {
    const C = r.newAttributes;
    for (let D = 0, _ = C.length; D < _; D++)
      C[D] = 0;
  }
  function f(C) {
    p(C, 0);
  }
  function p(C, D) {
    const _ = r.newAttributes, Q = r.enabledAttributes, H = r.attributeDivisors;
    _[C] = 1, Q[C] === 0 && (i.enableVertexAttribArray(C), Q[C] = 1), H[C] !== D && (i.vertexAttribDivisor(C, D), H[C] = D);
  }
  function v() {
    const C = r.newAttributes, D = r.enabledAttributes;
    for (let _ = 0, Q = D.length; _ < Q; _++)
      D[_] !== C[_] && (i.disableVertexAttribArray(_), D[_] = 0);
  }
  function E(C, D, _, Q, H, j, V) {
    V === !0 ? i.vertexAttribIPointer(C, D, _, H, j) : i.vertexAttribPointer(C, D, _, Q, H, j);
  }
  function b(C, D, _, Q) {
    g();
    const H = Q.attributes, j = _.getAttributes(), V = D.defaultAttributeValues;
    for (const J in j) {
      const G = j[J];
      if (G.location >= 0) {
        let te = H[J];
        if (te === void 0 && (J === "instanceMatrix" && C.instanceMatrix && (te = C.instanceMatrix), J === "instanceColor" && C.instanceColor && (te = C.instanceColor)), te !== void 0) {
          const le = te.normalized, me = te.itemSize, Re = e.get(te);
          if (Re === void 0) continue;
          const Ge = Re.buffer, q = Re.type, ne = Re.bytesPerElement, ge = q === i.INT || q === i.UNSIGNED_INT || te.gpuType === 1013;
          if (te.isInterleavedBufferAttribute) {
            const ae = te.data, Me = ae.stride, Ze = te.offset;
            if (ae.isInstancedInterleavedBuffer) {
              for (let Se = 0; Se < G.locationSize; Se++)
                p(G.location + Se, ae.meshPerAttribute);
              C.isInstancedMesh !== !0 && Q._maxInstanceCount === void 0 && (Q._maxInstanceCount = ae.meshPerAttribute * ae.count);
            } else
              for (let Se = 0; Se < G.locationSize; Se++)
                f(G.location + Se);
            i.bindBuffer(i.ARRAY_BUFFER, Ge);
            for (let Se = 0; Se < G.locationSize; Se++)
              E(
                G.location + Se,
                me / G.locationSize,
                q,
                le,
                Me * ne,
                (Ze + me / G.locationSize * Se) * ne,
                ge
              );
          } else {
            if (te.isInstancedBufferAttribute) {
              for (let ae = 0; ae < G.locationSize; ae++)
                p(G.location + ae, te.meshPerAttribute);
              C.isInstancedMesh !== !0 && Q._maxInstanceCount === void 0 && (Q._maxInstanceCount = te.meshPerAttribute * te.count);
            } else
              for (let ae = 0; ae < G.locationSize; ae++)
                f(G.location + ae);
            i.bindBuffer(i.ARRAY_BUFFER, Ge);
            for (let ae = 0; ae < G.locationSize; ae++)
              E(
                G.location + ae,
                me / G.locationSize,
                q,
                le,
                me * ne,
                me / G.locationSize * ae * ne,
                ge
              );
          }
        } else if (V !== void 0) {
          const le = V[J];
          if (le !== void 0)
            switch (le.length) {
              case 2:
                i.vertexAttrib2fv(G.location, le);
                break;
              case 3:
                i.vertexAttrib3fv(G.location, le);
                break;
              case 4:
                i.vertexAttrib4fv(G.location, le);
                break;
              default:
                i.vertexAttrib1fv(G.location, le);
            }
        }
      }
    }
    v();
  }
  function S() {
    R();
    for (const C in n) {
      const D = n[C];
      for (const _ in D) {
        const Q = D[_];
        for (const H in Q)
          h(Q[H].object), delete Q[H];
        delete D[_];
      }
      delete n[C];
    }
  }
  function I(C) {
    if (n[C.id] === void 0) return;
    const D = n[C.id];
    for (const _ in D) {
      const Q = D[_];
      for (const H in Q)
        h(Q[H].object), delete Q[H];
      delete D[_];
    }
    delete n[C.id];
  }
  function B(C) {
    for (const D in n) {
      const _ = n[D];
      if (_[C.id] === void 0) continue;
      const Q = _[C.id];
      for (const H in Q)
        h(Q[H].object), delete Q[H];
      delete _[C.id];
    }
  }
  function R() {
    w(), a = !0, r !== s && (r = s, c(r.object));
  }
  function w() {
    s.geometry = null, s.program = null, s.wireframe = !1;
  }
  return {
    setup: o,
    reset: R,
    resetDefaultState: w,
    dispose: S,
    releaseStatesOfGeometry: I,
    releaseStatesOfProgram: B,
    initAttributes: g,
    enableAttribute: f,
    disableUnusedAttributes: v
  };
}
function Jm(i, e, t) {
  let n;
  function s(c) {
    n = c;
  }
  function r(c, h) {
    i.drawArrays(n, c, h), t.update(h, n, 1);
  }
  function a(c, h, u) {
    u !== 0 && (i.drawArraysInstanced(n, c, h, u), t.update(h, n, u));
  }
  function o(c, h, u) {
    if (u === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, h, 0, u);
    let A = 0;
    for (let m = 0; m < u; m++)
      A += h[m];
    t.update(A, n, 1);
  }
  function l(c, h, u, d) {
    if (u === 0) return;
    const A = e.get("WEBGL_multi_draw");
    if (A === null)
      for (let m = 0; m < c.length; m++)
        a(c[m], h[m], d[m]);
    else {
      A.multiDrawArraysInstancedWEBGL(n, c, 0, h, 0, d, 0, u);
      let m = 0;
      for (let g = 0; g < u; g++)
        m += h[g] * d[g];
      t.update(m, n, 1);
    }
  }
  this.setMode = s, this.render = r, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = l;
}
function Zm(i, e, t, n) {
  let s;
  function r() {
    if (s !== void 0) return s;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const B = e.get("EXT_texture_filter_anisotropic");
      s = i.getParameter(B.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      s = 0;
    return s;
  }
  function a(B) {
    return !(B !== 1023 && n.convert(B) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function o(B) {
    const R = B === 1016 && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(B !== 1009 && n.convert(B) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    B !== 1015 && !R);
  }
  function l(B) {
    if (B === "highp") {
      if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0)
        return "highp";
      B = "mediump";
    }
    return B === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let c = t.precision !== void 0 ? t.precision : "highp";
  const h = l(c);
  h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
  const u = t.logarithmicDepthBuffer === !0, d = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), A = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), m = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS), g = i.getParameter(i.MAX_TEXTURE_SIZE), f = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE), p = i.getParameter(i.MAX_VERTEX_ATTRIBS), v = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS), E = i.getParameter(i.MAX_VARYING_VECTORS), b = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS), S = m > 0, I = i.getParameter(i.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: r,
    getMaxPrecision: l,
    textureFormatReadable: a,
    textureTypeReadable: o,
    precision: c,
    logarithmicDepthBuffer: u,
    reverseDepthBuffer: d,
    maxTextures: A,
    maxVertexTextures: m,
    maxTextureSize: g,
    maxCubemapSize: f,
    maxAttributes: p,
    maxVertexUniforms: v,
    maxVaryings: E,
    maxFragmentUniforms: b,
    vertexTextures: S,
    maxSamples: I
  };
}
function $m(i) {
  const e = this;
  let t = null, n = 0, s = !1, r = !1;
  const a = new Ii(), o = new Fe(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, d) {
    const A = u.length !== 0 || d || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || s;
    return s = d, n = u.length, A;
  }, this.beginShadows = function() {
    r = !0, h(null);
  }, this.endShadows = function() {
    r = !1;
  }, this.setGlobalState = function(u, d) {
    t = h(u, d, 0);
  }, this.setState = function(u, d, A) {
    const m = u.clippingPlanes, g = u.clipIntersection, f = u.clipShadows, p = i.get(u);
    if (!s || m === null || m.length === 0 || r && !f)
      r ? h(null) : c();
    else {
      const v = r ? 0 : n, E = v * 4;
      let b = p.clippingState || null;
      l.value = b, b = h(m, d, E, A);
      for (let S = 0; S !== E; ++S)
        b[S] = t[S];
      p.clippingState = b, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += v;
    }
  };
  function c() {
    l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function h(u, d, A, m) {
    const g = u !== null ? u.length : 0;
    let f = null;
    if (g !== 0) {
      if (f = l.value, m !== !0 || f === null) {
        const p = A + g * 4, v = d.matrixWorldInverse;
        o.getNormalMatrix(v), (f === null || f.length < p) && (f = new Float32Array(p));
        for (let E = 0, b = A; E !== g; ++E, b += 4)
          a.copy(u[E]).applyMatrix4(v, o), a.normal.toArray(f, b), f[b + 3] = a.constant;
      }
      l.value = f, l.needsUpdate = !0;
    }
    return e.numPlanes = g, e.numIntersection = 0, f;
  }
}
function eg(i) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(a, o) {
    return o === 303 ? a.mapping = 301 : o === 304 && (a.mapping = 302), a;
  }
  function n(a) {
    if (a && a.isTexture) {
      const o = a.mapping;
      if (o === 303 || o === 304)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return t(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new bp(l.height);
            return c.fromEquirectangularTexture(i, a), e.set(a, c), a.addEventListener("dispose", s), t(c.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function s(a) {
    const o = a.target;
    o.removeEventListener("dispose", s);
    const l = e.get(o);
    l !== void 0 && (e.delete(o), l.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: r
  };
}
const os = 4, Ec = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Si = 20, Ha = /* @__PURE__ */ new oa(), Cc = /* @__PURE__ */ new we();
let Va = null, za = 0, qa = 0, Wa = !1;
const Mi = (1 + Math.sqrt(5)) / 2, ts = 1 / Mi, xc = [
  /* @__PURE__ */ new T(-Mi, ts, 0),
  /* @__PURE__ */ new T(Mi, ts, 0),
  /* @__PURE__ */ new T(-ts, 0, Mi),
  /* @__PURE__ */ new T(ts, 0, Mi),
  /* @__PURE__ */ new T(0, Mi, -ts),
  /* @__PURE__ */ new T(0, Mi, ts),
  /* @__PURE__ */ new T(-1, 1, -1),
  /* @__PURE__ */ new T(1, 1, -1),
  /* @__PURE__ */ new T(-1, 1, 1),
  /* @__PURE__ */ new T(1, 1, 1)
];
class wc {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   *
   * @param {Scene} scene
   * @param {number} sigma
   * @param {number} near
   * @param {number} far
   * @return {WebGLRenderTarget}
   */
  fromScene(e, t = 0, n = 0.1, s = 100) {
    Va = this._renderer.getRenderTarget(), za = this._renderer.getActiveCubeFace(), qa = this._renderer.getActiveMipmapLevel(), Wa = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const r = this._allocateTargets();
    return r.depthBuffer = !0, this._sceneToCubeUV(e, n, s, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   *
   * @param {Texture} equirectangular
   * @param {WebGLRenderTarget} [renderTarget=null] - Optional render target.
   * @return {WebGLRenderTarget}
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   *
   * @param {Texture} cubemap
   * @param {null} [renderTarget=null] - Optional render target.
   * @return {WebGLRenderTarget}
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = Mc(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = Ic(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Va, za, qa), this._renderer.xr.enabled = Wa, e.scissorTest = !1, _r(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === 301 || e.mapping === 302 ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Va = this._renderer.getRenderTarget(), za = this._renderer.getActiveCubeFace(), qa = this._renderer.getActiveMipmapLevel(), Wa = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: 1006,
      minFilter: 1006,
      generateMipmaps: !1,
      type: 1016,
      format: 1023,
      colorSpace: Ut,
      depthBuffer: !1
    }, s = yc(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = yc(e, t, n);
      const { _lodMax: r } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = tg(r)), this._blurMaterial = ng(r, e, t);
    }
    return s;
  }
  _compileMaterial(e) {
    const t = new ot(this._lodPlanes[0], e);
    this._renderer.compile(t, Ha);
  }
  _sceneToCubeUV(e, t, n, s) {
    const o = new Gt(90, 1, t, n), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], h = this._renderer, u = h.autoClear, d = h.toneMapping;
    h.getClearColor(Cc), h.toneMapping = 0, h.autoClear = !1;
    const A = new Hn({
      name: "PMREM.Background",
      side: 1,
      depthWrite: !1,
      depthTest: !1
    }), m = new ot(new bs(), A);
    let g = !1;
    const f = e.background;
    f ? f.isColor && (A.color.copy(f), e.background = null, g = !0) : (A.color.copy(Cc), g = !0);
    for (let p = 0; p < 6; p++) {
      const v = p % 3;
      v === 0 ? (o.up.set(0, l[p], 0), o.lookAt(c[p], 0, 0)) : v === 1 ? (o.up.set(0, 0, l[p]), o.lookAt(0, c[p], 0)) : (o.up.set(0, l[p], 0), o.lookAt(0, 0, c[p]));
      const E = this._cubeSize;
      _r(s, v * E, p > 2 ? E : 0, E, E), h.setRenderTarget(s), g && h.render(m, o), h.render(e, o);
    }
    m.geometry.dispose(), m.material.dispose(), h.toneMapping = d, h.autoClear = u, e.background = f;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, s = e.mapping === 301 || e.mapping === 302;
    s ? (this._cubemapMaterial === null && (this._cubemapMaterial = Mc()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Ic());
    const r = s ? this._cubemapMaterial : this._equirectMaterial, a = new ot(this._lodPlanes[0], r), o = r.uniforms;
    o.envMap.value = e;
    const l = this._cubeSize;
    _r(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(a, Ha);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    const s = this._lodPlanes.length;
    for (let r = 1; r < s; r++) {
      const a = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = xc[(s - r - 1) % xc.length];
      this._blur(e, r - 1, r, a, o);
    }
    t.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * @param {WebGLRenderTarget} cubeUVRenderTarget
   * @param {number} lodIn
   * @param {number} lodOut
   * @param {number} sigma
   * @param {Vector3} [poleAxis]
   */
  _blur(e, t, n, s, r) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      a,
      t,
      n,
      s,
      "latitudinal",
      r
    ), this._halfBlur(
      a,
      e,
      n,
      n,
      s,
      "longitudinal",
      r
    );
  }
  _halfBlur(e, t, n, s, r, a, o) {
    const l = this._renderer, c = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const h = 3, u = new ot(this._lodPlanes[s], c), d = c.uniforms, A = this._sizeLods[n] - 1, m = isFinite(r) ? Math.PI / (2 * A) : 2 * Math.PI / (2 * Si - 1), g = r / m, f = isFinite(r) ? 1 + Math.floor(h * g) : Si;
    f > Si && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${Si}`);
    const p = [];
    let v = 0;
    for (let B = 0; B < Si; ++B) {
      const R = B / g, w = Math.exp(-R * R / 2);
      p.push(w), B === 0 ? v += w : B < f && (v += 2 * w);
    }
    for (let B = 0; B < p.length; B++)
      p[B] = p[B] / v;
    d.envMap.value = e.texture, d.samples.value = f, d.weights.value = p, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
    const { _lodMax: E } = this;
    d.dTheta.value = m, d.mipInt.value = E - n;
    const b = this._sizeLods[s], S = 3 * b * (s > E - os ? s - E + os : 0), I = 4 * (this._cubeSize - b);
    _r(t, S, I, 3 * b, 2 * b), l.setRenderTarget(t), l.render(u, Ha);
  }
}
function tg(i) {
  const e = [], t = [], n = [];
  let s = i;
  const r = i - os + 1 + Ec.length;
  for (let a = 0; a < r; a++) {
    const o = Math.pow(2, s);
    t.push(o);
    let l = 1 / o;
    a > i - os ? l = Ec[a - i + os - 1] : a === 0 && (l = 0), n.push(l);
    const c = 1 / (o - 2), h = -c, u = 1 + c, d = [h, h, u, h, u, u, h, h, u, u, h, u], A = 6, m = 6, g = 3, f = 2, p = 1, v = new Float32Array(g * m * A), E = new Float32Array(f * m * A), b = new Float32Array(p * m * A);
    for (let I = 0; I < A; I++) {
      const B = I % 3 * 2 / 3 - 1, R = I > 2 ? 0 : -1, w = [
        B,
        R,
        0,
        B + 2 / 3,
        R,
        0,
        B + 2 / 3,
        R + 1,
        0,
        B,
        R,
        0,
        B + 2 / 3,
        R + 1,
        0,
        B,
        R + 1,
        0
      ];
      v.set(w, g * m * I), E.set(d, f * m * I);
      const C = [I, I, I, I, I, I];
      b.set(C, p * m * I);
    }
    const S = new Bt();
    S.setAttribute("position", new Ht(v, g)), S.setAttribute("uv", new Ht(E, f)), S.setAttribute("faceIndex", new Ht(b, p)), e.push(S), s > os && s--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function yc(i, e, t) {
  const n = new Kn(i, e, t);
  return n.texture.mapping = 306, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function _r(i, e, t, n, s) {
  i.viewport.set(e, t, n, s), i.scissor.set(e, t, n, s);
}
function ng(i, e, t) {
  const n = new Float32Array(Si), s = new T(0, 1, 0);
  return new Mn({
    name: "SphericalGaussianBlur",
    defines: {
      n: Si,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${i}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: s }
    },
    vertexShader: jo(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}
function Ic() {
  return new Mn({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: jo(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}
function Mc() {
  return new Mn({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: jo(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}
function jo() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function ig(i) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping, c = l === 303 || l === 304, h = l === 301 || l === 302;
      if (c || h) {
        let u = e.get(o);
        const d = u !== void 0 ? u.texture.pmremVersion : 0;
        if (o.isRenderTargetTexture && o.pmremVersion !== d)
          return t === null && (t = new wc(i)), u = c ? t.fromEquirectangular(o, u) : t.fromCubemap(o, u), u.texture.pmremVersion = o.pmremVersion, e.set(o, u), u.texture;
        if (u !== void 0)
          return u.texture;
        {
          const A = o.image;
          return c && A && A.height > 0 || h && A && s(A) ? (t === null && (t = new wc(i)), u = c ? t.fromEquirectangular(o) : t.fromCubemap(o), u.texture.pmremVersion = o.pmremVersion, e.set(o, u), o.addEventListener("dispose", r), u.texture) : null;
        }
      }
    }
    return o;
  }
  function s(o) {
    let l = 0;
    const c = 6;
    for (let h = 0; h < c; h++)
      o[h] !== void 0 && l++;
    return l === c;
  }
  function r(o) {
    const l = o.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: a
  };
}
function sg(i) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let s;
    switch (n) {
      case "WEBGL_depth_texture":
        s = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        s = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        s = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        s = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        s = i.getExtension(n);
    }
    return e[n] = s, s;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function() {
      t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
    },
    get: function(n) {
      const s = t(n);
      return s === null && as("THREE.WebGLRenderer: " + n + " extension not supported."), s;
    }
  };
}
function rg(i, e, t, n) {
  const s = {}, r = /* @__PURE__ */ new WeakMap();
  function a(u) {
    const d = u.target;
    d.index !== null && e.remove(d.index);
    for (const m in d.attributes)
      e.remove(d.attributes[m]);
    d.removeEventListener("dispose", a), delete s[d.id];
    const A = r.get(d);
    A && (e.remove(A), r.delete(d)), n.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--;
  }
  function o(u, d) {
    return s[d.id] === !0 || (d.addEventListener("dispose", a), s[d.id] = !0, t.memory.geometries++), d;
  }
  function l(u) {
    const d = u.attributes;
    for (const A in d)
      e.update(d[A], i.ARRAY_BUFFER);
  }
  function c(u) {
    const d = [], A = u.index, m = u.attributes.position;
    let g = 0;
    if (A !== null) {
      const v = A.array;
      g = A.version;
      for (let E = 0, b = v.length; E < b; E += 3) {
        const S = v[E + 0], I = v[E + 1], B = v[E + 2];
        d.push(S, I, I, B, B, S);
      }
    } else if (m !== void 0) {
      const v = m.array;
      g = m.version;
      for (let E = 0, b = v.length / 3 - 1; E < b; E += 3) {
        const S = E + 0, I = E + 1, B = E + 2;
        d.push(S, I, I, B, B, S);
      }
    } else
      return;
    const f = new (Rh(d) ? Qh : Uh)(d, 1);
    f.version = g;
    const p = r.get(u);
    p && e.remove(p), r.set(u, f);
  }
  function h(u) {
    const d = r.get(u);
    if (d) {
      const A = u.index;
      A !== null && d.version < A.version && c(u);
    } else
      c(u);
    return r.get(u);
  }
  return {
    get: o,
    update: l,
    getWireframeAttribute: h
  };
}
function ag(i, e, t) {
  let n;
  function s(d) {
    n = d;
  }
  let r, a;
  function o(d) {
    r = d.type, a = d.bytesPerElement;
  }
  function l(d, A) {
    i.drawElements(n, A, r, d * a), t.update(A, n, 1);
  }
  function c(d, A, m) {
    m !== 0 && (i.drawElementsInstanced(n, A, r, d * a, m), t.update(A, n, m));
  }
  function h(d, A, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, A, 0, r, d, 0, m);
    let f = 0;
    for (let p = 0; p < m; p++)
      f += A[p];
    t.update(f, n, 1);
  }
  function u(d, A, m, g) {
    if (m === 0) return;
    const f = e.get("WEBGL_multi_draw");
    if (f === null)
      for (let p = 0; p < d.length; p++)
        c(d[p] / a, A[p], g[p]);
    else {
      f.multiDrawElementsInstancedWEBGL(n, A, 0, r, d, 0, g, 0, m);
      let p = 0;
      for (let v = 0; v < m; v++)
        p += A[v] * g[v];
      t.update(p, n, 1);
    }
  }
  this.setMode = s, this.setIndex = o, this.render = l, this.renderInstances = c, this.renderMultiDraw = h, this.renderMultiDrawInstances = u;
}
function og(i) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(r, a, o) {
    switch (t.calls++, a) {
      case i.TRIANGLES:
        t.triangles += o * (r / 3);
        break;
      case i.LINES:
        t.lines += o * (r / 2);
        break;
      case i.LINE_STRIP:
        t.lines += o * (r - 1);
        break;
      case i.LINE_LOOP:
        t.lines += o * r;
        break;
      case i.POINTS:
        t.points += o * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function s() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: s,
    update: n
  };
}
function lg(i, e, t) {
  const n = /* @__PURE__ */ new WeakMap(), s = new $e();
  function r(a, o, l) {
    const c = a.morphTargetInfluences, h = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, u = h !== void 0 ? h.length : 0;
    let d = n.get(o);
    if (d === void 0 || d.count !== u) {
      let w = function() {
        B.dispose(), n.delete(o), o.removeEventListener("dispose", w);
      };
      d !== void 0 && d.texture.dispose();
      const A = o.morphAttributes.position !== void 0, m = o.morphAttributes.normal !== void 0, g = o.morphAttributes.color !== void 0, f = o.morphAttributes.position || [], p = o.morphAttributes.normal || [], v = o.morphAttributes.color || [];
      let E = 0;
      A === !0 && (E = 1), m === !0 && (E = 2), g === !0 && (E = 3);
      let b = o.attributes.position.count * E, S = 1;
      b > e.maxTextureSize && (S = Math.ceil(b / e.maxTextureSize), b = e.maxTextureSize);
      const I = new Float32Array(b * S * 4 * u), B = new Ph(I, b, S, u);
      B.type = 1015, B.needsUpdate = !0;
      const R = E * 4;
      for (let C = 0; C < u; C++) {
        const D = f[C], _ = p[C], Q = v[C], H = b * S * 4 * C;
        for (let j = 0; j < D.count; j++) {
          const V = j * R;
          A === !0 && (s.fromBufferAttribute(D, j), I[H + V + 0] = s.x, I[H + V + 1] = s.y, I[H + V + 2] = s.z, I[H + V + 3] = 0), m === !0 && (s.fromBufferAttribute(_, j), I[H + V + 4] = s.x, I[H + V + 5] = s.y, I[H + V + 6] = s.z, I[H + V + 7] = 0), g === !0 && (s.fromBufferAttribute(Q, j), I[H + V + 8] = s.x, I[H + V + 9] = s.y, I[H + V + 10] = s.z, I[H + V + 11] = Q.itemSize === 4 ? s.w : 1);
        }
      }
      d = {
        count: u,
        texture: B,
        size: new Ie(b, S)
      }, n.set(o, d), o.addEventListener("dispose", w);
    }
    if (a.isInstancedMesh === !0 && a.morphTexture !== null)
      l.getUniforms().setValue(i, "morphTexture", a.morphTexture, t);
    else {
      let A = 0;
      for (let g = 0; g < c.length; g++)
        A += c[g];
      const m = o.morphTargetsRelative ? 1 : 1 - A;
      l.getUniforms().setValue(i, "morphTargetBaseInfluence", m), l.getUniforms().setValue(i, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(i, "morphTargetsTexture", d.texture, t), l.getUniforms().setValue(i, "morphTargetsTextureSize", d.size);
  }
  return {
    update: r
  };
}
function cg(i, e, t, n) {
  let s = /* @__PURE__ */ new WeakMap();
  function r(l) {
    const c = n.render.frame, h = l.geometry, u = e.get(l, h);
    if (s.get(u) !== c && (e.update(u), s.set(u, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === !1 && l.addEventListener("dispose", o), s.get(l) !== c && (t.update(l.instanceMatrix, i.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, i.ARRAY_BUFFER), s.set(l, c))), l.isSkinnedMesh) {
      const d = l.skeleton;
      s.get(d) !== c && (d.update(), s.set(d, c));
    }
    return u;
  }
  function a() {
    s = /* @__PURE__ */ new WeakMap();
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return {
    update: r,
    dispose: a
  };
}
const Kh = /* @__PURE__ */ new It(), Sc = /* @__PURE__ */ new Qo(1, 1), Xh = /* @__PURE__ */ new Ph(), jh = /* @__PURE__ */ new Lh(), Jh = /* @__PURE__ */ new Oh(), Bc = [], Tc = [], Rc = new Float32Array(16), Dc = new Float32Array(9), Pc = new Float32Array(4);
function Cs(i, e, t) {
  const n = i[0];
  if (n <= 0 || n > 0) return i;
  const s = e * t;
  let r = Bc[s];
  if (r === void 0 && (r = new Float32Array(s), Bc[s] = r), e !== 0) {
    n.toArray(r, 0);
    for (let a = 1, o = 0; a !== e; ++a)
      o += t, i[a].toArray(r, o);
  }
  return r;
}
function Mt(i, e) {
  if (i.length !== e.length) return !1;
  for (let t = 0, n = i.length; t < n; t++)
    if (i[t] !== e[t]) return !1;
  return !0;
}
function St(i, e) {
  for (let t = 0, n = e.length; t < n; t++)
    i[t] = e[t];
}
function la(i, e) {
  let t = Tc[e];
  t === void 0 && (t = new Int32Array(e), Tc[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = i.allocateTextureUnit();
  return t;
}
function hg(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1f(this.addr, e), t[0] = e);
}
function ug(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Mt(t, e)) return;
    i.uniform2fv(this.addr, e), St(t, e);
  }
}
function dg(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (Mt(t, e)) return;
    i.uniform3fv(this.addr, e), St(t, e);
  }
}
function pg(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Mt(t, e)) return;
    i.uniform4fv(this.addr, e), St(t, e);
  }
}
function Ag(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (Mt(t, e)) return;
    i.uniformMatrix2fv(this.addr, !1, e), St(t, e);
  } else {
    if (Mt(t, n)) return;
    Pc.set(n), i.uniformMatrix2fv(this.addr, !1, Pc), St(t, n);
  }
}
function fg(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (Mt(t, e)) return;
    i.uniformMatrix3fv(this.addr, !1, e), St(t, e);
  } else {
    if (Mt(t, n)) return;
    Dc.set(n), i.uniformMatrix3fv(this.addr, !1, Dc), St(t, n);
  }
}
function mg(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (Mt(t, e)) return;
    i.uniformMatrix4fv(this.addr, !1, e), St(t, e);
  } else {
    if (Mt(t, n)) return;
    Rc.set(n), i.uniformMatrix4fv(this.addr, !1, Rc), St(t, n);
  }
}
function gg(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1i(this.addr, e), t[0] = e);
}
function bg(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Mt(t, e)) return;
    i.uniform2iv(this.addr, e), St(t, e);
  }
}
function vg(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Mt(t, e)) return;
    i.uniform3iv(this.addr, e), St(t, e);
  }
}
function Eg(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Mt(t, e)) return;
    i.uniform4iv(this.addr, e), St(t, e);
  }
}
function Cg(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1ui(this.addr, e), t[0] = e);
}
function xg(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Mt(t, e)) return;
    i.uniform2uiv(this.addr, e), St(t, e);
  }
}
function wg(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Mt(t, e)) return;
    i.uniform3uiv(this.addr, e), St(t, e);
  }
}
function yg(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Mt(t, e)) return;
    i.uniform4uiv(this.addr, e), St(t, e);
  }
}
function Ig(i, e, t) {
  const n = this.cache, s = t.allocateTextureUnit();
  n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s);
  let r;
  this.type === i.SAMPLER_2D_SHADOW ? (Sc.compareFunction = 515, r = Sc) : r = Kh, t.setTexture2D(e || r, s);
}
function Mg(i, e, t) {
  const n = this.cache, s = t.allocateTextureUnit();
  n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTexture3D(e || jh, s);
}
function Sg(i, e, t) {
  const n = this.cache, s = t.allocateTextureUnit();
  n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTextureCube(e || Jh, s);
}
function Bg(i, e, t) {
  const n = this.cache, s = t.allocateTextureUnit();
  n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), t.setTexture2DArray(e || Xh, s);
}
function Tg(i) {
  switch (i) {
    case 5126:
      return hg;
    // FLOAT
    case 35664:
      return ug;
    // _VEC2
    case 35665:
      return dg;
    // _VEC3
    case 35666:
      return pg;
    // _VEC4
    case 35674:
      return Ag;
    // _MAT2
    case 35675:
      return fg;
    // _MAT3
    case 35676:
      return mg;
    // _MAT4
    case 5124:
    case 35670:
      return gg;
    // INT, BOOL
    case 35667:
    case 35671:
      return bg;
    // _VEC2
    case 35668:
    case 35672:
      return vg;
    // _VEC3
    case 35669:
    case 35673:
      return Eg;
    // _VEC4
    case 5125:
      return Cg;
    // UINT
    case 36294:
      return xg;
    // _VEC2
    case 36295:
      return wg;
    // _VEC3
    case 36296:
      return yg;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return Ig;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return Mg;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return Sg;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return Bg;
  }
}
function Rg(i, e) {
  i.uniform1fv(this.addr, e);
}
function Dg(i, e) {
  const t = Cs(e, this.size, 2);
  i.uniform2fv(this.addr, t);
}
function Pg(i, e) {
  const t = Cs(e, this.size, 3);
  i.uniform3fv(this.addr, t);
}
function Lg(i, e) {
  const t = Cs(e, this.size, 4);
  i.uniform4fv(this.addr, t);
}
function Fg(i, e) {
  const t = Cs(e, this.size, 4);
  i.uniformMatrix2fv(this.addr, !1, t);
}
function Ng(i, e) {
  const t = Cs(e, this.size, 9);
  i.uniformMatrix3fv(this.addr, !1, t);
}
function Ug(i, e) {
  const t = Cs(e, this.size, 16);
  i.uniformMatrix4fv(this.addr, !1, t);
}
function Qg(i, e) {
  i.uniform1iv(this.addr, e);
}
function kg(i, e) {
  i.uniform2iv(this.addr, e);
}
function _g(i, e) {
  i.uniform3iv(this.addr, e);
}
function Og(i, e) {
  i.uniform4iv(this.addr, e);
}
function Gg(i, e) {
  i.uniform1uiv(this.addr, e);
}
function Hg(i, e) {
  i.uniform2uiv(this.addr, e);
}
function Vg(i, e) {
  i.uniform3uiv(this.addr, e);
}
function zg(i, e) {
  i.uniform4uiv(this.addr, e);
}
function qg(i, e, t) {
  const n = this.cache, s = e.length, r = la(t, s);
  Mt(n, r) || (i.uniform1iv(this.addr, r), St(n, r));
  for (let a = 0; a !== s; ++a)
    t.setTexture2D(e[a] || Kh, r[a]);
}
function Wg(i, e, t) {
  const n = this.cache, s = e.length, r = la(t, s);
  Mt(n, r) || (i.uniform1iv(this.addr, r), St(n, r));
  for (let a = 0; a !== s; ++a)
    t.setTexture3D(e[a] || jh, r[a]);
}
function Yg(i, e, t) {
  const n = this.cache, s = e.length, r = la(t, s);
  Mt(n, r) || (i.uniform1iv(this.addr, r), St(n, r));
  for (let a = 0; a !== s; ++a)
    t.setTextureCube(e[a] || Jh, r[a]);
}
function Kg(i, e, t) {
  const n = this.cache, s = e.length, r = la(t, s);
  Mt(n, r) || (i.uniform1iv(this.addr, r), St(n, r));
  for (let a = 0; a !== s; ++a)
    t.setTexture2DArray(e[a] || Xh, r[a]);
}
function Xg(i) {
  switch (i) {
    case 5126:
      return Rg;
    // FLOAT
    case 35664:
      return Dg;
    // _VEC2
    case 35665:
      return Pg;
    // _VEC3
    case 35666:
      return Lg;
    // _VEC4
    case 35674:
      return Fg;
    // _MAT2
    case 35675:
      return Ng;
    // _MAT3
    case 35676:
      return Ug;
    // _MAT4
    case 5124:
    case 35670:
      return Qg;
    // INT, BOOL
    case 35667:
    case 35671:
      return kg;
    // _VEC2
    case 35668:
    case 35672:
      return _g;
    // _VEC3
    case 35669:
    case 35673:
      return Og;
    // _VEC4
    case 5125:
      return Gg;
    // UINT
    case 36294:
      return Hg;
    // _VEC2
    case 36295:
      return Vg;
    // _VEC3
    case 36296:
      return zg;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return qg;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return Wg;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return Yg;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return Kg;
  }
}
class jg {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = Tg(t.type);
  }
}
class Jg {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = Xg(t.type);
  }
}
class Zg {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const s = this.seq;
    for (let r = 0, a = s.length; r !== a; ++r) {
      const o = s[r];
      o.setValue(e, t[o.id], n);
    }
  }
}
const Ya = /(\w+)(\])?(\[|\.)?/g;
function Lc(i, e) {
  i.seq.push(e), i.map[e.id] = e;
}
function $g(i, e, t) {
  const n = i.name, s = n.length;
  for (Ya.lastIndex = 0; ; ) {
    const r = Ya.exec(n), a = Ya.lastIndex;
    let o = r[1];
    const l = r[2] === "]", c = r[3];
    if (l && (o = o | 0), c === void 0 || c === "[" && a + 2 === s) {
      Lc(t, c === void 0 ? new jg(o, i, e) : new Jg(o, i, e));
      break;
    } else {
      let u = t.map[o];
      u === void 0 && (u = new Zg(o), Lc(t, u)), t = u;
    }
  }
}
class qr {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let s = 0; s < n; ++s) {
      const r = e.getActiveUniform(t, s), a = e.getUniformLocation(t, r.name);
      $g(r, a, this);
    }
  }
  setValue(e, t, n, s) {
    const r = this.map[t];
    r !== void 0 && r.setValue(e, n, s);
  }
  setOptional(e, t, n) {
    const s = t[n];
    s !== void 0 && this.setValue(e, n, s);
  }
  static upload(e, t, n, s) {
    for (let r = 0, a = t.length; r !== a; ++r) {
      const o = t[r], l = n[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, s);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let s = 0, r = e.length; s !== r; ++s) {
      const a = e[s];
      a.id in t && n.push(a);
    }
    return n;
  }
}
function Fc(i, e, t) {
  const n = i.createShader(e);
  return i.shaderSource(n, t), i.compileShader(n), n;
}
const eb = 37297;
let tb = 0;
function nb(i, e) {
  const t = i.split(`
`), n = [], s = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
  for (let a = s; a < r; a++) {
    const o = a + 1;
    n.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
  }
  return n.join(`
`);
}
const Nc = /* @__PURE__ */ new Fe();
function ib(i) {
  We._getMatrix(Nc, We.workingColorSpace, i);
  const e = `mat3( ${Nc.elements.map((t) => t.toFixed(4))} )`;
  switch (We.getTransfer(i)) {
    case Kr:
      return [e, "LinearTransferOETF"];
    case at:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", i), [e, "LinearTransferOETF"];
  }
}
function Uc(i, e, t) {
  const n = i.getShaderParameter(e, i.COMPILE_STATUS), s = i.getShaderInfoLog(e).trim();
  if (n && s === "") return "";
  const r = /ERROR: 0:(\d+)/.exec(s);
  if (r) {
    const a = parseInt(r[1]);
    return t.toUpperCase() + `

` + s + `

` + nb(i.getShaderSource(e), a);
  } else
    return s;
}
function sb(i, e) {
  const t = ib(e);
  return [
    `vec4 ${i}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function rb(i, e) {
  let t;
  switch (e) {
    case 1:
      t = "Linear";
      break;
    case 2:
      t = "Reinhard";
      break;
    case 3:
      t = "Cineon";
      break;
    case 4:
      t = "ACESFilmic";
      break;
    case 6:
      t = "AgX";
      break;
    case 7:
      t = "Neutral";
      break;
    case 5:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
const Or = /* @__PURE__ */ new T();
function ab() {
  We.getLuminanceCoefficients(Or);
  const i = Or.x.toFixed(4), e = Or.y.toFixed(4), t = Or.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${i}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function ob(i) {
  return [
    i.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(Gs).join(`
`);
}
function lb(i) {
  const e = [];
  for (const t in i) {
    const n = i[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function cb(i, e) {
  const t = {}, n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
  for (let s = 0; s < n; s++) {
    const r = i.getActiveAttrib(e, s), a = r.name;
    let o = 1;
    r.type === i.FLOAT_MAT2 && (o = 2), r.type === i.FLOAT_MAT3 && (o = 3), r.type === i.FLOAT_MAT4 && (o = 4), t[a] = {
      type: r.type,
      location: i.getAttribLocation(e, a),
      locationSize: o
    };
  }
  return t;
}
function Gs(i) {
  return i !== "";
}
function Qc(i, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function kc(i, e) {
  return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const hb = /^[ \t]*#include +<([\w\d./]+)>/gm;
function bo(i) {
  return i.replace(hb, db);
}
const ub = /* @__PURE__ */ new Map();
function db(i, e) {
  let t = Ue[e];
  if (t === void 0) {
    const n = ub.get(e);
    if (n !== void 0)
      t = Ue[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return bo(t);
}
const pb = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function _c(i) {
  return i.replace(pb, Ab);
}
function Ab(i, e, t, n) {
  let s = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    s += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
  return s;
}
function Oc(i) {
  let e = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
  return i.precision === "highp" ? e += `
#define HIGH_PRECISION` : i.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function fb(i) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return i.shadowMapType === 1 ? e = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === 2 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === 3 && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function mb(i) {
  let e = "ENVMAP_TYPE_CUBE";
  if (i.envMap)
    switch (i.envMapMode) {
      case 301:
      case 302:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case 306:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function gb(i) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (i.envMap)
    switch (i.envMapMode) {
      case 302:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function bb(i) {
  let e = "ENVMAP_BLENDING_NONE";
  if (i.envMap)
    switch (i.combine) {
      case 0:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case 1:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case 2:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function vb(i) {
  const e = i.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
}
function Eb(i, e, t, n) {
  const s = i.getContext(), r = t.defines;
  let a = t.vertexShader, o = t.fragmentShader;
  const l = fb(t), c = mb(t), h = gb(t), u = bb(t), d = vb(t), A = ob(t), m = lb(r), g = s.createProgram();
  let f, p, v = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (f = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m
  ].filter(Gs).join(`
`), f.length > 0 && (f += `
`), p = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m
  ].filter(Gs).join(`
`), p.length > 0 && (p += `
`)) : (f = [
    Oc(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m,
    t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    t.batching ? "#define USE_BATCHING" : "",
    t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + h : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Gs).join(`
`), p = [
    Oc(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + c : "",
    t.envMap ? "#define " + h : "",
    t.envMap ? "#define " + u : "",
    d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
    d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
    d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.dispersion ? "#define USE_DISPERSION" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== 0 ? "#define TONE_MAPPING" : "",
    t.toneMapping !== 0 ? Ue.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== 0 ? rb("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    Ue.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    sb("linearToOutputTexel", t.outputColorSpace),
    ab(),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(Gs).join(`
`)), a = bo(a), a = Qc(a, t), a = kc(a, t), o = bo(o), o = Qc(o, t), o = kc(o, t), a = _c(a), o = _c(o), t.isRawShaderMaterial !== !0 && (v = `#version 300 es
`, f = [
    A,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + f, p = [
    "#define varying in",
    t.glslVersion === Ll ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === Ll ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + p);
  const E = v + f + a, b = v + p + o, S = Fc(s, s.VERTEX_SHADER, E), I = Fc(s, s.FRAGMENT_SHADER, b);
  s.attachShader(g, S), s.attachShader(g, I), t.index0AttributeName !== void 0 ? s.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && s.bindAttribLocation(g, 0, "position"), s.linkProgram(g);
  function B(D) {
    if (i.debug.checkShaderErrors) {
      const _ = s.getProgramInfoLog(g).trim(), Q = s.getShaderInfoLog(S).trim(), H = s.getShaderInfoLog(I).trim();
      let j = !0, V = !0;
      if (s.getProgramParameter(g, s.LINK_STATUS) === !1)
        if (j = !1, typeof i.debug.onShaderError == "function")
          i.debug.onShaderError(s, g, S, I);
        else {
          const J = Uc(s, S, "vertex"), G = Uc(s, I, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(g, s.VALIDATE_STATUS) + `

Material Name: ` + D.name + `
Material Type: ` + D.type + `

Program Info Log: ` + _ + `
` + J + `
` + G
          );
        }
      else _ !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", _) : (Q === "" || H === "") && (V = !1);
      V && (D.diagnostics = {
        runnable: j,
        programLog: _,
        vertexShader: {
          log: Q,
          prefix: f
        },
        fragmentShader: {
          log: H,
          prefix: p
        }
      });
    }
    s.deleteShader(S), s.deleteShader(I), R = new qr(s, g), w = cb(s, g);
  }
  let R;
  this.getUniforms = function() {
    return R === void 0 && B(this), R;
  };
  let w;
  this.getAttributes = function() {
    return w === void 0 && B(this), w;
  };
  let C = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return C === !1 && (C = s.getProgramParameter(g, eb)), C;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), s.deleteProgram(g), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = tb++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = S, this.fragmentShader = I, this;
}
let Cb = 0;
class xb {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, s = this._getShaderStage(t), r = this._getShaderStage(n), a = this._getShaderCacheForMaterial(e);
    return a.has(s) === !1 && (a.add(s), s.usedTimes++), a.has(r) === !1 && (a.add(r), r.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new wb(e), t.set(e, n)), n;
  }
}
class wb {
  constructor(e) {
    this.id = Cb++, this.code = e, this.usedTimes = 0;
  }
}
function yb(i, e, t, n, s, r, a) {
  const o = new Fh(), l = new xb(), c = /* @__PURE__ */ new Set(), h = [], u = s.logarithmicDepthBuffer, d = s.vertexTextures;
  let A = s.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function g(w) {
    return c.add(w), w === 0 ? "uv" : `uv${w}`;
  }
  function f(w, C, D, _, Q) {
    const H = _.fog, j = Q.geometry, V = w.isMeshStandardMaterial ? _.environment : null, J = (w.isMeshStandardMaterial ? t : e).get(w.envMap || V), G = J && J.mapping === 306 ? J.image.height : null, te = m[w.type];
    w.precision !== null && (A = s.getMaxPrecision(w.precision), A !== w.precision && console.warn("THREE.WebGLProgram.getParameters:", w.precision, "not supported, using", A, "instead."));
    const le = j.morphAttributes.position || j.morphAttributes.normal || j.morphAttributes.color, me = le !== void 0 ? le.length : 0;
    let Re = 0;
    j.morphAttributes.position !== void 0 && (Re = 1), j.morphAttributes.normal !== void 0 && (Re = 2), j.morphAttributes.color !== void 0 && (Re = 3);
    let Ge, q, ne, ge;
    if (te) {
      const it = Cn[te];
      Ge = it.vertexShader, q = it.fragmentShader;
    } else
      Ge = w.vertexShader, q = w.fragmentShader, l.update(w), ne = l.getVertexShaderID(w), ge = l.getFragmentShaderID(w);
    const ae = i.getRenderTarget(), Me = i.state.buffers.depth.getReversed(), Ze = Q.isInstancedMesh === !0, Se = Q.isBatchedMesh === !0, vt = !!w.map, pt = !!w.matcap, He = !!J, P = !!w.aoMap, tn = !!w.lightMap, Ve = !!w.bumpMap, ze = !!w.normalMap, Ee = !!w.displacementMap, ht = !!w.emissiveMap, ve = !!w.metalnessMap, M = !!w.roughnessMap, x = w.anisotropy > 0, U = w.clearcoat > 0, K = w.dispersion > 0, Z = w.iridescence > 0, W = w.sheen > 0, be = w.transmission > 0, oe = x && !!w.anisotropyMap, de = U && !!w.clearcoatMap, Ye = U && !!w.clearcoatNormalMap, ee = U && !!w.clearcoatRoughnessMap, pe = Z && !!w.iridescenceMap, ye = Z && !!w.iridescenceThicknessMap, Be = W && !!w.sheenColorMap, Ae = W && !!w.sheenRoughnessMap, qe = !!w.specularMap, Ne = !!w.specularColorMap, lt = !!w.specularIntensityMap, L = be && !!w.transmissionMap, se = be && !!w.thicknessMap, z = !!w.gradientMap, X = !!w.alphaMap, he = w.alphaTest > 0, ce = !!w.alphaHash, Le = !!w.extensions;
    let mt = 0;
    w.toneMapped && (ae === null || ae.isXRRenderTarget === !0) && (mt = i.toneMapping);
    const Lt = {
      shaderID: te,
      shaderType: w.type,
      shaderName: w.name,
      vertexShader: Ge,
      fragmentShader: q,
      defines: w.defines,
      customVertexShaderID: ne,
      customFragmentShaderID: ge,
      isRawShaderMaterial: w.isRawShaderMaterial === !0,
      glslVersion: w.glslVersion,
      precision: A,
      batching: Se,
      batchingColor: Se && Q._colorsTexture !== null,
      instancing: Ze,
      instancingColor: Ze && Q.instanceColor !== null,
      instancingMorph: Ze && Q.morphTexture !== null,
      supportsVertexTextures: d,
      outputColorSpace: ae === null ? i.outputColorSpace : ae.isXRRenderTarget === !0 ? ae.texture.colorSpace : Ut,
      alphaToCoverage: !!w.alphaToCoverage,
      map: vt,
      matcap: pt,
      envMap: He,
      envMapMode: He && J.mapping,
      envMapCubeUVHeight: G,
      aoMap: P,
      lightMap: tn,
      bumpMap: Ve,
      normalMap: ze,
      displacementMap: d && Ee,
      emissiveMap: ht,
      normalMapObjectSpace: ze && w.normalMapType === 1,
      normalMapTangentSpace: ze && w.normalMapType === 0,
      metalnessMap: ve,
      roughnessMap: M,
      anisotropy: x,
      anisotropyMap: oe,
      clearcoat: U,
      clearcoatMap: de,
      clearcoatNormalMap: Ye,
      clearcoatRoughnessMap: ee,
      dispersion: K,
      iridescence: Z,
      iridescenceMap: pe,
      iridescenceThicknessMap: ye,
      sheen: W,
      sheenColorMap: Be,
      sheenRoughnessMap: Ae,
      specularMap: qe,
      specularColorMap: Ne,
      specularIntensityMap: lt,
      transmission: be,
      transmissionMap: L,
      thicknessMap: se,
      gradientMap: z,
      opaque: w.transparent === !1 && w.blending === 1 && w.alphaToCoverage === !1,
      alphaMap: X,
      alphaTest: he,
      alphaHash: ce,
      combine: w.combine,
      //
      mapUv: vt && g(w.map.channel),
      aoMapUv: P && g(w.aoMap.channel),
      lightMapUv: tn && g(w.lightMap.channel),
      bumpMapUv: Ve && g(w.bumpMap.channel),
      normalMapUv: ze && g(w.normalMap.channel),
      displacementMapUv: Ee && g(w.displacementMap.channel),
      emissiveMapUv: ht && g(w.emissiveMap.channel),
      metalnessMapUv: ve && g(w.metalnessMap.channel),
      roughnessMapUv: M && g(w.roughnessMap.channel),
      anisotropyMapUv: oe && g(w.anisotropyMap.channel),
      clearcoatMapUv: de && g(w.clearcoatMap.channel),
      clearcoatNormalMapUv: Ye && g(w.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: ee && g(w.clearcoatRoughnessMap.channel),
      iridescenceMapUv: pe && g(w.iridescenceMap.channel),
      iridescenceThicknessMapUv: ye && g(w.iridescenceThicknessMap.channel),
      sheenColorMapUv: Be && g(w.sheenColorMap.channel),
      sheenRoughnessMapUv: Ae && g(w.sheenRoughnessMap.channel),
      specularMapUv: qe && g(w.specularMap.channel),
      specularColorMapUv: Ne && g(w.specularColorMap.channel),
      specularIntensityMapUv: lt && g(w.specularIntensityMap.channel),
      transmissionMapUv: L && g(w.transmissionMap.channel),
      thicknessMapUv: se && g(w.thicknessMap.channel),
      alphaMapUv: X && g(w.alphaMap.channel),
      //
      vertexTangents: !!j.attributes.tangent && (ze || x),
      vertexColors: w.vertexColors,
      vertexAlphas: w.vertexColors === !0 && !!j.attributes.color && j.attributes.color.itemSize === 4,
      pointsUvs: Q.isPoints === !0 && !!j.attributes.uv && (vt || X),
      fog: !!H,
      useFog: w.fog === !0,
      fogExp2: !!H && H.isFogExp2,
      flatShading: w.flatShading === !0,
      sizeAttenuation: w.sizeAttenuation === !0,
      logarithmicDepthBuffer: u,
      reverseDepthBuffer: Me,
      skinning: Q.isSkinnedMesh === !0,
      morphTargets: j.morphAttributes.position !== void 0,
      morphNormals: j.morphAttributes.normal !== void 0,
      morphColors: j.morphAttributes.color !== void 0,
      morphTargetsCount: me,
      morphTextureStride: Re,
      numDirLights: C.directional.length,
      numPointLights: C.point.length,
      numSpotLights: C.spot.length,
      numSpotLightMaps: C.spotLightMap.length,
      numRectAreaLights: C.rectArea.length,
      numHemiLights: C.hemi.length,
      numDirLightShadows: C.directionalShadowMap.length,
      numPointLightShadows: C.pointShadowMap.length,
      numSpotLightShadows: C.spotShadowMap.length,
      numSpotLightShadowsWithMaps: C.numSpotLightShadowsWithMaps,
      numLightProbes: C.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: w.dithering,
      shadowMapEnabled: i.shadowMap.enabled && D.length > 0,
      shadowMapType: i.shadowMap.type,
      toneMapping: mt,
      decodeVideoTexture: vt && w.map.isVideoTexture === !0 && We.getTransfer(w.map.colorSpace) === at,
      decodeVideoTextureEmissive: ht && w.emissiveMap.isVideoTexture === !0 && We.getTransfer(w.emissiveMap.colorSpace) === at,
      premultipliedAlpha: w.premultipliedAlpha,
      doubleSided: w.side === 2,
      flipSided: w.side === 1,
      useDepthPacking: w.depthPacking >= 0,
      depthPacking: w.depthPacking || 0,
      index0AttributeName: w.index0AttributeName,
      extensionClipCullDistance: Le && w.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (Le && w.extensions.multiDraw === !0 || Se) && n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: w.customProgramCacheKey()
    };
    return Lt.vertexUv1s = c.has(1), Lt.vertexUv2s = c.has(2), Lt.vertexUv3s = c.has(3), c.clear(), Lt;
  }
  function p(w) {
    const C = [];
    if (w.shaderID ? C.push(w.shaderID) : (C.push(w.customVertexShaderID), C.push(w.customFragmentShaderID)), w.defines !== void 0)
      for (const D in w.defines)
        C.push(D), C.push(w.defines[D]);
    return w.isRawShaderMaterial === !1 && (v(C, w), E(C, w), C.push(i.outputColorSpace)), C.push(w.customProgramCacheKey), C.join();
  }
  function v(w, C) {
    w.push(C.precision), w.push(C.outputColorSpace), w.push(C.envMapMode), w.push(C.envMapCubeUVHeight), w.push(C.mapUv), w.push(C.alphaMapUv), w.push(C.lightMapUv), w.push(C.aoMapUv), w.push(C.bumpMapUv), w.push(C.normalMapUv), w.push(C.displacementMapUv), w.push(C.emissiveMapUv), w.push(C.metalnessMapUv), w.push(C.roughnessMapUv), w.push(C.anisotropyMapUv), w.push(C.clearcoatMapUv), w.push(C.clearcoatNormalMapUv), w.push(C.clearcoatRoughnessMapUv), w.push(C.iridescenceMapUv), w.push(C.iridescenceThicknessMapUv), w.push(C.sheenColorMapUv), w.push(C.sheenRoughnessMapUv), w.push(C.specularMapUv), w.push(C.specularColorMapUv), w.push(C.specularIntensityMapUv), w.push(C.transmissionMapUv), w.push(C.thicknessMapUv), w.push(C.combine), w.push(C.fogExp2), w.push(C.sizeAttenuation), w.push(C.morphTargetsCount), w.push(C.morphAttributeCount), w.push(C.numDirLights), w.push(C.numPointLights), w.push(C.numSpotLights), w.push(C.numSpotLightMaps), w.push(C.numHemiLights), w.push(C.numRectAreaLights), w.push(C.numDirLightShadows), w.push(C.numPointLightShadows), w.push(C.numSpotLightShadows), w.push(C.numSpotLightShadowsWithMaps), w.push(C.numLightProbes), w.push(C.shadowMapType), w.push(C.toneMapping), w.push(C.numClippingPlanes), w.push(C.numClipIntersection), w.push(C.depthPacking);
  }
  function E(w, C) {
    o.disableAll(), C.supportsVertexTextures && o.enable(0), C.instancing && o.enable(1), C.instancingColor && o.enable(2), C.instancingMorph && o.enable(3), C.matcap && o.enable(4), C.envMap && o.enable(5), C.normalMapObjectSpace && o.enable(6), C.normalMapTangentSpace && o.enable(7), C.clearcoat && o.enable(8), C.iridescence && o.enable(9), C.alphaTest && o.enable(10), C.vertexColors && o.enable(11), C.vertexAlphas && o.enable(12), C.vertexUv1s && o.enable(13), C.vertexUv2s && o.enable(14), C.vertexUv3s && o.enable(15), C.vertexTangents && o.enable(16), C.anisotropy && o.enable(17), C.alphaHash && o.enable(18), C.batching && o.enable(19), C.dispersion && o.enable(20), C.batchingColor && o.enable(21), w.push(o.mask), o.disableAll(), C.fog && o.enable(0), C.useFog && o.enable(1), C.flatShading && o.enable(2), C.logarithmicDepthBuffer && o.enable(3), C.reverseDepthBuffer && o.enable(4), C.skinning && o.enable(5), C.morphTargets && o.enable(6), C.morphNormals && o.enable(7), C.morphColors && o.enable(8), C.premultipliedAlpha && o.enable(9), C.shadowMapEnabled && o.enable(10), C.doubleSided && o.enable(11), C.flipSided && o.enable(12), C.useDepthPacking && o.enable(13), C.dithering && o.enable(14), C.transmission && o.enable(15), C.sheen && o.enable(16), C.opaque && o.enable(17), C.pointsUvs && o.enable(18), C.decodeVideoTexture && o.enable(19), C.decodeVideoTextureEmissive && o.enable(20), C.alphaToCoverage && o.enable(21), w.push(o.mask);
  }
  function b(w) {
    const C = m[w.type];
    let D;
    if (C) {
      const _ = Cn[C];
      D = Ap.clone(_.uniforms);
    } else
      D = w.uniforms;
    return D;
  }
  function S(w, C) {
    let D;
    for (let _ = 0, Q = h.length; _ < Q; _++) {
      const H = h[_];
      if (H.cacheKey === C) {
        D = H, ++D.usedTimes;
        break;
      }
    }
    return D === void 0 && (D = new Eb(i, C, w, r), h.push(D)), D;
  }
  function I(w) {
    if (--w.usedTimes === 0) {
      const C = h.indexOf(w);
      h[C] = h[h.length - 1], h.pop(), w.destroy();
    }
  }
  function B(w) {
    l.remove(w);
  }
  function R() {
    l.dispose();
  }
  return {
    getParameters: f,
    getProgramCacheKey: p,
    getUniforms: b,
    acquireProgram: S,
    releaseProgram: I,
    releaseShaderCache: B,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: h,
    dispose: R
  };
}
function Ib() {
  let i = /* @__PURE__ */ new WeakMap();
  function e(a) {
    return i.has(a);
  }
  function t(a) {
    let o = i.get(a);
    return o === void 0 && (o = {}, i.set(a, o)), o;
  }
  function n(a) {
    i.delete(a);
  }
  function s(a, o, l) {
    i.get(a)[o] = l;
  }
  function r() {
    i = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: t,
    remove: n,
    update: s,
    dispose: r
  };
}
function Mb(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id;
}
function Gc(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id;
}
function Hc() {
  const i = [];
  let e = 0;
  const t = [], n = [], s = [];
  function r() {
    e = 0, t.length = 0, n.length = 0, s.length = 0;
  }
  function a(u, d, A, m, g, f) {
    let p = i[e];
    return p === void 0 ? (p = {
      id: u.id,
      object: u,
      geometry: d,
      material: A,
      groupOrder: m,
      renderOrder: u.renderOrder,
      z: g,
      group: f
    }, i[e] = p) : (p.id = u.id, p.object = u, p.geometry = d, p.material = A, p.groupOrder = m, p.renderOrder = u.renderOrder, p.z = g, p.group = f), e++, p;
  }
  function o(u, d, A, m, g, f) {
    const p = a(u, d, A, m, g, f);
    A.transmission > 0 ? n.push(p) : A.transparent === !0 ? s.push(p) : t.push(p);
  }
  function l(u, d, A, m, g, f) {
    const p = a(u, d, A, m, g, f);
    A.transmission > 0 ? n.unshift(p) : A.transparent === !0 ? s.unshift(p) : t.unshift(p);
  }
  function c(u, d) {
    t.length > 1 && t.sort(u || Mb), n.length > 1 && n.sort(d || Gc), s.length > 1 && s.sort(d || Gc);
  }
  function h() {
    for (let u = e, d = i.length; u < d; u++) {
      const A = i[u];
      if (A.id === null) break;
      A.id = null, A.object = null, A.geometry = null, A.material = null, A.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: s,
    init: r,
    push: o,
    unshift: l,
    finish: h,
    sort: c
  };
}
function Sb() {
  let i = /* @__PURE__ */ new WeakMap();
  function e(n, s) {
    const r = i.get(n);
    let a;
    return r === void 0 ? (a = new Hc(), i.set(n, [a])) : s >= r.length ? (a = new Hc(), r.push(a)) : a = r[s], a;
  }
  function t() {
    i = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function Bb() {
  const i = {};
  return {
    get: function(e) {
      if (i[e.id] !== void 0)
        return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new T(),
            color: new we()
          };
          break;
        case "SpotLight":
          t = {
            position: new T(),
            direction: new T(),
            color: new we(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new T(),
            color: new we(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new T(),
            skyColor: new we(),
            groundColor: new we()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new we(),
            position: new T(),
            halfWidth: new T(),
            halfHeight: new T()
          };
          break;
      }
      return i[e.id] = t, t;
    }
  };
}
function Tb() {
  const i = {};
  return {
    get: function(e) {
      if (i[e.id] !== void 0)
        return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ie()
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ie()
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ie(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return i[e.id] = t, t;
    }
  };
}
let Rb = 0;
function Db(i, e) {
  return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0);
}
function Pb(i) {
  const e = new Bb(), t = Tb(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let c = 0; c < 9; c++) n.probe.push(new T());
  const s = new T(), r = new Pe(), a = new Pe();
  function o(c) {
    let h = 0, u = 0, d = 0;
    for (let w = 0; w < 9; w++) n.probe[w].set(0, 0, 0);
    let A = 0, m = 0, g = 0, f = 0, p = 0, v = 0, E = 0, b = 0, S = 0, I = 0, B = 0;
    c.sort(Db);
    for (let w = 0, C = c.length; w < C; w++) {
      const D = c[w], _ = D.color, Q = D.intensity, H = D.distance, j = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
      if (D.isAmbientLight)
        h += _.r * Q, u += _.g * Q, d += _.b * Q;
      else if (D.isLightProbe) {
        for (let V = 0; V < 9; V++)
          n.probe[V].addScaledVector(D.sh.coefficients[V], Q);
        B++;
      } else if (D.isDirectionalLight) {
        const V = e.get(D);
        if (V.color.copy(D.color).multiplyScalar(D.intensity), D.castShadow) {
          const J = D.shadow, G = t.get(D);
          G.shadowIntensity = J.intensity, G.shadowBias = J.bias, G.shadowNormalBias = J.normalBias, G.shadowRadius = J.radius, G.shadowMapSize = J.mapSize, n.directionalShadow[A] = G, n.directionalShadowMap[A] = j, n.directionalShadowMatrix[A] = D.shadow.matrix, v++;
        }
        n.directional[A] = V, A++;
      } else if (D.isSpotLight) {
        const V = e.get(D);
        V.position.setFromMatrixPosition(D.matrixWorld), V.color.copy(_).multiplyScalar(Q), V.distance = H, V.coneCos = Math.cos(D.angle), V.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), V.decay = D.decay, n.spot[g] = V;
        const J = D.shadow;
        if (D.map && (n.spotLightMap[S] = D.map, S++, J.updateMatrices(D), D.castShadow && I++), n.spotLightMatrix[g] = J.matrix, D.castShadow) {
          const G = t.get(D);
          G.shadowIntensity = J.intensity, G.shadowBias = J.bias, G.shadowNormalBias = J.normalBias, G.shadowRadius = J.radius, G.shadowMapSize = J.mapSize, n.spotShadow[g] = G, n.spotShadowMap[g] = j, b++;
        }
        g++;
      } else if (D.isRectAreaLight) {
        const V = e.get(D);
        V.color.copy(_).multiplyScalar(Q), V.halfWidth.set(D.width * 0.5, 0, 0), V.halfHeight.set(0, D.height * 0.5, 0), n.rectArea[f] = V, f++;
      } else if (D.isPointLight) {
        const V = e.get(D);
        if (V.color.copy(D.color).multiplyScalar(D.intensity), V.distance = D.distance, V.decay = D.decay, D.castShadow) {
          const J = D.shadow, G = t.get(D);
          G.shadowIntensity = J.intensity, G.shadowBias = J.bias, G.shadowNormalBias = J.normalBias, G.shadowRadius = J.radius, G.shadowMapSize = J.mapSize, G.shadowCameraNear = J.camera.near, G.shadowCameraFar = J.camera.far, n.pointShadow[m] = G, n.pointShadowMap[m] = j, n.pointShadowMatrix[m] = D.shadow.matrix, E++;
        }
        n.point[m] = V, m++;
      } else if (D.isHemisphereLight) {
        const V = e.get(D);
        V.skyColor.copy(D.color).multiplyScalar(Q), V.groundColor.copy(D.groundColor).multiplyScalar(Q), n.hemi[p] = V, p++;
      }
    }
    f > 0 && (i.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = ie.LTC_FLOAT_1, n.rectAreaLTC2 = ie.LTC_FLOAT_2) : (n.rectAreaLTC1 = ie.LTC_HALF_1, n.rectAreaLTC2 = ie.LTC_HALF_2)), n.ambient[0] = h, n.ambient[1] = u, n.ambient[2] = d;
    const R = n.hash;
    (R.directionalLength !== A || R.pointLength !== m || R.spotLength !== g || R.rectAreaLength !== f || R.hemiLength !== p || R.numDirectionalShadows !== v || R.numPointShadows !== E || R.numSpotShadows !== b || R.numSpotMaps !== S || R.numLightProbes !== B) && (n.directional.length = A, n.spot.length = g, n.rectArea.length = f, n.point.length = m, n.hemi.length = p, n.directionalShadow.length = v, n.directionalShadowMap.length = v, n.pointShadow.length = E, n.pointShadowMap.length = E, n.spotShadow.length = b, n.spotShadowMap.length = b, n.directionalShadowMatrix.length = v, n.pointShadowMatrix.length = E, n.spotLightMatrix.length = b + S - I, n.spotLightMap.length = S, n.numSpotLightShadowsWithMaps = I, n.numLightProbes = B, R.directionalLength = A, R.pointLength = m, R.spotLength = g, R.rectAreaLength = f, R.hemiLength = p, R.numDirectionalShadows = v, R.numPointShadows = E, R.numSpotShadows = b, R.numSpotMaps = S, R.numLightProbes = B, n.version = Rb++);
  }
  function l(c, h) {
    let u = 0, d = 0, A = 0, m = 0, g = 0;
    const f = h.matrixWorldInverse;
    for (let p = 0, v = c.length; p < v; p++) {
      const E = c[p];
      if (E.isDirectionalLight) {
        const b = n.directional[u];
        b.direction.setFromMatrixPosition(E.matrixWorld), s.setFromMatrixPosition(E.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(f), u++;
      } else if (E.isSpotLight) {
        const b = n.spot[A];
        b.position.setFromMatrixPosition(E.matrixWorld), b.position.applyMatrix4(f), b.direction.setFromMatrixPosition(E.matrixWorld), s.setFromMatrixPosition(E.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(f), A++;
      } else if (E.isRectAreaLight) {
        const b = n.rectArea[m];
        b.position.setFromMatrixPosition(E.matrixWorld), b.position.applyMatrix4(f), a.identity(), r.copy(E.matrixWorld), r.premultiply(f), a.extractRotation(r), b.halfWidth.set(E.width * 0.5, 0, 0), b.halfHeight.set(0, E.height * 0.5, 0), b.halfWidth.applyMatrix4(a), b.halfHeight.applyMatrix4(a), m++;
      } else if (E.isPointLight) {
        const b = n.point[d];
        b.position.setFromMatrixPosition(E.matrixWorld), b.position.applyMatrix4(f), d++;
      } else if (E.isHemisphereLight) {
        const b = n.hemi[g];
        b.direction.setFromMatrixPosition(E.matrixWorld), b.direction.transformDirection(f), g++;
      }
    }
  }
  return {
    setup: o,
    setupView: l,
    state: n
  };
}
function Vc(i) {
  const e = new Pb(i), t = [], n = [];
  function s(h) {
    c.camera = h, t.length = 0, n.length = 0;
  }
  function r(h) {
    t.push(h);
  }
  function a(h) {
    n.push(h);
  }
  function o() {
    e.setup(t);
  }
  function l(h) {
    e.setupView(t, h);
  }
  const c = {
    lightsArray: t,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: s,
    state: c,
    setupLights: o,
    setupLightsView: l,
    pushLight: r,
    pushShadow: a
  };
}
function Lb(i) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(s, r = 0) {
    const a = e.get(s);
    let o;
    return a === void 0 ? (o = new Vc(i), e.set(s, [o])) : r >= a.length ? (o = new Vc(i), a.push(o)) : o = a[r], o;
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: n
  };
}
const Fb = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, Nb = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Ub(i, e, t) {
  let n = new Fo();
  const s = new Ie(), r = new Ie(), a = new $e(), o = new Pp({ depthPacking: 3201 }), l = new Lp(), c = {}, h = t.maxTextureSize, u = { 0: 1, 1: 0, 2: 2 }, d = new Mn({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Ie() },
      radius: { value: 4 }
    },
    vertexShader: Fb,
    fragmentShader: Nb
  }), A = d.clone();
  A.defines.HORIZONTAL_PASS = 1;
  const m = new Bt();
  m.setAttribute(
    "position",
    new Ht(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const g = new ot(m, d), f = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1;
  let p = this.type;
  this.render = function(I, B, R) {
    if (f.enabled === !1 || f.autoUpdate === !1 && f.needsUpdate === !1 || I.length === 0) return;
    const w = i.getRenderTarget(), C = i.getActiveCubeFace(), D = i.getActiveMipmapLevel(), _ = i.state;
    _.setBlending(0), _.buffers.color.setClear(1, 1, 1, 1), _.buffers.depth.setTest(!0), _.setScissorTest(!1);
    const Q = p !== 3 && this.type === 3, H = p === 3 && this.type !== 3;
    for (let j = 0, V = I.length; j < V; j++) {
      const J = I[j], G = J.shadow;
      if (G === void 0) {
        console.warn("THREE.WebGLShadowMap:", J, "has no shadow.");
        continue;
      }
      if (G.autoUpdate === !1 && G.needsUpdate === !1) continue;
      s.copy(G.mapSize);
      const te = G.getFrameExtents();
      if (s.multiply(te), r.copy(G.mapSize), (s.x > h || s.y > h) && (s.x > h && (r.x = Math.floor(h / te.x), s.x = r.x * te.x, G.mapSize.x = r.x), s.y > h && (r.y = Math.floor(h / te.y), s.y = r.y * te.y, G.mapSize.y = r.y)), G.map === null || Q === !0 || H === !0) {
        const me = this.type !== 3 ? { minFilter: 1003, magFilter: 1003 } : {};
        G.map !== null && G.map.dispose(), G.map = new Kn(s.x, s.y, me), G.map.texture.name = J.name + ".shadowMap", G.camera.updateProjectionMatrix();
      }
      i.setRenderTarget(G.map), i.clear();
      const le = G.getViewportCount();
      for (let me = 0; me < le; me++) {
        const Re = G.getViewport(me);
        a.set(
          r.x * Re.x,
          r.y * Re.y,
          r.x * Re.z,
          r.y * Re.w
        ), _.viewport(a), G.updateMatrices(J, me), n = G.getFrustum(), b(B, R, G.camera, J, this.type);
      }
      G.isPointLightShadow !== !0 && this.type === 3 && v(G, R), G.needsUpdate = !1;
    }
    p = this.type, f.needsUpdate = !1, i.setRenderTarget(w, C, D);
  };
  function v(I, B) {
    const R = e.update(g);
    d.defines.VSM_SAMPLES !== I.blurSamples && (d.defines.VSM_SAMPLES = I.blurSamples, A.defines.VSM_SAMPLES = I.blurSamples, d.needsUpdate = !0, A.needsUpdate = !0), I.mapPass === null && (I.mapPass = new Kn(s.x, s.y)), d.uniforms.shadow_pass.value = I.map.texture, d.uniforms.resolution.value = I.mapSize, d.uniforms.radius.value = I.radius, i.setRenderTarget(I.mapPass), i.clear(), i.renderBufferDirect(B, null, R, d, g, null), A.uniforms.shadow_pass.value = I.mapPass.texture, A.uniforms.resolution.value = I.mapSize, A.uniforms.radius.value = I.radius, i.setRenderTarget(I.map), i.clear(), i.renderBufferDirect(B, null, R, A, g, null);
  }
  function E(I, B, R, w) {
    let C = null;
    const D = R.isPointLight === !0 ? I.customDistanceMaterial : I.customDepthMaterial;
    if (D !== void 0)
      C = D;
    else if (C = R.isPointLight === !0 ? l : o, i.localClippingEnabled && B.clipShadows === !0 && Array.isArray(B.clippingPlanes) && B.clippingPlanes.length !== 0 || B.displacementMap && B.displacementScale !== 0 || B.alphaMap && B.alphaTest > 0 || B.map && B.alphaTest > 0) {
      const _ = C.uuid, Q = B.uuid;
      let H = c[_];
      H === void 0 && (H = {}, c[_] = H);
      let j = H[Q];
      j === void 0 && (j = C.clone(), H[Q] = j, B.addEventListener("dispose", S)), C = j;
    }
    if (C.visible = B.visible, C.wireframe = B.wireframe, w === 3 ? C.side = B.shadowSide !== null ? B.shadowSide : B.side : C.side = B.shadowSide !== null ? B.shadowSide : u[B.side], C.alphaMap = B.alphaMap, C.alphaTest = B.alphaTest, C.map = B.map, C.clipShadows = B.clipShadows, C.clippingPlanes = B.clippingPlanes, C.clipIntersection = B.clipIntersection, C.displacementMap = B.displacementMap, C.displacementScale = B.displacementScale, C.displacementBias = B.displacementBias, C.wireframeLinewidth = B.wireframeLinewidth, C.linewidth = B.linewidth, R.isPointLight === !0 && C.isMeshDistanceMaterial === !0) {
      const _ = i.properties.get(C);
      _.light = R;
    }
    return C;
  }
  function b(I, B, R, w, C) {
    if (I.visible === !1) return;
    if (I.layers.test(B.layers) && (I.isMesh || I.isLine || I.isPoints) && (I.castShadow || I.receiveShadow && C === 3) && (!I.frustumCulled || n.intersectsObject(I))) {
      I.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, I.matrixWorld);
      const Q = e.update(I), H = I.material;
      if (Array.isArray(H)) {
        const j = Q.groups;
        for (let V = 0, J = j.length; V < J; V++) {
          const G = j[V], te = H[G.materialIndex];
          if (te && te.visible) {
            const le = E(I, te, w, C);
            I.onBeforeShadow(i, I, B, R, Q, le, G), i.renderBufferDirect(R, null, Q, le, I, G), I.onAfterShadow(i, I, B, R, Q, le, G);
          }
        }
      } else if (H.visible) {
        const j = E(I, H, w, C);
        I.onBeforeShadow(i, I, B, R, Q, j, null), i.renderBufferDirect(R, null, Q, j, I, null), I.onAfterShadow(i, I, B, R, Q, j, null);
      }
    }
    const _ = I.children;
    for (let Q = 0, H = _.length; Q < H; Q++)
      b(_[Q], B, R, w, C);
  }
  function S(I) {
    I.target.removeEventListener("dispose", S);
    for (const R in c) {
      const w = c[R], C = I.target.uuid;
      C in w && (w[C].dispose(), delete w[C]);
    }
  }
}
const Qb = {
  0: 1,
  2: 6,
  4: 7,
  3: 5,
  1: 0,
  6: 2,
  7: 4,
  5: 3
};
function kb(i, e) {
  function t() {
    let L = !1;
    const se = new $e();
    let z = null;
    const X = new $e(0, 0, 0, 0);
    return {
      setMask: function(he) {
        z !== he && !L && (i.colorMask(he, he, he, he), z = he);
      },
      setLocked: function(he) {
        L = he;
      },
      setClear: function(he, ce, Le, mt, Lt) {
        Lt === !0 && (he *= mt, ce *= mt, Le *= mt), se.set(he, ce, Le, mt), X.equals(se) === !1 && (i.clearColor(he, ce, Le, mt), X.copy(se));
      },
      reset: function() {
        L = !1, z = null, X.set(-1, 0, 0, 0);
      }
    };
  }
  function n() {
    let L = !1, se = !1, z = null, X = null, he = null;
    return {
      setReversed: function(ce) {
        if (se !== ce) {
          const Le = e.get("EXT_clip_control");
          se ? Le.clipControlEXT(Le.LOWER_LEFT_EXT, Le.ZERO_TO_ONE_EXT) : Le.clipControlEXT(Le.LOWER_LEFT_EXT, Le.NEGATIVE_ONE_TO_ONE_EXT);
          const mt = he;
          he = null, this.setClear(mt);
        }
        se = ce;
      },
      getReversed: function() {
        return se;
      },
      setTest: function(ce) {
        ce ? ae(i.DEPTH_TEST) : Me(i.DEPTH_TEST);
      },
      setMask: function(ce) {
        z !== ce && !L && (i.depthMask(ce), z = ce);
      },
      setFunc: function(ce) {
        if (se && (ce = Qb[ce]), X !== ce) {
          switch (ce) {
            case 0:
              i.depthFunc(i.NEVER);
              break;
            case 1:
              i.depthFunc(i.ALWAYS);
              break;
            case 2:
              i.depthFunc(i.LESS);
              break;
            case 3:
              i.depthFunc(i.LEQUAL);
              break;
            case 4:
              i.depthFunc(i.EQUAL);
              break;
            case 5:
              i.depthFunc(i.GEQUAL);
              break;
            case 6:
              i.depthFunc(i.GREATER);
              break;
            case 7:
              i.depthFunc(i.NOTEQUAL);
              break;
            default:
              i.depthFunc(i.LEQUAL);
          }
          X = ce;
        }
      },
      setLocked: function(ce) {
        L = ce;
      },
      setClear: function(ce) {
        he !== ce && (se && (ce = 1 - ce), i.clearDepth(ce), he = ce);
      },
      reset: function() {
        L = !1, z = null, X = null, he = null, se = !1;
      }
    };
  }
  function s() {
    let L = !1, se = null, z = null, X = null, he = null, ce = null, Le = null, mt = null, Lt = null;
    return {
      setTest: function(it) {
        L || (it ? ae(i.STENCIL_TEST) : Me(i.STENCIL_TEST));
      },
      setMask: function(it) {
        se !== it && !L && (i.stencilMask(it), se = it);
      },
      setFunc: function(it, pn, Pn) {
        (z !== it || X !== pn || he !== Pn) && (i.stencilFunc(it, pn, Pn), z = it, X = pn, he = Pn);
      },
      setOp: function(it, pn, Pn) {
        (ce !== it || Le !== pn || mt !== Pn) && (i.stencilOp(it, pn, Pn), ce = it, Le = pn, mt = Pn);
      },
      setLocked: function(it) {
        L = it;
      },
      setClear: function(it) {
        Lt !== it && (i.clearStencil(it), Lt = it);
      },
      reset: function() {
        L = !1, se = null, z = null, X = null, he = null, ce = null, Le = null, mt = null, Lt = null;
      }
    };
  }
  const r = new t(), a = new n(), o = new s(), l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
  let h = {}, u = {}, d = /* @__PURE__ */ new WeakMap(), A = [], m = null, g = !1, f = null, p = null, v = null, E = null, b = null, S = null, I = null, B = new we(0, 0, 0), R = 0, w = !1, C = null, D = null, _ = null, Q = null, H = null;
  const j = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let V = !1, J = 0;
  const G = i.getParameter(i.VERSION);
  G.indexOf("WebGL") !== -1 ? (J = parseFloat(/^WebGL (\d)/.exec(G)[1]), V = J >= 1) : G.indexOf("OpenGL ES") !== -1 && (J = parseFloat(/^OpenGL ES (\d)/.exec(G)[1]), V = J >= 2);
  let te = null, le = {};
  const me = i.getParameter(i.SCISSOR_BOX), Re = i.getParameter(i.VIEWPORT), Ge = new $e().fromArray(me), q = new $e().fromArray(Re);
  function ne(L, se, z, X) {
    const he = new Uint8Array(4), ce = i.createTexture();
    i.bindTexture(L, ce), i.texParameteri(L, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(L, i.TEXTURE_MAG_FILTER, i.NEAREST);
    for (let Le = 0; Le < z; Le++)
      L === i.TEXTURE_3D || L === i.TEXTURE_2D_ARRAY ? i.texImage3D(se, 0, i.RGBA, 1, 1, X, 0, i.RGBA, i.UNSIGNED_BYTE, he) : i.texImage2D(se + Le, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, he);
    return ce;
  }
  const ge = {};
  ge[i.TEXTURE_2D] = ne(i.TEXTURE_2D, i.TEXTURE_2D, 1), ge[i.TEXTURE_CUBE_MAP] = ne(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ge[i.TEXTURE_2D_ARRAY] = ne(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1), ge[i.TEXTURE_3D] = ne(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1), r.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), ae(i.DEPTH_TEST), a.setFunc(3), Ve(!1), ze(1), ae(i.CULL_FACE), P(0);
  function ae(L) {
    h[L] !== !0 && (i.enable(L), h[L] = !0);
  }
  function Me(L) {
    h[L] !== !1 && (i.disable(L), h[L] = !1);
  }
  function Ze(L, se) {
    return u[L] !== se ? (i.bindFramebuffer(L, se), u[L] = se, L === i.DRAW_FRAMEBUFFER && (u[i.FRAMEBUFFER] = se), L === i.FRAMEBUFFER && (u[i.DRAW_FRAMEBUFFER] = se), !0) : !1;
  }
  function Se(L, se) {
    let z = A, X = !1;
    if (L) {
      z = d.get(se), z === void 0 && (z = [], d.set(se, z));
      const he = L.textures;
      if (z.length !== he.length || z[0] !== i.COLOR_ATTACHMENT0) {
        for (let ce = 0, Le = he.length; ce < Le; ce++)
          z[ce] = i.COLOR_ATTACHMENT0 + ce;
        z.length = he.length, X = !0;
      }
    } else
      z[0] !== i.BACK && (z[0] = i.BACK, X = !0);
    X && i.drawBuffers(z);
  }
  function vt(L) {
    return m !== L ? (i.useProgram(L), m = L, !0) : !1;
  }
  const pt = {
    100: i.FUNC_ADD,
    101: i.FUNC_SUBTRACT,
    102: i.FUNC_REVERSE_SUBTRACT
  };
  pt[103] = i.MIN, pt[104] = i.MAX;
  const He = {
    200: i.ZERO,
    201: i.ONE,
    202: i.SRC_COLOR,
    204: i.SRC_ALPHA,
    210: i.SRC_ALPHA_SATURATE,
    208: i.DST_COLOR,
    206: i.DST_ALPHA,
    203: i.ONE_MINUS_SRC_COLOR,
    205: i.ONE_MINUS_SRC_ALPHA,
    209: i.ONE_MINUS_DST_COLOR,
    207: i.ONE_MINUS_DST_ALPHA,
    211: i.CONSTANT_COLOR,
    212: i.ONE_MINUS_CONSTANT_COLOR,
    213: i.CONSTANT_ALPHA,
    214: i.ONE_MINUS_CONSTANT_ALPHA
  };
  function P(L, se, z, X, he, ce, Le, mt, Lt, it) {
    if (L === 0) {
      g === !0 && (Me(i.BLEND), g = !1);
      return;
    }
    if (g === !1 && (ae(i.BLEND), g = !0), L !== 5) {
      if (L !== f || it !== w) {
        if ((p !== 100 || b !== 100) && (i.blendEquation(i.FUNC_ADD), p = 100, b = 100), it)
          switch (L) {
            case 1:
              i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
              break;
            case 2:
              i.blendFunc(i.ONE, i.ONE);
              break;
            case 3:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case 4:
              i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", L);
              break;
          }
        else
          switch (L) {
            case 1:
              i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
              break;
            case 2:
              i.blendFunc(i.SRC_ALPHA, i.ONE);
              break;
            case 3:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case 4:
              i.blendFunc(i.ZERO, i.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", L);
              break;
          }
        v = null, E = null, S = null, I = null, B.set(0, 0, 0), R = 0, f = L, w = it;
      }
      return;
    }
    he = he || se, ce = ce || z, Le = Le || X, (se !== p || he !== b) && (i.blendEquationSeparate(pt[se], pt[he]), p = se, b = he), (z !== v || X !== E || ce !== S || Le !== I) && (i.blendFuncSeparate(He[z], He[X], He[ce], He[Le]), v = z, E = X, S = ce, I = Le), (mt.equals(B) === !1 || Lt !== R) && (i.blendColor(mt.r, mt.g, mt.b, Lt), B.copy(mt), R = Lt), f = L, w = !1;
  }
  function tn(L, se) {
    L.side === 2 ? Me(i.CULL_FACE) : ae(i.CULL_FACE);
    let z = L.side === 1;
    se && (z = !z), Ve(z), L.blending === 1 && L.transparent === !1 ? P(0) : P(L.blending, L.blendEquation, L.blendSrc, L.blendDst, L.blendEquationAlpha, L.blendSrcAlpha, L.blendDstAlpha, L.blendColor, L.blendAlpha, L.premultipliedAlpha), a.setFunc(L.depthFunc), a.setTest(L.depthTest), a.setMask(L.depthWrite), r.setMask(L.colorWrite);
    const X = L.stencilWrite;
    o.setTest(X), X && (o.setMask(L.stencilWriteMask), o.setFunc(L.stencilFunc, L.stencilRef, L.stencilFuncMask), o.setOp(L.stencilFail, L.stencilZFail, L.stencilZPass)), ht(L.polygonOffset, L.polygonOffsetFactor, L.polygonOffsetUnits), L.alphaToCoverage === !0 ? ae(i.SAMPLE_ALPHA_TO_COVERAGE) : Me(i.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ve(L) {
    C !== L && (L ? i.frontFace(i.CW) : i.frontFace(i.CCW), C = L);
  }
  function ze(L) {
    L !== 0 ? (ae(i.CULL_FACE), L !== D && (L === 1 ? i.cullFace(i.BACK) : L === 2 ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : Me(i.CULL_FACE), D = L;
  }
  function Ee(L) {
    L !== _ && (V && i.lineWidth(L), _ = L);
  }
  function ht(L, se, z) {
    L ? (ae(i.POLYGON_OFFSET_FILL), (Q !== se || H !== z) && (i.polygonOffset(se, z), Q = se, H = z)) : Me(i.POLYGON_OFFSET_FILL);
  }
  function ve(L) {
    L ? ae(i.SCISSOR_TEST) : Me(i.SCISSOR_TEST);
  }
  function M(L) {
    L === void 0 && (L = i.TEXTURE0 + j - 1), te !== L && (i.activeTexture(L), te = L);
  }
  function x(L, se, z) {
    z === void 0 && (te === null ? z = i.TEXTURE0 + j - 1 : z = te);
    let X = le[z];
    X === void 0 && (X = { type: void 0, texture: void 0 }, le[z] = X), (X.type !== L || X.texture !== se) && (te !== z && (i.activeTexture(z), te = z), i.bindTexture(L, se || ge[L]), X.type = L, X.texture = se);
  }
  function U() {
    const L = le[te];
    L !== void 0 && L.type !== void 0 && (i.bindTexture(L.type, null), L.type = void 0, L.texture = void 0);
  }
  function K() {
    try {
      i.compressedTexImage2D.apply(i, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function Z() {
    try {
      i.compressedTexImage3D.apply(i, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function W() {
    try {
      i.texSubImage2D.apply(i, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function be() {
    try {
      i.texSubImage3D.apply(i, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function oe() {
    try {
      i.compressedTexSubImage2D.apply(i, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function de() {
    try {
      i.compressedTexSubImage3D.apply(i, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function Ye() {
    try {
      i.texStorage2D.apply(i, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function ee() {
    try {
      i.texStorage3D.apply(i, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function pe() {
    try {
      i.texImage2D.apply(i, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function ye() {
    try {
      i.texImage3D.apply(i, arguments);
    } catch (L) {
      console.error("THREE.WebGLState:", L);
    }
  }
  function Be(L) {
    Ge.equals(L) === !1 && (i.scissor(L.x, L.y, L.z, L.w), Ge.copy(L));
  }
  function Ae(L) {
    q.equals(L) === !1 && (i.viewport(L.x, L.y, L.z, L.w), q.copy(L));
  }
  function qe(L, se) {
    let z = c.get(se);
    z === void 0 && (z = /* @__PURE__ */ new WeakMap(), c.set(se, z));
    let X = z.get(L);
    X === void 0 && (X = i.getUniformBlockIndex(se, L.name), z.set(L, X));
  }
  function Ne(L, se) {
    const X = c.get(se).get(L);
    l.get(se) !== X && (i.uniformBlockBinding(se, X, L.__bindingPointIndex), l.set(se, X));
  }
  function lt() {
    i.disable(i.BLEND), i.disable(i.CULL_FACE), i.disable(i.DEPTH_TEST), i.disable(i.POLYGON_OFFSET_FILL), i.disable(i.SCISSOR_TEST), i.disable(i.STENCIL_TEST), i.disable(i.SAMPLE_ALPHA_TO_COVERAGE), i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ONE, i.ZERO), i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO), i.blendColor(0, 0, 0, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(i.LESS), a.setReversed(!1), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(i.ALWAYS, 0, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.KEEP), i.clearStencil(0), i.cullFace(i.BACK), i.frontFace(i.CCW), i.polygonOffset(0, 0), i.activeTexture(i.TEXTURE0), i.bindFramebuffer(i.FRAMEBUFFER, null), i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), i.bindFramebuffer(i.READ_FRAMEBUFFER, null), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), h = {}, te = null, le = {}, u = {}, d = /* @__PURE__ */ new WeakMap(), A = [], m = null, g = !1, f = null, p = null, v = null, E = null, b = null, S = null, I = null, B = new we(0, 0, 0), R = 0, w = !1, C = null, D = null, _ = null, Q = null, H = null, Ge.set(0, 0, i.canvas.width, i.canvas.height), q.set(0, 0, i.canvas.width, i.canvas.height), r.reset(), a.reset(), o.reset();
  }
  return {
    buffers: {
      color: r,
      depth: a,
      stencil: o
    },
    enable: ae,
    disable: Me,
    bindFramebuffer: Ze,
    drawBuffers: Se,
    useProgram: vt,
    setBlending: P,
    setMaterial: tn,
    setFlipSided: Ve,
    setCullFace: ze,
    setLineWidth: Ee,
    setPolygonOffset: ht,
    setScissorTest: ve,
    activeTexture: M,
    bindTexture: x,
    unbindTexture: U,
    compressedTexImage2D: K,
    compressedTexImage3D: Z,
    texImage2D: pe,
    texImage3D: ye,
    updateUBOMapping: qe,
    uniformBlockBinding: Ne,
    texStorage2D: Ye,
    texStorage3D: ee,
    texSubImage2D: W,
    texSubImage3D: be,
    compressedTexSubImage2D: oe,
    compressedTexSubImage3D: de,
    scissor: Be,
    viewport: Ae,
    reset: lt
  };
}
function _b(i, e, t, n, s, r, a) {
  const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), c = new Ie(), h = /* @__PURE__ */ new WeakMap();
  let u;
  const d = /* @__PURE__ */ new WeakMap();
  let A = !1;
  try {
    A = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function m(M, x) {
    return A ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(M, x)
    ) : Ys("canvas");
  }
  function g(M, x, U) {
    let K = 1;
    const Z = ve(M);
    if ((Z.width > U || Z.height > U) && (K = U / Math.max(Z.width, Z.height)), K < 1)
      if (typeof HTMLImageElement < "u" && M instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && M instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && M instanceof ImageBitmap || typeof VideoFrame < "u" && M instanceof VideoFrame) {
        const W = Math.floor(K * Z.width), be = Math.floor(K * Z.height);
        u === void 0 && (u = m(W, be));
        const oe = x ? m(W, be) : u;
        return oe.width = W, oe.height = be, oe.getContext("2d").drawImage(M, 0, 0, W, be), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Z.width + "x" + Z.height + ") to (" + W + "x" + be + ")."), oe;
      } else
        return "data" in M && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Z.width + "x" + Z.height + ")."), M;
    return M;
  }
  function f(M) {
    return M.generateMipmaps;
  }
  function p(M) {
    i.generateMipmap(M);
  }
  function v(M) {
    return M.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : M.isWebGL3DRenderTarget ? i.TEXTURE_3D : M.isWebGLArrayRenderTarget || M.isCompressedArrayTexture ? i.TEXTURE_2D_ARRAY : i.TEXTURE_2D;
  }
  function E(M, x, U, K, Z = !1) {
    if (M !== null) {
      if (i[M] !== void 0) return i[M];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + M + "'");
    }
    let W = x;
    if (x === i.RED && (U === i.FLOAT && (W = i.R32F), U === i.HALF_FLOAT && (W = i.R16F), U === i.UNSIGNED_BYTE && (W = i.R8)), x === i.RED_INTEGER && (U === i.UNSIGNED_BYTE && (W = i.R8UI), U === i.UNSIGNED_SHORT && (W = i.R16UI), U === i.UNSIGNED_INT && (W = i.R32UI), U === i.BYTE && (W = i.R8I), U === i.SHORT && (W = i.R16I), U === i.INT && (W = i.R32I)), x === i.RG && (U === i.FLOAT && (W = i.RG32F), U === i.HALF_FLOAT && (W = i.RG16F), U === i.UNSIGNED_BYTE && (W = i.RG8)), x === i.RG_INTEGER && (U === i.UNSIGNED_BYTE && (W = i.RG8UI), U === i.UNSIGNED_SHORT && (W = i.RG16UI), U === i.UNSIGNED_INT && (W = i.RG32UI), U === i.BYTE && (W = i.RG8I), U === i.SHORT && (W = i.RG16I), U === i.INT && (W = i.RG32I)), x === i.RGB_INTEGER && (U === i.UNSIGNED_BYTE && (W = i.RGB8UI), U === i.UNSIGNED_SHORT && (W = i.RGB16UI), U === i.UNSIGNED_INT && (W = i.RGB32UI), U === i.BYTE && (W = i.RGB8I), U === i.SHORT && (W = i.RGB16I), U === i.INT && (W = i.RGB32I)), x === i.RGBA_INTEGER && (U === i.UNSIGNED_BYTE && (W = i.RGBA8UI), U === i.UNSIGNED_SHORT && (W = i.RGBA16UI), U === i.UNSIGNED_INT && (W = i.RGBA32UI), U === i.BYTE && (W = i.RGBA8I), U === i.SHORT && (W = i.RGBA16I), U === i.INT && (W = i.RGBA32I)), x === i.RGB && U === i.UNSIGNED_INT_5_9_9_9_REV && (W = i.RGB9_E5), x === i.RGBA) {
      const be = Z ? Kr : We.getTransfer(K);
      U === i.FLOAT && (W = i.RGBA32F), U === i.HALF_FLOAT && (W = i.RGBA16F), U === i.UNSIGNED_BYTE && (W = be === at ? i.SRGB8_ALPHA8 : i.RGBA8), U === i.UNSIGNED_SHORT_4_4_4_4 && (W = i.RGBA4), U === i.UNSIGNED_SHORT_5_5_5_1 && (W = i.RGB5_A1);
    }
    return (W === i.R16F || W === i.R32F || W === i.RG16F || W === i.RG32F || W === i.RGBA16F || W === i.RGBA32F) && e.get("EXT_color_buffer_float"), W;
  }
  function b(M, x) {
    let U;
    return M ? x === null || x === 1014 || x === 1020 ? U = i.DEPTH24_STENCIL8 : x === 1015 ? U = i.DEPTH32F_STENCIL8 : x === 1012 && (U = i.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : x === null || x === 1014 || x === 1020 ? U = i.DEPTH_COMPONENT24 : x === 1015 ? U = i.DEPTH_COMPONENT32F : x === 1012 && (U = i.DEPTH_COMPONENT16), U;
  }
  function S(M, x) {
    return f(M) === !0 || M.isFramebufferTexture && M.minFilter !== 1003 && M.minFilter !== 1006 ? Math.log2(Math.max(x.width, x.height)) + 1 : M.mipmaps !== void 0 && M.mipmaps.length > 0 ? M.mipmaps.length : M.isCompressedTexture && Array.isArray(M.image) ? x.mipmaps.length : 1;
  }
  function I(M) {
    const x = M.target;
    x.removeEventListener("dispose", I), R(x), x.isVideoTexture && h.delete(x);
  }
  function B(M) {
    const x = M.target;
    x.removeEventListener("dispose", B), C(x);
  }
  function R(M) {
    const x = n.get(M);
    if (x.__webglInit === void 0) return;
    const U = M.source, K = d.get(U);
    if (K) {
      const Z = K[x.__cacheKey];
      Z.usedTimes--, Z.usedTimes === 0 && w(M), Object.keys(K).length === 0 && d.delete(U);
    }
    n.remove(M);
  }
  function w(M) {
    const x = n.get(M);
    i.deleteTexture(x.__webglTexture);
    const U = M.source, K = d.get(U);
    delete K[x.__cacheKey], a.memory.textures--;
  }
  function C(M) {
    const x = n.get(M);
    if (M.depthTexture && (M.depthTexture.dispose(), n.remove(M.depthTexture)), M.isWebGLCubeRenderTarget)
      for (let K = 0; K < 6; K++) {
        if (Array.isArray(x.__webglFramebuffer[K]))
          for (let Z = 0; Z < x.__webglFramebuffer[K].length; Z++) i.deleteFramebuffer(x.__webglFramebuffer[K][Z]);
        else
          i.deleteFramebuffer(x.__webglFramebuffer[K]);
        x.__webglDepthbuffer && i.deleteRenderbuffer(x.__webglDepthbuffer[K]);
      }
    else {
      if (Array.isArray(x.__webglFramebuffer))
        for (let K = 0; K < x.__webglFramebuffer.length; K++) i.deleteFramebuffer(x.__webglFramebuffer[K]);
      else
        i.deleteFramebuffer(x.__webglFramebuffer);
      if (x.__webglDepthbuffer && i.deleteRenderbuffer(x.__webglDepthbuffer), x.__webglMultisampledFramebuffer && i.deleteFramebuffer(x.__webglMultisampledFramebuffer), x.__webglColorRenderbuffer)
        for (let K = 0; K < x.__webglColorRenderbuffer.length; K++)
          x.__webglColorRenderbuffer[K] && i.deleteRenderbuffer(x.__webglColorRenderbuffer[K]);
      x.__webglDepthRenderbuffer && i.deleteRenderbuffer(x.__webglDepthRenderbuffer);
    }
    const U = M.textures;
    for (let K = 0, Z = U.length; K < Z; K++) {
      const W = n.get(U[K]);
      W.__webglTexture && (i.deleteTexture(W.__webglTexture), a.memory.textures--), n.remove(U[K]);
    }
    n.remove(M);
  }
  let D = 0;
  function _() {
    D = 0;
  }
  function Q() {
    const M = D;
    return M >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + M + " texture units while this GPU supports only " + s.maxTextures), D += 1, M;
  }
  function H(M) {
    const x = [];
    return x.push(M.wrapS), x.push(M.wrapT), x.push(M.wrapR || 0), x.push(M.magFilter), x.push(M.minFilter), x.push(M.anisotropy), x.push(M.internalFormat), x.push(M.format), x.push(M.type), x.push(M.generateMipmaps), x.push(M.premultiplyAlpha), x.push(M.flipY), x.push(M.unpackAlignment), x.push(M.colorSpace), x.join();
  }
  function j(M, x) {
    const U = n.get(M);
    if (M.isVideoTexture && Ee(M), M.isRenderTargetTexture === !1 && M.version > 0 && U.__version !== M.version) {
      const K = M.image;
      if (K === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (K.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        q(U, M, x);
        return;
      }
    }
    t.bindTexture(i.TEXTURE_2D, U.__webglTexture, i.TEXTURE0 + x);
  }
  function V(M, x) {
    const U = n.get(M);
    if (M.version > 0 && U.__version !== M.version) {
      q(U, M, x);
      return;
    }
    t.bindTexture(i.TEXTURE_2D_ARRAY, U.__webglTexture, i.TEXTURE0 + x);
  }
  function J(M, x) {
    const U = n.get(M);
    if (M.version > 0 && U.__version !== M.version) {
      q(U, M, x);
      return;
    }
    t.bindTexture(i.TEXTURE_3D, U.__webglTexture, i.TEXTURE0 + x);
  }
  function G(M, x) {
    const U = n.get(M);
    if (M.version > 0 && U.__version !== M.version) {
      ne(U, M, x);
      return;
    }
    t.bindTexture(i.TEXTURE_CUBE_MAP, U.__webglTexture, i.TEXTURE0 + x);
  }
  const te = {
    1e3: i.REPEAT,
    1001: i.CLAMP_TO_EDGE,
    1002: i.MIRRORED_REPEAT
  }, le = {
    1003: i.NEAREST,
    1004: i.NEAREST_MIPMAP_NEAREST,
    1005: i.NEAREST_MIPMAP_LINEAR,
    1006: i.LINEAR,
    1007: i.LINEAR_MIPMAP_NEAREST,
    1008: i.LINEAR_MIPMAP_LINEAR
  }, me = {
    512: i.NEVER,
    519: i.ALWAYS,
    513: i.LESS,
    515: i.LEQUAL,
    514: i.EQUAL,
    518: i.GEQUAL,
    516: i.GREATER,
    517: i.NOTEQUAL
  };
  function Re(M, x) {
    if (x.type === 1015 && e.has("OES_texture_float_linear") === !1 && (x.magFilter === 1006 || x.magFilter === 1007 || x.magFilter === 1005 || x.magFilter === 1008 || x.minFilter === 1006 || x.minFilter === 1007 || x.minFilter === 1005 || x.minFilter === 1008) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), i.texParameteri(M, i.TEXTURE_WRAP_S, te[x.wrapS]), i.texParameteri(M, i.TEXTURE_WRAP_T, te[x.wrapT]), (M === i.TEXTURE_3D || M === i.TEXTURE_2D_ARRAY) && i.texParameteri(M, i.TEXTURE_WRAP_R, te[x.wrapR]), i.texParameteri(M, i.TEXTURE_MAG_FILTER, le[x.magFilter]), i.texParameteri(M, i.TEXTURE_MIN_FILTER, le[x.minFilter]), x.compareFunction && (i.texParameteri(M, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE), i.texParameteri(M, i.TEXTURE_COMPARE_FUNC, me[x.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (x.magFilter === 1003 || x.minFilter !== 1005 && x.minFilter !== 1008 || x.type === 1015 && e.has("OES_texture_float_linear") === !1) return;
      if (x.anisotropy > 1 || n.get(x).__currentAnisotropy) {
        const U = e.get("EXT_texture_filter_anisotropic");
        i.texParameterf(M, U.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(x.anisotropy, s.getMaxAnisotropy())), n.get(x).__currentAnisotropy = x.anisotropy;
      }
    }
  }
  function Ge(M, x) {
    let U = !1;
    M.__webglInit === void 0 && (M.__webglInit = !0, x.addEventListener("dispose", I));
    const K = x.source;
    let Z = d.get(K);
    Z === void 0 && (Z = {}, d.set(K, Z));
    const W = H(x);
    if (W !== M.__cacheKey) {
      Z[W] === void 0 && (Z[W] = {
        texture: i.createTexture(),
        usedTimes: 0
      }, a.memory.textures++, U = !0), Z[W].usedTimes++;
      const be = Z[M.__cacheKey];
      be !== void 0 && (Z[M.__cacheKey].usedTimes--, be.usedTimes === 0 && w(x)), M.__cacheKey = W, M.__webglTexture = Z[W].texture;
    }
    return U;
  }
  function q(M, x, U) {
    let K = i.TEXTURE_2D;
    (x.isDataArrayTexture || x.isCompressedArrayTexture) && (K = i.TEXTURE_2D_ARRAY), x.isData3DTexture && (K = i.TEXTURE_3D);
    const Z = Ge(M, x), W = x.source;
    t.bindTexture(K, M.__webglTexture, i.TEXTURE0 + U);
    const be = n.get(W);
    if (W.version !== be.__version || Z === !0) {
      t.activeTexture(i.TEXTURE0 + U);
      const oe = We.getPrimaries(We.workingColorSpace), de = x.colorSpace === xn ? null : We.getPrimaries(x.colorSpace), Ye = x.colorSpace === xn || oe === de ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, x.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, x.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, x.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ye);
      let ee = g(x.image, !1, s.maxTextureSize);
      ee = ht(x, ee);
      const pe = r.convert(x.format, x.colorSpace), ye = r.convert(x.type);
      let Be = E(x.internalFormat, pe, ye, x.colorSpace, x.isVideoTexture);
      Re(K, x);
      let Ae;
      const qe = x.mipmaps, Ne = x.isVideoTexture !== !0, lt = be.__version === void 0 || Z === !0, L = W.dataReady, se = S(x, ee);
      if (x.isDepthTexture)
        Be = b(x.format === 1027, x.type), lt && (Ne ? t.texStorage2D(i.TEXTURE_2D, 1, Be, ee.width, ee.height) : t.texImage2D(i.TEXTURE_2D, 0, Be, ee.width, ee.height, 0, pe, ye, null));
      else if (x.isDataTexture)
        if (qe.length > 0) {
          Ne && lt && t.texStorage2D(i.TEXTURE_2D, se, Be, qe[0].width, qe[0].height);
          for (let z = 0, X = qe.length; z < X; z++)
            Ae = qe[z], Ne ? L && t.texSubImage2D(i.TEXTURE_2D, z, 0, 0, Ae.width, Ae.height, pe, ye, Ae.data) : t.texImage2D(i.TEXTURE_2D, z, Be, Ae.width, Ae.height, 0, pe, ye, Ae.data);
          x.generateMipmaps = !1;
        } else
          Ne ? (lt && t.texStorage2D(i.TEXTURE_2D, se, Be, ee.width, ee.height), L && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, ee.width, ee.height, pe, ye, ee.data)) : t.texImage2D(i.TEXTURE_2D, 0, Be, ee.width, ee.height, 0, pe, ye, ee.data);
      else if (x.isCompressedTexture)
        if (x.isCompressedArrayTexture) {
          Ne && lt && t.texStorage3D(i.TEXTURE_2D_ARRAY, se, Be, qe[0].width, qe[0].height, ee.depth);
          for (let z = 0, X = qe.length; z < X; z++)
            if (Ae = qe[z], x.format !== 1023)
              if (pe !== null)
                if (Ne) {
                  if (L)
                    if (x.layerUpdates.size > 0) {
                      const he = vc(Ae.width, Ae.height, x.format, x.type);
                      for (const ce of x.layerUpdates) {
                        const Le = Ae.data.subarray(
                          ce * he / Ae.data.BYTES_PER_ELEMENT,
                          (ce + 1) * he / Ae.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, z, 0, 0, ce, Ae.width, Ae.height, 1, pe, Le);
                      }
                      x.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, z, 0, 0, 0, Ae.width, Ae.height, ee.depth, pe, Ae.data);
                } else
                  t.compressedTexImage3D(i.TEXTURE_2D_ARRAY, z, Be, Ae.width, Ae.height, ee.depth, 0, Ae.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              Ne ? L && t.texSubImage3D(i.TEXTURE_2D_ARRAY, z, 0, 0, 0, Ae.width, Ae.height, ee.depth, pe, ye, Ae.data) : t.texImage3D(i.TEXTURE_2D_ARRAY, z, Be, Ae.width, Ae.height, ee.depth, 0, pe, ye, Ae.data);
        } else {
          Ne && lt && t.texStorage2D(i.TEXTURE_2D, se, Be, qe[0].width, qe[0].height);
          for (let z = 0, X = qe.length; z < X; z++)
            Ae = qe[z], x.format !== 1023 ? pe !== null ? Ne ? L && t.compressedTexSubImage2D(i.TEXTURE_2D, z, 0, 0, Ae.width, Ae.height, pe, Ae.data) : t.compressedTexImage2D(i.TEXTURE_2D, z, Be, Ae.width, Ae.height, 0, Ae.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ne ? L && t.texSubImage2D(i.TEXTURE_2D, z, 0, 0, Ae.width, Ae.height, pe, ye, Ae.data) : t.texImage2D(i.TEXTURE_2D, z, Be, Ae.width, Ae.height, 0, pe, ye, Ae.data);
        }
      else if (x.isDataArrayTexture)
        if (Ne) {
          if (lt && t.texStorage3D(i.TEXTURE_2D_ARRAY, se, Be, ee.width, ee.height, ee.depth), L)
            if (x.layerUpdates.size > 0) {
              const z = vc(ee.width, ee.height, x.format, x.type);
              for (const X of x.layerUpdates) {
                const he = ee.data.subarray(
                  X * z / ee.data.BYTES_PER_ELEMENT,
                  (X + 1) * z / ee.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, X, ee.width, ee.height, 1, pe, ye, he);
              }
              x.clearLayerUpdates();
            } else
              t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ee.width, ee.height, ee.depth, pe, ye, ee.data);
        } else
          t.texImage3D(i.TEXTURE_2D_ARRAY, 0, Be, ee.width, ee.height, ee.depth, 0, pe, ye, ee.data);
      else if (x.isData3DTexture)
        Ne ? (lt && t.texStorage3D(i.TEXTURE_3D, se, Be, ee.width, ee.height, ee.depth), L && t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, ee.width, ee.height, ee.depth, pe, ye, ee.data)) : t.texImage3D(i.TEXTURE_3D, 0, Be, ee.width, ee.height, ee.depth, 0, pe, ye, ee.data);
      else if (x.isFramebufferTexture) {
        if (lt)
          if (Ne)
            t.texStorage2D(i.TEXTURE_2D, se, Be, ee.width, ee.height);
          else {
            let z = ee.width, X = ee.height;
            for (let he = 0; he < se; he++)
              t.texImage2D(i.TEXTURE_2D, he, Be, z, X, 0, pe, ye, null), z >>= 1, X >>= 1;
          }
      } else if (qe.length > 0) {
        if (Ne && lt) {
          const z = ve(qe[0]);
          t.texStorage2D(i.TEXTURE_2D, se, Be, z.width, z.height);
        }
        for (let z = 0, X = qe.length; z < X; z++)
          Ae = qe[z], Ne ? L && t.texSubImage2D(i.TEXTURE_2D, z, 0, 0, pe, ye, Ae) : t.texImage2D(i.TEXTURE_2D, z, Be, pe, ye, Ae);
        x.generateMipmaps = !1;
      } else if (Ne) {
        if (lt) {
          const z = ve(ee);
          t.texStorage2D(i.TEXTURE_2D, se, Be, z.width, z.height);
        }
        L && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, pe, ye, ee);
      } else
        t.texImage2D(i.TEXTURE_2D, 0, Be, pe, ye, ee);
      f(x) && p(K), be.__version = W.version, x.onUpdate && x.onUpdate(x);
    }
    M.__version = x.version;
  }
  function ne(M, x, U) {
    if (x.image.length !== 6) return;
    const K = Ge(M, x), Z = x.source;
    t.bindTexture(i.TEXTURE_CUBE_MAP, M.__webglTexture, i.TEXTURE0 + U);
    const W = n.get(Z);
    if (Z.version !== W.__version || K === !0) {
      t.activeTexture(i.TEXTURE0 + U);
      const be = We.getPrimaries(We.workingColorSpace), oe = x.colorSpace === xn ? null : We.getPrimaries(x.colorSpace), de = x.colorSpace === xn || be === oe ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, x.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, x.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, x.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, de);
      const Ye = x.isCompressedTexture || x.image[0].isCompressedTexture, ee = x.image[0] && x.image[0].isDataTexture, pe = [];
      for (let X = 0; X < 6; X++)
        !Ye && !ee ? pe[X] = g(x.image[X], !0, s.maxCubemapSize) : pe[X] = ee ? x.image[X].image : x.image[X], pe[X] = ht(x, pe[X]);
      const ye = pe[0], Be = r.convert(x.format, x.colorSpace), Ae = r.convert(x.type), qe = E(x.internalFormat, Be, Ae, x.colorSpace), Ne = x.isVideoTexture !== !0, lt = W.__version === void 0 || K === !0, L = Z.dataReady;
      let se = S(x, ye);
      Re(i.TEXTURE_CUBE_MAP, x);
      let z;
      if (Ye) {
        Ne && lt && t.texStorage2D(i.TEXTURE_CUBE_MAP, se, qe, ye.width, ye.height);
        for (let X = 0; X < 6; X++) {
          z = pe[X].mipmaps;
          for (let he = 0; he < z.length; he++) {
            const ce = z[he];
            x.format !== 1023 ? Be !== null ? Ne ? L && t.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, he, 0, 0, ce.width, ce.height, Be, ce.data) : t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, he, qe, ce.width, ce.height, 0, ce.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ne ? L && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, he, 0, 0, ce.width, ce.height, Be, Ae, ce.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, he, qe, ce.width, ce.height, 0, Be, Ae, ce.data);
          }
        }
      } else {
        if (z = x.mipmaps, Ne && lt) {
          z.length > 0 && se++;
          const X = ve(pe[0]);
          t.texStorage2D(i.TEXTURE_CUBE_MAP, se, qe, X.width, X.height);
        }
        for (let X = 0; X < 6; X++)
          if (ee) {
            Ne ? L && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, 0, 0, 0, pe[X].width, pe[X].height, Be, Ae, pe[X].data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, 0, qe, pe[X].width, pe[X].height, 0, Be, Ae, pe[X].data);
            for (let he = 0; he < z.length; he++) {
              const Le = z[he].image[X].image;
              Ne ? L && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, he + 1, 0, 0, Le.width, Le.height, Be, Ae, Le.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, he + 1, qe, Le.width, Le.height, 0, Be, Ae, Le.data);
            }
          } else {
            Ne ? L && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, 0, 0, 0, Be, Ae, pe[X]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, 0, qe, Be, Ae, pe[X]);
            for (let he = 0; he < z.length; he++) {
              const ce = z[he];
              Ne ? L && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, he + 1, 0, 0, Be, Ae, ce.image[X]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + X, he + 1, qe, Be, Ae, ce.image[X]);
            }
          }
      }
      f(x) && p(i.TEXTURE_CUBE_MAP), W.__version = Z.version, x.onUpdate && x.onUpdate(x);
    }
    M.__version = x.version;
  }
  function ge(M, x, U, K, Z, W) {
    const be = r.convert(U.format, U.colorSpace), oe = r.convert(U.type), de = E(U.internalFormat, be, oe, U.colorSpace), Ye = n.get(x), ee = n.get(U);
    if (ee.__renderTarget = x, !Ye.__hasExternalTextures) {
      const pe = Math.max(1, x.width >> W), ye = Math.max(1, x.height >> W);
      Z === i.TEXTURE_3D || Z === i.TEXTURE_2D_ARRAY ? t.texImage3D(Z, W, de, pe, ye, x.depth, 0, be, oe, null) : t.texImage2D(Z, W, de, pe, ye, 0, be, oe, null);
    }
    t.bindFramebuffer(i.FRAMEBUFFER, M), ze(x) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, K, Z, ee.__webglTexture, 0, Ve(x)) : (Z === i.TEXTURE_2D || Z >= i.TEXTURE_CUBE_MAP_POSITIVE_X && Z <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, K, Z, ee.__webglTexture, W), t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function ae(M, x, U) {
    if (i.bindRenderbuffer(i.RENDERBUFFER, M), x.depthBuffer) {
      const K = x.depthTexture, Z = K && K.isDepthTexture ? K.type : null, W = b(x.stencilBuffer, Z), be = x.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, oe = Ve(x);
      ze(x) ? o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, oe, W, x.width, x.height) : U ? i.renderbufferStorageMultisample(i.RENDERBUFFER, oe, W, x.width, x.height) : i.renderbufferStorage(i.RENDERBUFFER, W, x.width, x.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, be, i.RENDERBUFFER, M);
    } else {
      const K = x.textures;
      for (let Z = 0; Z < K.length; Z++) {
        const W = K[Z], be = r.convert(W.format, W.colorSpace), oe = r.convert(W.type), de = E(W.internalFormat, be, oe, W.colorSpace), Ye = Ve(x);
        U && ze(x) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, Ye, de, x.width, x.height) : ze(x) ? o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, Ye, de, x.width, x.height) : i.renderbufferStorage(i.RENDERBUFFER, de, x.width, x.height);
      }
    }
    i.bindRenderbuffer(i.RENDERBUFFER, null);
  }
  function Me(M, x) {
    if (x && x.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(i.FRAMEBUFFER, M), !(x.depthTexture && x.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const K = n.get(x.depthTexture);
    K.__renderTarget = x, (!K.__webglTexture || x.depthTexture.image.width !== x.width || x.depthTexture.image.height !== x.height) && (x.depthTexture.image.width = x.width, x.depthTexture.image.height = x.height, x.depthTexture.needsUpdate = !0), j(x.depthTexture, 0);
    const Z = K.__webglTexture, W = Ve(x);
    if (x.depthTexture.format === 1026)
      ze(x) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, Z, 0, W) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, Z, 0);
    else if (x.depthTexture.format === 1027)
      ze(x) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, Z, 0, W) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, Z, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Ze(M) {
    const x = n.get(M), U = M.isWebGLCubeRenderTarget === !0;
    if (x.__boundDepthTexture !== M.depthTexture) {
      const K = M.depthTexture;
      if (x.__depthDisposeCallback && x.__depthDisposeCallback(), K) {
        const Z = () => {
          delete x.__boundDepthTexture, delete x.__depthDisposeCallback, K.removeEventListener("dispose", Z);
        };
        K.addEventListener("dispose", Z), x.__depthDisposeCallback = Z;
      }
      x.__boundDepthTexture = K;
    }
    if (M.depthTexture && !x.__autoAllocateDepthBuffer) {
      if (U) throw new Error("target.depthTexture not supported in Cube render targets");
      Me(x.__webglFramebuffer, M);
    } else if (U) {
      x.__webglDepthbuffer = [];
      for (let K = 0; K < 6; K++)
        if (t.bindFramebuffer(i.FRAMEBUFFER, x.__webglFramebuffer[K]), x.__webglDepthbuffer[K] === void 0)
          x.__webglDepthbuffer[K] = i.createRenderbuffer(), ae(x.__webglDepthbuffer[K], M, !1);
        else {
          const Z = M.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, W = x.__webglDepthbuffer[K];
          i.bindRenderbuffer(i.RENDERBUFFER, W), i.framebufferRenderbuffer(i.FRAMEBUFFER, Z, i.RENDERBUFFER, W);
        }
    } else if (t.bindFramebuffer(i.FRAMEBUFFER, x.__webglFramebuffer), x.__webglDepthbuffer === void 0)
      x.__webglDepthbuffer = i.createRenderbuffer(), ae(x.__webglDepthbuffer, M, !1);
    else {
      const K = M.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, Z = x.__webglDepthbuffer;
      i.bindRenderbuffer(i.RENDERBUFFER, Z), i.framebufferRenderbuffer(i.FRAMEBUFFER, K, i.RENDERBUFFER, Z);
    }
    t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function Se(M, x, U) {
    const K = n.get(M);
    x !== void 0 && ge(K.__webglFramebuffer, M, M.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0), U !== void 0 && Ze(M);
  }
  function vt(M) {
    const x = M.texture, U = n.get(M), K = n.get(x);
    M.addEventListener("dispose", B);
    const Z = M.textures, W = M.isWebGLCubeRenderTarget === !0, be = Z.length > 1;
    if (be || (K.__webglTexture === void 0 && (K.__webglTexture = i.createTexture()), K.__version = x.version, a.memory.textures++), W) {
      U.__webglFramebuffer = [];
      for (let oe = 0; oe < 6; oe++)
        if (x.mipmaps && x.mipmaps.length > 0) {
          U.__webglFramebuffer[oe] = [];
          for (let de = 0; de < x.mipmaps.length; de++)
            U.__webglFramebuffer[oe][de] = i.createFramebuffer();
        } else
          U.__webglFramebuffer[oe] = i.createFramebuffer();
    } else {
      if (x.mipmaps && x.mipmaps.length > 0) {
        U.__webglFramebuffer = [];
        for (let oe = 0; oe < x.mipmaps.length; oe++)
          U.__webglFramebuffer[oe] = i.createFramebuffer();
      } else
        U.__webglFramebuffer = i.createFramebuffer();
      if (be)
        for (let oe = 0, de = Z.length; oe < de; oe++) {
          const Ye = n.get(Z[oe]);
          Ye.__webglTexture === void 0 && (Ye.__webglTexture = i.createTexture(), a.memory.textures++);
        }
      if (M.samples > 0 && ze(M) === !1) {
        U.__webglMultisampledFramebuffer = i.createFramebuffer(), U.__webglColorRenderbuffer = [], t.bindFramebuffer(i.FRAMEBUFFER, U.__webglMultisampledFramebuffer);
        for (let oe = 0; oe < Z.length; oe++) {
          const de = Z[oe];
          U.__webglColorRenderbuffer[oe] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, U.__webglColorRenderbuffer[oe]);
          const Ye = r.convert(de.format, de.colorSpace), ee = r.convert(de.type), pe = E(de.internalFormat, Ye, ee, de.colorSpace, M.isXRRenderTarget === !0), ye = Ve(M);
          i.renderbufferStorageMultisample(i.RENDERBUFFER, ye, pe, M.width, M.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + oe, i.RENDERBUFFER, U.__webglColorRenderbuffer[oe]);
        }
        i.bindRenderbuffer(i.RENDERBUFFER, null), M.depthBuffer && (U.__webglDepthRenderbuffer = i.createRenderbuffer(), ae(U.__webglDepthRenderbuffer, M, !0)), t.bindFramebuffer(i.FRAMEBUFFER, null);
      }
    }
    if (W) {
      t.bindTexture(i.TEXTURE_CUBE_MAP, K.__webglTexture), Re(i.TEXTURE_CUBE_MAP, x);
      for (let oe = 0; oe < 6; oe++)
        if (x.mipmaps && x.mipmaps.length > 0)
          for (let de = 0; de < x.mipmaps.length; de++)
            ge(U.__webglFramebuffer[oe][de], M, x, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + oe, de);
        else
          ge(U.__webglFramebuffer[oe], M, x, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + oe, 0);
      f(x) && p(i.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (be) {
      for (let oe = 0, de = Z.length; oe < de; oe++) {
        const Ye = Z[oe], ee = n.get(Ye);
        t.bindTexture(i.TEXTURE_2D, ee.__webglTexture), Re(i.TEXTURE_2D, Ye), ge(U.__webglFramebuffer, M, Ye, i.COLOR_ATTACHMENT0 + oe, i.TEXTURE_2D, 0), f(Ye) && p(i.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let oe = i.TEXTURE_2D;
      if ((M.isWebGL3DRenderTarget || M.isWebGLArrayRenderTarget) && (oe = M.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY), t.bindTexture(oe, K.__webglTexture), Re(oe, x), x.mipmaps && x.mipmaps.length > 0)
        for (let de = 0; de < x.mipmaps.length; de++)
          ge(U.__webglFramebuffer[de], M, x, i.COLOR_ATTACHMENT0, oe, de);
      else
        ge(U.__webglFramebuffer, M, x, i.COLOR_ATTACHMENT0, oe, 0);
      f(x) && p(oe), t.unbindTexture();
    }
    M.depthBuffer && Ze(M);
  }
  function pt(M) {
    const x = M.textures;
    for (let U = 0, K = x.length; U < K; U++) {
      const Z = x[U];
      if (f(Z)) {
        const W = v(M), be = n.get(Z).__webglTexture;
        t.bindTexture(W, be), p(W), t.unbindTexture();
      }
    }
  }
  const He = [], P = [];
  function tn(M) {
    if (M.samples > 0) {
      if (ze(M) === !1) {
        const x = M.textures, U = M.width, K = M.height;
        let Z = i.COLOR_BUFFER_BIT;
        const W = M.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, be = n.get(M), oe = x.length > 1;
        if (oe)
          for (let de = 0; de < x.length; de++)
            t.bindFramebuffer(i.FRAMEBUFFER, be.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + de, i.RENDERBUFFER, null), t.bindFramebuffer(i.FRAMEBUFFER, be.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + de, i.TEXTURE_2D, null, 0);
        t.bindFramebuffer(i.READ_FRAMEBUFFER, be.__webglMultisampledFramebuffer), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, be.__webglFramebuffer);
        for (let de = 0; de < x.length; de++) {
          if (M.resolveDepthBuffer && (M.depthBuffer && (Z |= i.DEPTH_BUFFER_BIT), M.stencilBuffer && M.resolveStencilBuffer && (Z |= i.STENCIL_BUFFER_BIT)), oe) {
            i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, be.__webglColorRenderbuffer[de]);
            const Ye = n.get(x[de]).__webglTexture;
            i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, Ye, 0);
          }
          i.blitFramebuffer(0, 0, U, K, 0, 0, U, K, Z, i.NEAREST), l === !0 && (He.length = 0, P.length = 0, He.push(i.COLOR_ATTACHMENT0 + de), M.depthBuffer && M.resolveDepthBuffer === !1 && (He.push(W), P.push(W), i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, P)), i.invalidateFramebuffer(i.READ_FRAMEBUFFER, He));
        }
        if (t.bindFramebuffer(i.READ_FRAMEBUFFER, null), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), oe)
          for (let de = 0; de < x.length; de++) {
            t.bindFramebuffer(i.FRAMEBUFFER, be.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + de, i.RENDERBUFFER, be.__webglColorRenderbuffer[de]);
            const Ye = n.get(x[de]).__webglTexture;
            t.bindFramebuffer(i.FRAMEBUFFER, be.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + de, i.TEXTURE_2D, Ye, 0);
          }
        t.bindFramebuffer(i.DRAW_FRAMEBUFFER, be.__webglMultisampledFramebuffer);
      } else if (M.depthBuffer && M.resolveDepthBuffer === !1 && l) {
        const x = M.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
        i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [x]);
      }
    }
  }
  function Ve(M) {
    return Math.min(s.maxSamples, M.samples);
  }
  function ze(M) {
    const x = n.get(M);
    return M.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && x.__useRenderToTexture !== !1;
  }
  function Ee(M) {
    const x = a.render.frame;
    h.get(M) !== x && (h.set(M, x), M.update());
  }
  function ht(M, x) {
    const U = M.colorSpace, K = M.format, Z = M.type;
    return M.isCompressedTexture === !0 || M.isVideoTexture === !0 || U !== Ut && U !== xn && (We.getTransfer(U) === at ? (K !== 1023 || Z !== 1009) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", U)), x;
  }
  function ve(M) {
    return typeof HTMLImageElement < "u" && M instanceof HTMLImageElement ? (c.width = M.naturalWidth || M.width, c.height = M.naturalHeight || M.height) : typeof VideoFrame < "u" && M instanceof VideoFrame ? (c.width = M.displayWidth, c.height = M.displayHeight) : (c.width = M.width, c.height = M.height), c;
  }
  this.allocateTextureUnit = Q, this.resetTextureUnits = _, this.setTexture2D = j, this.setTexture2DArray = V, this.setTexture3D = J, this.setTextureCube = G, this.rebindTextures = Se, this.setupRenderTarget = vt, this.updateRenderTargetMipmap = pt, this.updateMultisampleRenderTarget = tn, this.setupDepthRenderbuffer = Ze, this.setupFrameBufferTexture = ge, this.useMultisampledRTT = ze;
}
function Ob(i, e) {
  function t(n, s = xn) {
    let r;
    const a = We.getTransfer(s);
    if (n === 1009) return i.UNSIGNED_BYTE;
    if (n === 1017) return i.UNSIGNED_SHORT_4_4_4_4;
    if (n === 1018) return i.UNSIGNED_SHORT_5_5_5_1;
    if (n === 35902) return i.UNSIGNED_INT_5_9_9_9_REV;
    if (n === 1010) return i.BYTE;
    if (n === 1011) return i.SHORT;
    if (n === 1012) return i.UNSIGNED_SHORT;
    if (n === 1013) return i.INT;
    if (n === 1014) return i.UNSIGNED_INT;
    if (n === 1015) return i.FLOAT;
    if (n === 1016) return i.HALF_FLOAT;
    if (n === 1021) return i.ALPHA;
    if (n === 1022) return i.RGB;
    if (n === 1023) return i.RGBA;
    if (n === 1024) return i.LUMINANCE;
    if (n === 1025) return i.LUMINANCE_ALPHA;
    if (n === 1026) return i.DEPTH_COMPONENT;
    if (n === 1027) return i.DEPTH_STENCIL;
    if (n === 1028) return i.RED;
    if (n === 1029) return i.RED_INTEGER;
    if (n === 1030) return i.RG;
    if (n === 1031) return i.RG_INTEGER;
    if (n === 1033) return i.RGBA_INTEGER;
    if (n === 33776 || n === 33777 || n === 33778 || n === 33779)
      if (a === at)
        if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
          if (n === 33776) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === 33777) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === 33778) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === 33779) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
        if (n === 33776) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === 33777) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === 33778) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === 33779) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === 35840 || n === 35841 || n === 35842 || n === 35843)
      if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
        if (n === 35840) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === 35841) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === 35842) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === 35843) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === 36196 || n === 37492 || n === 37496)
      if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
        if (n === 36196 || n === 37492) return a === at ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
        if (n === 37496) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (n === 37808 || n === 37809 || n === 37810 || n === 37811 || n === 37812 || n === 37813 || n === 37814 || n === 37815 || n === 37816 || n === 37817 || n === 37818 || n === 37819 || n === 37820 || n === 37821)
      if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
        if (n === 37808) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === 37809) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === 37810) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === 37811) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === 37812) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === 37813) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === 37814) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === 37815) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === 37816) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === 37817) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === 37818) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === 37819) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === 37820) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === 37821) return a === at ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === 36492 || n === 36494 || n === 36495)
      if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
        if (n === 36492) return a === at ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === 36494) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === 36495) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (n === 36283 || n === 36284 || n === 36285 || n === 36286)
      if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
        if (n === 36492) return r.COMPRESSED_RED_RGTC1_EXT;
        if (n === 36284) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === 36285) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === 36286) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === 1020 ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null;
  }
  return { convert: t };
}
const Gb = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, Hb = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class Vb {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, t, n) {
    if (this.texture === null) {
      const s = new It(), r = e.properties.get(s);
      r.__webglTexture = t.texture, (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = s;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport, n = new Mn({
        vertexShader: Gb,
        fragmentShader: Hb,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: t.z },
          depthHeight: { value: t.w }
        }
      });
      this.mesh = new ot(new Li(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class zb extends Pt {
  constructor(e, t) {
    super();
    const n = this;
    let s = null, r = 1, a = null, o = "local-floor", l = 1, c = null, h = null, u = null, d = null, A = null, m = null;
    const g = new Vb(), f = t.getContextAttributes();
    let p = null, v = null;
    const E = [], b = [], S = new Ie();
    let I = null;
    const B = new Gt();
    B.viewport = new $e();
    const R = new Gt();
    R.viewport = new $e();
    const w = [B, R], C = new tA();
    let D = null, _ = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(q) {
      let ne = E[q];
      return ne === void 0 && (ne = new Fa(), E[q] = ne), ne.getTargetRaySpace();
    }, this.getControllerGrip = function(q) {
      let ne = E[q];
      return ne === void 0 && (ne = new Fa(), E[q] = ne), ne.getGripSpace();
    }, this.getHand = function(q) {
      let ne = E[q];
      return ne === void 0 && (ne = new Fa(), E[q] = ne), ne.getHandSpace();
    };
    function Q(q) {
      const ne = b.indexOf(q.inputSource);
      if (ne === -1)
        return;
      const ge = E[ne];
      ge !== void 0 && (ge.update(q.inputSource, q.frame, c || a), ge.dispatchEvent({ type: q.type, data: q.inputSource }));
    }
    function H() {
      s.removeEventListener("select", Q), s.removeEventListener("selectstart", Q), s.removeEventListener("selectend", Q), s.removeEventListener("squeeze", Q), s.removeEventListener("squeezestart", Q), s.removeEventListener("squeezeend", Q), s.removeEventListener("end", H), s.removeEventListener("inputsourceschange", j);
      for (let q = 0; q < E.length; q++) {
        const ne = b[q];
        ne !== null && (b[q] = null, E[q].disconnect(ne));
      }
      D = null, _ = null, g.reset(), e.setRenderTarget(p), A = null, d = null, u = null, s = null, v = null, Ge.stop(), n.isPresenting = !1, e.setPixelRatio(I), e.setSize(S.width, S.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(q) {
      r = q, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(q) {
      o = q, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || a;
    }, this.setReferenceSpace = function(q) {
      c = q;
    }, this.getBaseLayer = function() {
      return d !== null ? d : A;
    }, this.getBinding = function() {
      return u;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return s;
    }, this.setSession = async function(q) {
      if (s = q, s !== null) {
        if (p = e.getRenderTarget(), s.addEventListener("select", Q), s.addEventListener("selectstart", Q), s.addEventListener("selectend", Q), s.addEventListener("squeeze", Q), s.addEventListener("squeezestart", Q), s.addEventListener("squeezeend", Q), s.addEventListener("end", H), s.addEventListener("inputsourceschange", j), f.xrCompatible !== !0 && await t.makeXRCompatible(), I = e.getPixelRatio(), e.getSize(S), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
          let ge = null, ae = null, Me = null;
          f.depth && (Me = f.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, ge = f.stencil ? 1027 : 1026, ae = f.stencil ? 1020 : 1014);
          const Ze = {
            colorFormat: t.RGBA8,
            depthFormat: Me,
            scaleFactor: r
          };
          u = new XRWebGLBinding(s, t), d = u.createProjectionLayer(Ze), s.updateRenderState({ layers: [d] }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), v = new Kn(
            d.textureWidth,
            d.textureHeight,
            {
              format: 1023,
              type: 1009,
              depthTexture: new Qo(d.textureWidth, d.textureHeight, ae, void 0, void 0, void 0, void 0, void 0, void 0, ge),
              stencilBuffer: f.stencil,
              colorSpace: e.outputColorSpace,
              samples: f.antialias ? 4 : 0,
              resolveDepthBuffer: d.ignoreDepthValues === !1
            }
          );
        } else {
          const ge = {
            antialias: f.antialias,
            alpha: !0,
            depth: f.depth,
            stencil: f.stencil,
            framebufferScaleFactor: r
          };
          A = new XRWebGLLayer(s, t, ge), s.updateRenderState({ baseLayer: A }), e.setPixelRatio(1), e.setSize(A.framebufferWidth, A.framebufferHeight, !1), v = new Kn(
            A.framebufferWidth,
            A.framebufferHeight,
            {
              format: 1023,
              type: 1009,
              colorSpace: e.outputColorSpace,
              stencilBuffer: f.stencil
            }
          );
        }
        v.isXRRenderTarget = !0, this.setFoveation(l), c = null, a = await s.requestReferenceSpace(o), Ge.setContext(s), Ge.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (s !== null)
        return s.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return g.getDepthTexture();
    };
    function j(q) {
      for (let ne = 0; ne < q.removed.length; ne++) {
        const ge = q.removed[ne], ae = b.indexOf(ge);
        ae >= 0 && (b[ae] = null, E[ae].disconnect(ge));
      }
      for (let ne = 0; ne < q.added.length; ne++) {
        const ge = q.added[ne];
        let ae = b.indexOf(ge);
        if (ae === -1) {
          for (let Ze = 0; Ze < E.length; Ze++)
            if (Ze >= b.length) {
              b.push(ge), ae = Ze;
              break;
            } else if (b[Ze] === null) {
              b[Ze] = ge, ae = Ze;
              break;
            }
          if (ae === -1) break;
        }
        const Me = E[ae];
        Me && Me.connect(ge);
      }
    }
    const V = new T(), J = new T();
    function G(q, ne, ge) {
      V.setFromMatrixPosition(ne.matrixWorld), J.setFromMatrixPosition(ge.matrixWorld);
      const ae = V.distanceTo(J), Me = ne.projectionMatrix.elements, Ze = ge.projectionMatrix.elements, Se = Me[14] / (Me[10] - 1), vt = Me[14] / (Me[10] + 1), pt = (Me[9] + 1) / Me[5], He = (Me[9] - 1) / Me[5], P = (Me[8] - 1) / Me[0], tn = (Ze[8] + 1) / Ze[0], Ve = Se * P, ze = Se * tn, Ee = ae / (-P + tn), ht = Ee * -P;
      if (ne.matrixWorld.decompose(q.position, q.quaternion, q.scale), q.translateX(ht), q.translateZ(Ee), q.matrixWorld.compose(q.position, q.quaternion, q.scale), q.matrixWorldInverse.copy(q.matrixWorld).invert(), Me[10] === -1)
        q.projectionMatrix.copy(ne.projectionMatrix), q.projectionMatrixInverse.copy(ne.projectionMatrixInverse);
      else {
        const ve = Se + Ee, M = vt + Ee, x = Ve - ht, U = ze + (ae - ht), K = pt * vt / M * ve, Z = He * vt / M * ve;
        q.projectionMatrix.makePerspective(x, U, K, Z, ve, M), q.projectionMatrixInverse.copy(q.projectionMatrix).invert();
      }
    }
    function te(q, ne) {
      ne === null ? q.matrixWorld.copy(q.matrix) : q.matrixWorld.multiplyMatrices(ne.matrixWorld, q.matrix), q.matrixWorldInverse.copy(q.matrixWorld).invert();
    }
    this.updateCamera = function(q) {
      if (s === null) return;
      let ne = q.near, ge = q.far;
      g.texture !== null && (g.depthNear > 0 && (ne = g.depthNear), g.depthFar > 0 && (ge = g.depthFar)), C.near = R.near = B.near = ne, C.far = R.far = B.far = ge, (D !== C.near || _ !== C.far) && (s.updateRenderState({
        depthNear: C.near,
        depthFar: C.far
      }), D = C.near, _ = C.far), B.layers.mask = q.layers.mask | 2, R.layers.mask = q.layers.mask | 4, C.layers.mask = B.layers.mask | R.layers.mask;
      const ae = q.parent, Me = C.cameras;
      te(C, ae);
      for (let Ze = 0; Ze < Me.length; Ze++)
        te(Me[Ze], ae);
      Me.length === 2 ? G(C, B, R) : C.projectionMatrix.copy(B.projectionMatrix), le(q, C, ae);
    };
    function le(q, ne, ge) {
      ge === null ? q.matrix.copy(ne.matrixWorld) : (q.matrix.copy(ge.matrixWorld), q.matrix.invert(), q.matrix.multiply(ne.matrixWorld)), q.matrix.decompose(q.position, q.quaternion, q.scale), q.updateMatrixWorld(!0), q.projectionMatrix.copy(ne.projectionMatrix), q.projectionMatrixInverse.copy(ne.projectionMatrixInverse), q.isPerspectiveCamera && (q.fov = ds * 2 * Math.atan(1 / q.projectionMatrix.elements[5]), q.zoom = 1);
    }
    this.getCamera = function() {
      return C;
    }, this.getFoveation = function() {
      if (!(d === null && A === null))
        return l;
    }, this.setFoveation = function(q) {
      l = q, d !== null && (d.fixedFoveation = q), A !== null && A.fixedFoveation !== void 0 && (A.fixedFoveation = q);
    }, this.hasDepthSensing = function() {
      return g.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return g.getMesh(C);
    };
    let me = null;
    function Re(q, ne) {
      if (h = ne.getViewerPose(c || a), m = ne, h !== null) {
        const ge = h.views;
        A !== null && (e.setRenderTargetFramebuffer(v, A.framebuffer), e.setRenderTarget(v));
        let ae = !1;
        ge.length !== C.cameras.length && (C.cameras.length = 0, ae = !0);
        for (let Se = 0; Se < ge.length; Se++) {
          const vt = ge[Se];
          let pt = null;
          if (A !== null)
            pt = A.getViewport(vt);
          else {
            const P = u.getViewSubImage(d, vt);
            pt = P.viewport, Se === 0 && (e.setRenderTargetTextures(
              v,
              P.colorTexture,
              d.ignoreDepthValues ? void 0 : P.depthStencilTexture
            ), e.setRenderTarget(v));
          }
          let He = w[Se];
          He === void 0 && (He = new Gt(), He.layers.enable(Se), He.viewport = new $e(), w[Se] = He), He.matrix.fromArray(vt.transform.matrix), He.matrix.decompose(He.position, He.quaternion, He.scale), He.projectionMatrix.fromArray(vt.projectionMatrix), He.projectionMatrixInverse.copy(He.projectionMatrix).invert(), He.viewport.set(pt.x, pt.y, pt.width, pt.height), Se === 0 && (C.matrix.copy(He.matrix), C.matrix.decompose(C.position, C.quaternion, C.scale)), ae === !0 && C.cameras.push(He);
        }
        const Me = s.enabledFeatures;
        if (Me && Me.includes("depth-sensing") && s.depthUsage == "gpu-optimized" && u) {
          const Se = u.getDepthInformation(ge[0]);
          Se && Se.isValid && Se.texture && g.init(e, Se, s.renderState);
        }
      }
      for (let ge = 0; ge < E.length; ge++) {
        const ae = b[ge], Me = E[ge];
        ae !== null && Me !== void 0 && Me.update(ae, ne, c || a);
      }
      me && me(q, ne), ne.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: ne }), m = null;
    }
    const Ge = new Yh();
    Ge.setAnimationLoop(Re), this.setAnimationLoop = function(q) {
      me = q;
    }, this.dispose = function() {
    };
  }
}
const xi = /* @__PURE__ */ new In(), qb = /* @__PURE__ */ new Pe();
function Wb(i, e) {
  function t(f, p) {
    f.matrixAutoUpdate === !0 && f.updateMatrix(), p.value.copy(f.matrix);
  }
  function n(f, p) {
    p.color.getRGB(f.fogColor.value, kh(i)), p.isFog ? (f.fogNear.value = p.near, f.fogFar.value = p.far) : p.isFogExp2 && (f.fogDensity.value = p.density);
  }
  function s(f, p, v, E, b) {
    p.isMeshBasicMaterial || p.isMeshLambertMaterial ? r(f, p) : p.isMeshToonMaterial ? (r(f, p), u(f, p)) : p.isMeshPhongMaterial ? (r(f, p), h(f, p)) : p.isMeshStandardMaterial ? (r(f, p), d(f, p), p.isMeshPhysicalMaterial && A(f, p, b)) : p.isMeshMatcapMaterial ? (r(f, p), m(f, p)) : p.isMeshDepthMaterial ? r(f, p) : p.isMeshDistanceMaterial ? (r(f, p), g(f, p)) : p.isMeshNormalMaterial ? r(f, p) : p.isLineBasicMaterial ? (a(f, p), p.isLineDashedMaterial && o(f, p)) : p.isPointsMaterial ? l(f, p, v, E) : p.isSpriteMaterial ? c(f, p) : p.isShadowMaterial ? (f.color.value.copy(p.color), f.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
  }
  function r(f, p) {
    f.opacity.value = p.opacity, p.color && f.diffuse.value.copy(p.color), p.emissive && f.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (f.map.value = p.map, t(p.map, f.mapTransform)), p.alphaMap && (f.alphaMap.value = p.alphaMap, t(p.alphaMap, f.alphaMapTransform)), p.bumpMap && (f.bumpMap.value = p.bumpMap, t(p.bumpMap, f.bumpMapTransform), f.bumpScale.value = p.bumpScale, p.side === 1 && (f.bumpScale.value *= -1)), p.normalMap && (f.normalMap.value = p.normalMap, t(p.normalMap, f.normalMapTransform), f.normalScale.value.copy(p.normalScale), p.side === 1 && f.normalScale.value.negate()), p.displacementMap && (f.displacementMap.value = p.displacementMap, t(p.displacementMap, f.displacementMapTransform), f.displacementScale.value = p.displacementScale, f.displacementBias.value = p.displacementBias), p.emissiveMap && (f.emissiveMap.value = p.emissiveMap, t(p.emissiveMap, f.emissiveMapTransform)), p.specularMap && (f.specularMap.value = p.specularMap, t(p.specularMap, f.specularMapTransform)), p.alphaTest > 0 && (f.alphaTest.value = p.alphaTest);
    const v = e.get(p), E = v.envMap, b = v.envMapRotation;
    E && (f.envMap.value = E, xi.copy(b), xi.x *= -1, xi.y *= -1, xi.z *= -1, E.isCubeTexture && E.isRenderTargetTexture === !1 && (xi.y *= -1, xi.z *= -1), f.envMapRotation.value.setFromMatrix4(qb.makeRotationFromEuler(xi)), f.flipEnvMap.value = E.isCubeTexture && E.isRenderTargetTexture === !1 ? -1 : 1, f.reflectivity.value = p.reflectivity, f.ior.value = p.ior, f.refractionRatio.value = p.refractionRatio), p.lightMap && (f.lightMap.value = p.lightMap, f.lightMapIntensity.value = p.lightMapIntensity, t(p.lightMap, f.lightMapTransform)), p.aoMap && (f.aoMap.value = p.aoMap, f.aoMapIntensity.value = p.aoMapIntensity, t(p.aoMap, f.aoMapTransform));
  }
  function a(f, p) {
    f.diffuse.value.copy(p.color), f.opacity.value = p.opacity, p.map && (f.map.value = p.map, t(p.map, f.mapTransform));
  }
  function o(f, p) {
    f.dashSize.value = p.dashSize, f.totalSize.value = p.dashSize + p.gapSize, f.scale.value = p.scale;
  }
  function l(f, p, v, E) {
    f.diffuse.value.copy(p.color), f.opacity.value = p.opacity, f.size.value = p.size * v, f.scale.value = E * 0.5, p.map && (f.map.value = p.map, t(p.map, f.uvTransform)), p.alphaMap && (f.alphaMap.value = p.alphaMap, t(p.alphaMap, f.alphaMapTransform)), p.alphaTest > 0 && (f.alphaTest.value = p.alphaTest);
  }
  function c(f, p) {
    f.diffuse.value.copy(p.color), f.opacity.value = p.opacity, f.rotation.value = p.rotation, p.map && (f.map.value = p.map, t(p.map, f.mapTransform)), p.alphaMap && (f.alphaMap.value = p.alphaMap, t(p.alphaMap, f.alphaMapTransform)), p.alphaTest > 0 && (f.alphaTest.value = p.alphaTest);
  }
  function h(f, p) {
    f.specular.value.copy(p.specular), f.shininess.value = Math.max(p.shininess, 1e-4);
  }
  function u(f, p) {
    p.gradientMap && (f.gradientMap.value = p.gradientMap);
  }
  function d(f, p) {
    f.metalness.value = p.metalness, p.metalnessMap && (f.metalnessMap.value = p.metalnessMap, t(p.metalnessMap, f.metalnessMapTransform)), f.roughness.value = p.roughness, p.roughnessMap && (f.roughnessMap.value = p.roughnessMap, t(p.roughnessMap, f.roughnessMapTransform)), p.envMap && (f.envMapIntensity.value = p.envMapIntensity);
  }
  function A(f, p, v) {
    f.ior.value = p.ior, p.sheen > 0 && (f.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), f.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (f.sheenColorMap.value = p.sheenColorMap, t(p.sheenColorMap, f.sheenColorMapTransform)), p.sheenRoughnessMap && (f.sheenRoughnessMap.value = p.sheenRoughnessMap, t(p.sheenRoughnessMap, f.sheenRoughnessMapTransform))), p.clearcoat > 0 && (f.clearcoat.value = p.clearcoat, f.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (f.clearcoatMap.value = p.clearcoatMap, t(p.clearcoatMap, f.clearcoatMapTransform)), p.clearcoatRoughnessMap && (f.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap, t(p.clearcoatRoughnessMap, f.clearcoatRoughnessMapTransform)), p.clearcoatNormalMap && (f.clearcoatNormalMap.value = p.clearcoatNormalMap, t(p.clearcoatNormalMap, f.clearcoatNormalMapTransform), f.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), p.side === 1 && f.clearcoatNormalScale.value.negate())), p.dispersion > 0 && (f.dispersion.value = p.dispersion), p.iridescence > 0 && (f.iridescence.value = p.iridescence, f.iridescenceIOR.value = p.iridescenceIOR, f.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], f.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (f.iridescenceMap.value = p.iridescenceMap, t(p.iridescenceMap, f.iridescenceMapTransform)), p.iridescenceThicknessMap && (f.iridescenceThicknessMap.value = p.iridescenceThicknessMap, t(p.iridescenceThicknessMap, f.iridescenceThicknessMapTransform))), p.transmission > 0 && (f.transmission.value = p.transmission, f.transmissionSamplerMap.value = v.texture, f.transmissionSamplerSize.value.set(v.width, v.height), p.transmissionMap && (f.transmissionMap.value = p.transmissionMap, t(p.transmissionMap, f.transmissionMapTransform)), f.thickness.value = p.thickness, p.thicknessMap && (f.thicknessMap.value = p.thicknessMap, t(p.thicknessMap, f.thicknessMapTransform)), f.attenuationDistance.value = p.attenuationDistance, f.attenuationColor.value.copy(p.attenuationColor)), p.anisotropy > 0 && (f.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)), p.anisotropyMap && (f.anisotropyMap.value = p.anisotropyMap, t(p.anisotropyMap, f.anisotropyMapTransform))), f.specularIntensity.value = p.specularIntensity, f.specularColor.value.copy(p.specularColor), p.specularColorMap && (f.specularColorMap.value = p.specularColorMap, t(p.specularColorMap, f.specularColorMapTransform)), p.specularIntensityMap && (f.specularIntensityMap.value = p.specularIntensityMap, t(p.specularIntensityMap, f.specularIntensityMapTransform));
  }
  function m(f, p) {
    p.matcap && (f.matcap.value = p.matcap);
  }
  function g(f, p) {
    const v = e.get(p).light;
    f.referencePosition.value.setFromMatrixPosition(v.matrixWorld), f.nearDistance.value = v.shadow.camera.near, f.farDistance.value = v.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: s
  };
}
function Yb(i, e, t, n) {
  let s = {}, r = {}, a = [];
  const o = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(v, E) {
    const b = E.program;
    n.uniformBlockBinding(v, b);
  }
  function c(v, E) {
    let b = s[v.id];
    b === void 0 && (m(v), b = h(v), s[v.id] = b, v.addEventListener("dispose", f));
    const S = E.program;
    n.updateUBOMapping(v, S);
    const I = e.render.frame;
    r[v.id] !== I && (d(v), r[v.id] = I);
  }
  function h(v) {
    const E = u();
    v.__bindingPointIndex = E;
    const b = i.createBuffer(), S = v.__size, I = v.usage;
    return i.bindBuffer(i.UNIFORM_BUFFER, b), i.bufferData(i.UNIFORM_BUFFER, S, I), i.bindBuffer(i.UNIFORM_BUFFER, null), i.bindBufferBase(i.UNIFORM_BUFFER, E, b), b;
  }
  function u() {
    for (let v = 0; v < o; v++)
      if (a.indexOf(v) === -1)
        return a.push(v), v;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function d(v) {
    const E = s[v.id], b = v.uniforms, S = v.__cache;
    i.bindBuffer(i.UNIFORM_BUFFER, E);
    for (let I = 0, B = b.length; I < B; I++) {
      const R = Array.isArray(b[I]) ? b[I] : [b[I]];
      for (let w = 0, C = R.length; w < C; w++) {
        const D = R[w];
        if (A(D, I, w, S) === !0) {
          const _ = D.__offset, Q = Array.isArray(D.value) ? D.value : [D.value];
          let H = 0;
          for (let j = 0; j < Q.length; j++) {
            const V = Q[j], J = g(V);
            typeof V == "number" || typeof V == "boolean" ? (D.__data[0] = V, i.bufferSubData(i.UNIFORM_BUFFER, _ + H, D.__data)) : V.isMatrix3 ? (D.__data[0] = V.elements[0], D.__data[1] = V.elements[1], D.__data[2] = V.elements[2], D.__data[3] = 0, D.__data[4] = V.elements[3], D.__data[5] = V.elements[4], D.__data[6] = V.elements[5], D.__data[7] = 0, D.__data[8] = V.elements[6], D.__data[9] = V.elements[7], D.__data[10] = V.elements[8], D.__data[11] = 0) : (V.toArray(D.__data, H), H += J.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          i.bufferSubData(i.UNIFORM_BUFFER, _, D.__data);
        }
      }
    }
    i.bindBuffer(i.UNIFORM_BUFFER, null);
  }
  function A(v, E, b, S) {
    const I = v.value, B = E + "_" + b;
    if (S[B] === void 0)
      return typeof I == "number" || typeof I == "boolean" ? S[B] = I : S[B] = I.clone(), !0;
    {
      const R = S[B];
      if (typeof I == "number" || typeof I == "boolean") {
        if (R !== I)
          return S[B] = I, !0;
      } else if (R.equals(I) === !1)
        return R.copy(I), !0;
    }
    return !1;
  }
  function m(v) {
    const E = v.uniforms;
    let b = 0;
    const S = 16;
    for (let B = 0, R = E.length; B < R; B++) {
      const w = Array.isArray(E[B]) ? E[B] : [E[B]];
      for (let C = 0, D = w.length; C < D; C++) {
        const _ = w[C], Q = Array.isArray(_.value) ? _.value : [_.value];
        for (let H = 0, j = Q.length; H < j; H++) {
          const V = Q[H], J = g(V), G = b % S, te = G % J.boundary, le = G + te;
          b += te, le !== 0 && S - le < J.storage && (b += S - le), _.__data = new Float32Array(J.storage / Float32Array.BYTES_PER_ELEMENT), _.__offset = b, b += J.storage;
        }
      }
    }
    const I = b % S;
    return I > 0 && (b += S - I), v.__size = b, v.__cache = {}, this;
  }
  function g(v) {
    const E = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof v == "number" || typeof v == "boolean" ? (E.boundary = 4, E.storage = 4) : v.isVector2 ? (E.boundary = 8, E.storage = 8) : v.isVector3 || v.isColor ? (E.boundary = 16, E.storage = 12) : v.isVector4 ? (E.boundary = 16, E.storage = 16) : v.isMatrix3 ? (E.boundary = 48, E.storage = 48) : v.isMatrix4 ? (E.boundary = 64, E.storage = 64) : v.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", v), E;
  }
  function f(v) {
    const E = v.target;
    E.removeEventListener("dispose", f);
    const b = a.indexOf(E.__bindingPointIndex);
    a.splice(b, 1), i.deleteBuffer(s[E.id]), delete s[E.id], delete r[E.id];
  }
  function p() {
    for (const v in s)
      i.deleteBuffer(s[v]);
    a = [], s = {}, r = {};
  }
  return {
    bind: l,
    update: c,
    dispose: p
  };
}
class Kb {
  constructor(e = {}) {
    const {
      canvas: t = Yd(),
      context: n = null,
      depth: s = !0,
      stencil: r = !1,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: u = !1,
      reverseDepthBuffer: d = !1
    } = e;
    this.isWebGLRenderer = !0;
    let A;
    if (n !== null) {
      if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      A = n.getContextAttributes().alpha;
    } else
      A = a;
    const m = new Uint32Array(4), g = new Int32Array(4);
    let f = null, p = null;
    const v = [], E = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Rt, this.toneMapping = 0, this.toneMappingExposure = 1;
    const b = this;
    let S = !1, I = 0, B = 0, R = null, w = -1, C = null;
    const D = new $e(), _ = new $e();
    let Q = null;
    const H = new we(0);
    let j = 0, V = t.width, J = t.height, G = 1, te = null, le = null;
    const me = new $e(0, 0, V, J), Re = new $e(0, 0, V, J);
    let Ge = !1;
    const q = new Fo();
    let ne = !1, ge = !1;
    this.transmissionResolutionScale = 1;
    const ae = new Pe(), Me = new Pe(), Ze = new T(), Se = new $e(), vt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let pt = !1;
    function He() {
      return R === null ? G : 1;
    }
    let P = n;
    function tn(y, F) {
      return t.getContext(y, F);
    }
    try {
      const y = {
        alpha: !0,
        depth: s,
        stencil: r,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: u
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${To}`), t.addEventListener("webglcontextlost", X, !1), t.addEventListener("webglcontextrestored", he, !1), t.addEventListener("webglcontextcreationerror", ce, !1), P === null) {
        const F = "webgl2";
        if (P = tn(F, y), P === null)
          throw tn(F) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (y) {
      throw console.error("THREE.WebGLRenderer: " + y.message), y;
    }
    let Ve, ze, Ee, ht, ve, M, x, U, K, Z, W, be, oe, de, Ye, ee, pe, ye, Be, Ae, qe, Ne, lt, L;
    function se() {
      Ve = new sg(P), Ve.init(), Ne = new Ob(P, Ve), ze = new Zm(P, Ve, e, Ne), Ee = new kb(P, Ve), ze.reverseDepthBuffer && d && Ee.buffers.depth.setReversed(!0), ht = new og(P), ve = new Ib(), M = new _b(P, Ve, Ee, ve, ze, Ne, ht), x = new eg(b), U = new ig(b), K = new pA(P), lt = new jm(P, K), Z = new rg(P, K, ht, lt), W = new cg(P, Z, K, ht), Be = new lg(P, ze, M), ee = new $m(ve), be = new yb(b, x, U, Ve, ze, lt, ee), oe = new Wb(b, ve), de = new Sb(), Ye = new Lb(Ve), ye = new Xm(b, x, U, Ee, W, A, l), pe = new Ub(b, W, ze), L = new Yb(P, ht, ze, Ee), Ae = new Jm(P, Ve, ht), qe = new ag(P, Ve, ht), ht.programs = be.programs, b.capabilities = ze, b.extensions = Ve, b.properties = ve, b.renderLists = de, b.shadowMap = pe, b.state = Ee, b.info = ht;
    }
    se();
    const z = new zb(b, P);
    this.xr = z, this.getContext = function() {
      return P;
    }, this.getContextAttributes = function() {
      return P.getContextAttributes();
    }, this.forceContextLoss = function() {
      const y = Ve.get("WEBGL_lose_context");
      y && y.loseContext();
    }, this.forceContextRestore = function() {
      const y = Ve.get("WEBGL_lose_context");
      y && y.restoreContext();
    }, this.getPixelRatio = function() {
      return G;
    }, this.setPixelRatio = function(y) {
      y !== void 0 && (G = y, this.setSize(V, J, !1));
    }, this.getSize = function(y) {
      return y.set(V, J);
    }, this.setSize = function(y, F, k = !0) {
      if (z.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      V = y, J = F, t.width = Math.floor(y * G), t.height = Math.floor(F * G), k === !0 && (t.style.width = y + "px", t.style.height = F + "px"), this.setViewport(0, 0, y, F);
    }, this.getDrawingBufferSize = function(y) {
      return y.set(V * G, J * G).floor();
    }, this.setDrawingBufferSize = function(y, F, k) {
      V = y, J = F, G = k, t.width = Math.floor(y * k), t.height = Math.floor(F * k), this.setViewport(0, 0, y, F);
    }, this.getCurrentViewport = function(y) {
      return y.copy(D);
    }, this.getViewport = function(y) {
      return y.copy(me);
    }, this.setViewport = function(y, F, k, O) {
      y.isVector4 ? me.set(y.x, y.y, y.z, y.w) : me.set(y, F, k, O), Ee.viewport(D.copy(me).multiplyScalar(G).round());
    }, this.getScissor = function(y) {
      return y.copy(Re);
    }, this.setScissor = function(y, F, k, O) {
      y.isVector4 ? Re.set(y.x, y.y, y.z, y.w) : Re.set(y, F, k, O), Ee.scissor(_.copy(Re).multiplyScalar(G).round());
    }, this.getScissorTest = function() {
      return Ge;
    }, this.setScissorTest = function(y) {
      Ee.setScissorTest(Ge = y);
    }, this.setOpaqueSort = function(y) {
      te = y;
    }, this.setTransparentSort = function(y) {
      le = y;
    }, this.getClearColor = function(y) {
      return y.copy(ye.getClearColor());
    }, this.setClearColor = function() {
      ye.setClearColor.apply(ye, arguments);
    }, this.getClearAlpha = function() {
      return ye.getClearAlpha();
    }, this.setClearAlpha = function() {
      ye.setClearAlpha.apply(ye, arguments);
    }, this.clear = function(y = !0, F = !0, k = !0) {
      let O = 0;
      if (y) {
        let N = !1;
        if (R !== null) {
          const $ = R.texture.format;
          N = $ === 1033 || $ === 1031 || $ === 1029;
        }
        if (N) {
          const $ = R.texture.type, re = $ === 1009 || $ === 1014 || $ === 1012 || $ === 1020 || $ === 1017 || $ === 1018, ue = ye.getClearColor(), fe = ye.getClearAlpha(), Te = ue.r, De = ue.g, Ce = ue.b;
          re ? (m[0] = Te, m[1] = De, m[2] = Ce, m[3] = fe, P.clearBufferuiv(P.COLOR, 0, m)) : (g[0] = Te, g[1] = De, g[2] = Ce, g[3] = fe, P.clearBufferiv(P.COLOR, 0, g));
        } else
          O |= P.COLOR_BUFFER_BIT;
      }
      F && (O |= P.DEPTH_BUFFER_BIT), k && (O |= P.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), P.clear(O);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", X, !1), t.removeEventListener("webglcontextrestored", he, !1), t.removeEventListener("webglcontextcreationerror", ce, !1), ye.dispose(), de.dispose(), Ye.dispose(), ve.dispose(), x.dispose(), U.dispose(), W.dispose(), lt.dispose(), L.dispose(), be.dispose(), z.dispose(), z.removeEventListener("sessionstart", Il), z.removeEventListener("sessionend", Ml), fi.stop();
    };
    function X(y) {
      y.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), S = !0;
    }
    function he() {
      console.log("THREE.WebGLRenderer: Context Restored."), S = !1;
      const y = ht.autoReset, F = pe.enabled, k = pe.autoUpdate, O = pe.needsUpdate, N = pe.type;
      se(), ht.autoReset = y, pe.enabled = F, pe.autoUpdate = k, pe.needsUpdate = O, pe.type = N;
    }
    function ce(y) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", y.statusMessage);
    }
    function Le(y) {
      const F = y.target;
      F.removeEventListener("dispose", Le), mt(F);
    }
    function mt(y) {
      Lt(y), ve.remove(y);
    }
    function Lt(y) {
      const F = ve.get(y).programs;
      F !== void 0 && (F.forEach(function(k) {
        be.releaseProgram(k);
      }), y.isShaderMaterial && be.releaseShaderCache(y));
    }
    this.renderBufferDirect = function(y, F, k, O, N, $) {
      F === null && (F = vt);
      const re = N.isMesh && N.matrixWorld.determinant() < 0, ue = Cd(y, F, k, O, N);
      Ee.setMaterial(O, re);
      let fe = k.index, Te = 1;
      if (O.wireframe === !0) {
        if (fe = Z.getWireframeAttribute(k), fe === void 0) return;
        Te = 2;
      }
      const De = k.drawRange, Ce = k.attributes.position;
      let Ke = De.start * Te, et = (De.start + De.count) * Te;
      $ !== null && (Ke = Math.max(Ke, $.start * Te), et = Math.min(et, ($.start + $.count) * Te)), fe !== null ? (Ke = Math.max(Ke, 0), et = Math.min(et, fe.count)) : Ce != null && (Ke = Math.max(Ke, 0), et = Math.min(et, Ce.count));
      const Et = et - Ke;
      if (Et < 0 || Et === 1 / 0) return;
      lt.setup(N, O, ue, k, fe);
      let gt, je = Ae;
      if (fe !== null && (gt = K.get(fe), je = qe, je.setIndex(gt)), N.isMesh)
        O.wireframe === !0 ? (Ee.setLineWidth(O.wireframeLinewidth * He()), je.setMode(P.LINES)) : je.setMode(P.TRIANGLES);
      else if (N.isLine) {
        let xe = O.linewidth;
        xe === void 0 && (xe = 1), Ee.setLineWidth(xe * He()), N.isLineSegments ? je.setMode(P.LINES) : N.isLineLoop ? je.setMode(P.LINE_LOOP) : je.setMode(P.LINE_STRIP);
      } else N.isPoints ? je.setMode(P.POINTS) : N.isSprite && je.setMode(P.TRIANGLES);
      if (N.isBatchedMesh)
        if (N._multiDrawInstances !== null)
          je.renderMultiDrawInstances(N._multiDrawStarts, N._multiDrawCounts, N._multiDrawCount, N._multiDrawInstances);
        else if (Ve.get("WEBGL_multi_draw"))
          je.renderMultiDraw(N._multiDrawStarts, N._multiDrawCounts, N._multiDrawCount);
        else {
          const xe = N._multiDrawStarts, Dt = N._multiDrawCounts, tt = N._multiDrawCount, An = fe ? K.get(fe).bytesPerElement : 1, Gi = ve.get(O).currentProgram.getUniforms();
          for (let jt = 0; jt < tt; jt++)
            Gi.setValue(P, "_gl_DrawID", jt), je.render(xe[jt] / An, Dt[jt]);
        }
      else if (N.isInstancedMesh)
        je.renderInstances(Ke, Et, N.count);
      else if (k.isInstancedBufferGeometry) {
        const xe = k._maxInstanceCount !== void 0 ? k._maxInstanceCount : 1 / 0, Dt = Math.min(k.instanceCount, xe);
        je.renderInstances(Ke, Et, Dt);
      } else
        je.render(Ke, Et);
    };
    function it(y, F, k) {
      y.transparent === !0 && y.side === 2 && y.forceSinglePass === !1 ? (y.side = 1, y.needsUpdate = !0, pr(y, F, k), y.side = 0, y.needsUpdate = !0, pr(y, F, k), y.side = 2) : pr(y, F, k);
    }
    this.compile = function(y, F, k = null) {
      k === null && (k = y), p = Ye.get(k), p.init(F), E.push(p), k.traverseVisible(function(N) {
        N.isLight && N.layers.test(F.layers) && (p.pushLight(N), N.castShadow && p.pushShadow(N));
      }), y !== k && y.traverseVisible(function(N) {
        N.isLight && N.layers.test(F.layers) && (p.pushLight(N), N.castShadow && p.pushShadow(N));
      }), p.setupLights();
      const O = /* @__PURE__ */ new Set();
      return y.traverse(function(N) {
        if (!(N.isMesh || N.isPoints || N.isLine || N.isSprite))
          return;
        const $ = N.material;
        if ($)
          if (Array.isArray($))
            for (let re = 0; re < $.length; re++) {
              const ue = $[re];
              it(ue, k, N), O.add(ue);
            }
          else
            it($, k, N), O.add($);
      }), E.pop(), p = null, O;
    }, this.compileAsync = function(y, F, k = null) {
      const O = this.compile(y, F, k);
      return new Promise((N) => {
        function $() {
          if (O.forEach(function(re) {
            ve.get(re).currentProgram.isReady() && O.delete(re);
          }), O.size === 0) {
            N(y);
            return;
          }
          setTimeout($, 10);
        }
        Ve.get("KHR_parallel_shader_compile") !== null ? $() : setTimeout($, 10);
      });
    };
    let pn = null;
    function Pn(y) {
      pn && pn(y);
    }
    function Il() {
      fi.stop();
    }
    function Ml() {
      fi.start();
    }
    const fi = new Yh();
    fi.setAnimationLoop(Pn), typeof self < "u" && fi.setContext(self), this.setAnimationLoop = function(y) {
      pn = y, z.setAnimationLoop(y), y === null ? fi.stop() : fi.start();
    }, z.addEventListener("sessionstart", Il), z.addEventListener("sessionend", Ml), this.render = function(y, F) {
      if (F !== void 0 && F.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (S === !0) return;
      if (y.matrixWorldAutoUpdate === !0 && y.updateMatrixWorld(), F.parent === null && F.matrixWorldAutoUpdate === !0 && F.updateMatrixWorld(), z.enabled === !0 && z.isPresenting === !0 && (z.cameraAutoUpdate === !0 && z.updateCamera(F), F = z.getCamera()), y.isScene === !0 && y.onBeforeRender(b, y, F, R), p = Ye.get(y, E.length), p.init(F), E.push(p), Me.multiplyMatrices(F.projectionMatrix, F.matrixWorldInverse), q.setFromProjectionMatrix(Me), ge = this.localClippingEnabled, ne = ee.init(this.clippingPlanes, ge), f = de.get(y, v.length), f.init(), v.push(f), z.enabled === !0 && z.isPresenting === !0) {
        const $ = b.xr.getDepthSensingMesh();
        $ !== null && pa($, F, -1 / 0, b.sortObjects);
      }
      pa(y, F, 0, b.sortObjects), f.finish(), b.sortObjects === !0 && f.sort(te, le), pt = z.enabled === !1 || z.isPresenting === !1 || z.hasDepthSensing() === !1, pt && ye.addToRenderList(f, y), this.info.render.frame++, ne === !0 && ee.beginShadows();
      const k = p.state.shadowsArray;
      pe.render(k, y, F), ne === !0 && ee.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const O = f.opaque, N = f.transmissive;
      if (p.setupLights(), F.isArrayCamera) {
        const $ = F.cameras;
        if (N.length > 0)
          for (let re = 0, ue = $.length; re < ue; re++) {
            const fe = $[re];
            Bl(O, N, y, fe);
          }
        pt && ye.render(y);
        for (let re = 0, ue = $.length; re < ue; re++) {
          const fe = $[re];
          Sl(f, y, fe, fe.viewport);
        }
      } else
        N.length > 0 && Bl(O, N, y, F), pt && ye.render(y), Sl(f, y, F);
      R !== null && B === 0 && (M.updateMultisampleRenderTarget(R), M.updateRenderTargetMipmap(R)), y.isScene === !0 && y.onAfterRender(b, y, F), lt.resetDefaultState(), w = -1, C = null, E.pop(), E.length > 0 ? (p = E[E.length - 1], ne === !0 && ee.setGlobalState(b.clippingPlanes, p.state.camera)) : p = null, v.pop(), v.length > 0 ? f = v[v.length - 1] : f = null;
    };
    function pa(y, F, k, O) {
      if (y.visible === !1) return;
      if (y.layers.test(F.layers)) {
        if (y.isGroup)
          k = y.renderOrder;
        else if (y.isLOD)
          y.autoUpdate === !0 && y.update(F);
        else if (y.isLight)
          p.pushLight(y), y.castShadow && p.pushShadow(y);
        else if (y.isSprite) {
          if (!y.frustumCulled || q.intersectsSprite(y)) {
            O && Se.setFromMatrixPosition(y.matrixWorld).applyMatrix4(Me);
            const re = W.update(y), ue = y.material;
            ue.visible && f.push(y, re, ue, k, Se.z, null);
          }
        } else if ((y.isMesh || y.isLine || y.isPoints) && (!y.frustumCulled || q.intersectsObject(y))) {
          const re = W.update(y), ue = y.material;
          if (O && (y.boundingSphere !== void 0 ? (y.boundingSphere === null && y.computeBoundingSphere(), Se.copy(y.boundingSphere.center)) : (re.boundingSphere === null && re.computeBoundingSphere(), Se.copy(re.boundingSphere.center)), Se.applyMatrix4(y.matrixWorld).applyMatrix4(Me)), Array.isArray(ue)) {
            const fe = re.groups;
            for (let Te = 0, De = fe.length; Te < De; Te++) {
              const Ce = fe[Te], Ke = ue[Ce.materialIndex];
              Ke && Ke.visible && f.push(y, re, Ke, k, Se.z, Ce);
            }
          } else ue.visible && f.push(y, re, ue, k, Se.z, null);
        }
      }
      const $ = y.children;
      for (let re = 0, ue = $.length; re < ue; re++)
        pa($[re], F, k, O);
    }
    function Sl(y, F, k, O) {
      const N = y.opaque, $ = y.transmissive, re = y.transparent;
      p.setupLightsView(k), ne === !0 && ee.setGlobalState(b.clippingPlanes, k), O && Ee.viewport(D.copy(O)), N.length > 0 && dr(N, F, k), $.length > 0 && dr($, F, k), re.length > 0 && dr(re, F, k), Ee.buffers.depth.setTest(!0), Ee.buffers.depth.setMask(!0), Ee.buffers.color.setMask(!0), Ee.setPolygonOffset(!1);
    }
    function Bl(y, F, k, O) {
      if ((k.isScene === !0 ? k.overrideMaterial : null) !== null)
        return;
      p.state.transmissionRenderTarget[O.id] === void 0 && (p.state.transmissionRenderTarget[O.id] = new Kn(1, 1, {
        generateMipmaps: !0,
        type: Ve.has("EXT_color_buffer_half_float") || Ve.has("EXT_color_buffer_float") ? 1016 : 1009,
        minFilter: 1008,
        samples: 4,
        stencilBuffer: r,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: We.workingColorSpace
      }));
      const $ = p.state.transmissionRenderTarget[O.id], re = O.viewport || D;
      $.setSize(re.z * b.transmissionResolutionScale, re.w * b.transmissionResolutionScale);
      const ue = b.getRenderTarget();
      b.setRenderTarget($), b.getClearColor(H), j = b.getClearAlpha(), j < 1 && b.setClearColor(16777215, 0.5), b.clear(), pt && ye.render(k);
      const fe = b.toneMapping;
      b.toneMapping = 0;
      const Te = O.viewport;
      if (O.viewport !== void 0 && (O.viewport = void 0), p.setupLightsView(O), ne === !0 && ee.setGlobalState(b.clippingPlanes, O), dr(y, k, O), M.updateMultisampleRenderTarget($), M.updateRenderTargetMipmap($), Ve.has("WEBGL_multisampled_render_to_texture") === !1) {
        let De = !1;
        for (let Ce = 0, Ke = F.length; Ce < Ke; Ce++) {
          const et = F[Ce], Et = et.object, gt = et.geometry, je = et.material, xe = et.group;
          if (je.side === 2 && Et.layers.test(O.layers)) {
            const Dt = je.side;
            je.side = 1, je.needsUpdate = !0, Tl(Et, k, O, gt, je, xe), je.side = Dt, je.needsUpdate = !0, De = !0;
          }
        }
        De === !0 && (M.updateMultisampleRenderTarget($), M.updateRenderTargetMipmap($));
      }
      b.setRenderTarget(ue), b.setClearColor(H, j), Te !== void 0 && (O.viewport = Te), b.toneMapping = fe;
    }
    function dr(y, F, k) {
      const O = F.isScene === !0 ? F.overrideMaterial : null;
      for (let N = 0, $ = y.length; N < $; N++) {
        const re = y[N], ue = re.object, fe = re.geometry, Te = O === null ? re.material : O, De = re.group;
        ue.layers.test(k.layers) && Tl(ue, F, k, fe, Te, De);
      }
    }
    function Tl(y, F, k, O, N, $) {
      y.onBeforeRender(b, F, k, O, N, $), y.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse, y.matrixWorld), y.normalMatrix.getNormalMatrix(y.modelViewMatrix), N.onBeforeRender(b, F, k, O, y, $), N.transparent === !0 && N.side === 2 && N.forceSinglePass === !1 ? (N.side = 1, N.needsUpdate = !0, b.renderBufferDirect(k, F, O, N, y, $), N.side = 0, N.needsUpdate = !0, b.renderBufferDirect(k, F, O, N, y, $), N.side = 2) : b.renderBufferDirect(k, F, O, N, y, $), y.onAfterRender(b, F, k, O, N, $);
    }
    function pr(y, F, k) {
      F.isScene !== !0 && (F = vt);
      const O = ve.get(y), N = p.state.lights, $ = p.state.shadowsArray, re = N.state.version, ue = be.getParameters(y, N.state, $, F, k), fe = be.getProgramCacheKey(ue);
      let Te = O.programs;
      O.environment = y.isMeshStandardMaterial ? F.environment : null, O.fog = F.fog, O.envMap = (y.isMeshStandardMaterial ? U : x).get(y.envMap || O.environment), O.envMapRotation = O.environment !== null && y.envMap === null ? F.environmentRotation : y.envMapRotation, Te === void 0 && (y.addEventListener("dispose", Le), Te = /* @__PURE__ */ new Map(), O.programs = Te);
      let De = Te.get(fe);
      if (De !== void 0) {
        if (O.currentProgram === De && O.lightsStateVersion === re)
          return Dl(y, ue), De;
      } else
        ue.uniforms = be.getUniforms(y), y.onBeforeCompile(ue, b), De = be.acquireProgram(ue, fe), Te.set(fe, De), O.uniforms = ue.uniforms;
      const Ce = O.uniforms;
      return (!y.isShaderMaterial && !y.isRawShaderMaterial || y.clipping === !0) && (Ce.clippingPlanes = ee.uniform), Dl(y, ue), O.needsLights = wd(y), O.lightsStateVersion = re, O.needsLights && (Ce.ambientLightColor.value = N.state.ambient, Ce.lightProbe.value = N.state.probe, Ce.directionalLights.value = N.state.directional, Ce.directionalLightShadows.value = N.state.directionalShadow, Ce.spotLights.value = N.state.spot, Ce.spotLightShadows.value = N.state.spotShadow, Ce.rectAreaLights.value = N.state.rectArea, Ce.ltc_1.value = N.state.rectAreaLTC1, Ce.ltc_2.value = N.state.rectAreaLTC2, Ce.pointLights.value = N.state.point, Ce.pointLightShadows.value = N.state.pointShadow, Ce.hemisphereLights.value = N.state.hemi, Ce.directionalShadowMap.value = N.state.directionalShadowMap, Ce.directionalShadowMatrix.value = N.state.directionalShadowMatrix, Ce.spotShadowMap.value = N.state.spotShadowMap, Ce.spotLightMatrix.value = N.state.spotLightMatrix, Ce.spotLightMap.value = N.state.spotLightMap, Ce.pointShadowMap.value = N.state.pointShadowMap, Ce.pointShadowMatrix.value = N.state.pointShadowMatrix), O.currentProgram = De, O.uniformsList = null, De;
    }
    function Rl(y) {
      if (y.uniformsList === null) {
        const F = y.currentProgram.getUniforms();
        y.uniformsList = qr.seqWithValue(F.seq, y.uniforms);
      }
      return y.uniformsList;
    }
    function Dl(y, F) {
      const k = ve.get(y);
      k.outputColorSpace = F.outputColorSpace, k.batching = F.batching, k.batchingColor = F.batchingColor, k.instancing = F.instancing, k.instancingColor = F.instancingColor, k.instancingMorph = F.instancingMorph, k.skinning = F.skinning, k.morphTargets = F.morphTargets, k.morphNormals = F.morphNormals, k.morphColors = F.morphColors, k.morphTargetsCount = F.morphTargetsCount, k.numClippingPlanes = F.numClippingPlanes, k.numIntersection = F.numClipIntersection, k.vertexAlphas = F.vertexAlphas, k.vertexTangents = F.vertexTangents, k.toneMapping = F.toneMapping;
    }
    function Cd(y, F, k, O, N) {
      F.isScene !== !0 && (F = vt), M.resetTextureUnits();
      const $ = F.fog, re = O.isMeshStandardMaterial ? F.environment : null, ue = R === null ? b.outputColorSpace : R.isXRRenderTarget === !0 ? R.texture.colorSpace : Ut, fe = (O.isMeshStandardMaterial ? U : x).get(O.envMap || re), Te = O.vertexColors === !0 && !!k.attributes.color && k.attributes.color.itemSize === 4, De = !!k.attributes.tangent && (!!O.normalMap || O.anisotropy > 0), Ce = !!k.morphAttributes.position, Ke = !!k.morphAttributes.normal, et = !!k.morphAttributes.color;
      let Et = 0;
      O.toneMapped && (R === null || R.isXRRenderTarget === !0) && (Et = b.toneMapping);
      const gt = k.morphAttributes.position || k.morphAttributes.normal || k.morphAttributes.color, je = gt !== void 0 ? gt.length : 0, xe = ve.get(O), Dt = p.state.lights;
      if (ne === !0 && (ge === !0 || y !== C)) {
        const Qt = y === C && O.id === w;
        ee.setState(O, y, Qt);
      }
      let tt = !1;
      O.version === xe.__version ? (xe.needsLights && xe.lightsStateVersion !== Dt.state.version || xe.outputColorSpace !== ue || N.isBatchedMesh && xe.batching === !1 || !N.isBatchedMesh && xe.batching === !0 || N.isBatchedMesh && xe.batchingColor === !0 && N.colorTexture === null || N.isBatchedMesh && xe.batchingColor === !1 && N.colorTexture !== null || N.isInstancedMesh && xe.instancing === !1 || !N.isInstancedMesh && xe.instancing === !0 || N.isSkinnedMesh && xe.skinning === !1 || !N.isSkinnedMesh && xe.skinning === !0 || N.isInstancedMesh && xe.instancingColor === !0 && N.instanceColor === null || N.isInstancedMesh && xe.instancingColor === !1 && N.instanceColor !== null || N.isInstancedMesh && xe.instancingMorph === !0 && N.morphTexture === null || N.isInstancedMesh && xe.instancingMorph === !1 && N.morphTexture !== null || xe.envMap !== fe || O.fog === !0 && xe.fog !== $ || xe.numClippingPlanes !== void 0 && (xe.numClippingPlanes !== ee.numPlanes || xe.numIntersection !== ee.numIntersection) || xe.vertexAlphas !== Te || xe.vertexTangents !== De || xe.morphTargets !== Ce || xe.morphNormals !== Ke || xe.morphColors !== et || xe.toneMapping !== Et || xe.morphTargetsCount !== je) && (tt = !0) : (tt = !0, xe.__version = O.version);
      let An = xe.currentProgram;
      tt === !0 && (An = pr(O, F, N));
      let Gi = !1, jt = !1, Ms = !1;
      const ut = An.getUniforms(), nn = xe.uniforms;
      if (Ee.useProgram(An.program) && (Gi = !0, jt = !0, Ms = !0), O.id !== w && (w = O.id, jt = !0), Gi || C !== y) {
        Ee.buffers.depth.getReversed() ? (ae.copy(y.projectionMatrix), Xd(ae), jd(ae), ut.setValue(P, "projectionMatrix", ae)) : ut.setValue(P, "projectionMatrix", y.projectionMatrix), ut.setValue(P, "viewMatrix", y.matrixWorldInverse);
        const qt = ut.map.cameraPosition;
        qt !== void 0 && qt.setValue(P, Ze.setFromMatrixPosition(y.matrixWorld)), ze.logarithmicDepthBuffer && ut.setValue(
          P,
          "logDepthBufFC",
          2 / (Math.log(y.far + 1) / Math.LN2)
        ), (O.isMeshPhongMaterial || O.isMeshToonMaterial || O.isMeshLambertMaterial || O.isMeshBasicMaterial || O.isMeshStandardMaterial || O.isShaderMaterial) && ut.setValue(P, "isOrthographic", y.isOrthographicCamera === !0), C !== y && (C = y, jt = !0, Ms = !0);
      }
      if (N.isSkinnedMesh) {
        ut.setOptional(P, N, "bindMatrix"), ut.setOptional(P, N, "bindMatrixInverse");
        const Qt = N.skeleton;
        Qt && (Qt.boneTexture === null && Qt.computeBoneTexture(), ut.setValue(P, "boneTexture", Qt.boneTexture, M));
      }
      N.isBatchedMesh && (ut.setOptional(P, N, "batchingTexture"), ut.setValue(P, "batchingTexture", N._matricesTexture, M), ut.setOptional(P, N, "batchingIdTexture"), ut.setValue(P, "batchingIdTexture", N._indirectTexture, M), ut.setOptional(P, N, "batchingColorTexture"), N._colorsTexture !== null && ut.setValue(P, "batchingColorTexture", N._colorsTexture, M));
      const sn = k.morphAttributes;
      if ((sn.position !== void 0 || sn.normal !== void 0 || sn.color !== void 0) && Be.update(N, k, An), (jt || xe.receiveShadow !== N.receiveShadow) && (xe.receiveShadow = N.receiveShadow, ut.setValue(P, "receiveShadow", N.receiveShadow)), O.isMeshGouraudMaterial && O.envMap !== null && (nn.envMap.value = fe, nn.flipEnvMap.value = fe.isCubeTexture && fe.isRenderTargetTexture === !1 ? -1 : 1), O.isMeshStandardMaterial && O.envMap === null && F.environment !== null && (nn.envMapIntensity.value = F.environmentIntensity), jt && (ut.setValue(P, "toneMappingExposure", b.toneMappingExposure), xe.needsLights && xd(nn, Ms), $ && O.fog === !0 && oe.refreshFogUniforms(nn, $), oe.refreshMaterialUniforms(nn, O, G, J, p.state.transmissionRenderTarget[y.id]), qr.upload(P, Rl(xe), nn, M)), O.isShaderMaterial && O.uniformsNeedUpdate === !0 && (qr.upload(P, Rl(xe), nn, M), O.uniformsNeedUpdate = !1), O.isSpriteMaterial && ut.setValue(P, "center", N.center), ut.setValue(P, "modelViewMatrix", N.modelViewMatrix), ut.setValue(P, "normalMatrix", N.normalMatrix), ut.setValue(P, "modelMatrix", N.matrixWorld), O.isShaderMaterial || O.isRawShaderMaterial) {
        const Qt = O.uniformsGroups;
        for (let qt = 0, Aa = Qt.length; qt < Aa; qt++) {
          const mi = Qt[qt];
          L.update(mi, An), L.bind(mi, An);
        }
      }
      return An;
    }
    function xd(y, F) {
      y.ambientLightColor.needsUpdate = F, y.lightProbe.needsUpdate = F, y.directionalLights.needsUpdate = F, y.directionalLightShadows.needsUpdate = F, y.pointLights.needsUpdate = F, y.pointLightShadows.needsUpdate = F, y.spotLights.needsUpdate = F, y.spotLightShadows.needsUpdate = F, y.rectAreaLights.needsUpdate = F, y.hemisphereLights.needsUpdate = F;
    }
    function wd(y) {
      return y.isMeshLambertMaterial || y.isMeshToonMaterial || y.isMeshPhongMaterial || y.isMeshStandardMaterial || y.isShadowMaterial || y.isShaderMaterial && y.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return I;
    }, this.getActiveMipmapLevel = function() {
      return B;
    }, this.getRenderTarget = function() {
      return R;
    }, this.setRenderTargetTextures = function(y, F, k) {
      ve.get(y.texture).__webglTexture = F, ve.get(y.depthTexture).__webglTexture = k;
      const O = ve.get(y);
      O.__hasExternalTextures = !0, O.__autoAllocateDepthBuffer = k === void 0, O.__autoAllocateDepthBuffer || Ve.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), O.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(y, F) {
      const k = ve.get(y);
      k.__webglFramebuffer = F, k.__useDefaultFramebuffer = F === void 0;
    };
    const yd = P.createFramebuffer();
    this.setRenderTarget = function(y, F = 0, k = 0) {
      R = y, I = F, B = k;
      let O = !0, N = null, $ = !1, re = !1;
      if (y) {
        const fe = ve.get(y);
        if (fe.__useDefaultFramebuffer !== void 0)
          Ee.bindFramebuffer(P.FRAMEBUFFER, null), O = !1;
        else if (fe.__webglFramebuffer === void 0)
          M.setupRenderTarget(y);
        else if (fe.__hasExternalTextures)
          M.rebindTextures(y, ve.get(y.texture).__webglTexture, ve.get(y.depthTexture).__webglTexture);
        else if (y.depthBuffer) {
          const Ce = y.depthTexture;
          if (fe.__boundDepthTexture !== Ce) {
            if (Ce !== null && ve.has(Ce) && (y.width !== Ce.image.width || y.height !== Ce.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            M.setupDepthRenderbuffer(y);
          }
        }
        const Te = y.texture;
        (Te.isData3DTexture || Te.isDataArrayTexture || Te.isCompressedArrayTexture) && (re = !0);
        const De = ve.get(y).__webglFramebuffer;
        y.isWebGLCubeRenderTarget ? (Array.isArray(De[F]) ? N = De[F][k] : N = De[F], $ = !0) : y.samples > 0 && M.useMultisampledRTT(y) === !1 ? N = ve.get(y).__webglMultisampledFramebuffer : Array.isArray(De) ? N = De[k] : N = De, D.copy(y.viewport), _.copy(y.scissor), Q = y.scissorTest;
      } else
        D.copy(me).multiplyScalar(G).floor(), _.copy(Re).multiplyScalar(G).floor(), Q = Ge;
      if (k !== 0 && (N = yd), Ee.bindFramebuffer(P.FRAMEBUFFER, N) && O && Ee.drawBuffers(y, N), Ee.viewport(D), Ee.scissor(_), Ee.setScissorTest(Q), $) {
        const fe = ve.get(y.texture);
        P.framebufferTexture2D(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_CUBE_MAP_POSITIVE_X + F, fe.__webglTexture, k);
      } else if (re) {
        const fe = ve.get(y.texture), Te = F;
        P.framebufferTextureLayer(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, fe.__webglTexture, k, Te);
      } else if (y !== null && k !== 0) {
        const fe = ve.get(y.texture);
        P.framebufferTexture2D(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, fe.__webglTexture, k);
      }
      w = -1;
    }, this.readRenderTargetPixels = function(y, F, k, O, N, $, re) {
      if (!(y && y.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let ue = ve.get(y).__webglFramebuffer;
      if (y.isWebGLCubeRenderTarget && re !== void 0 && (ue = ue[re]), ue) {
        Ee.bindFramebuffer(P.FRAMEBUFFER, ue);
        try {
          const fe = y.texture, Te = fe.format, De = fe.type;
          if (!ze.textureFormatReadable(Te)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!ze.textureTypeReadable(De)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          F >= 0 && F <= y.width - O && k >= 0 && k <= y.height - N && P.readPixels(F, k, O, N, Ne.convert(Te), Ne.convert(De), $);
        } finally {
          const fe = R !== null ? ve.get(R).__webglFramebuffer : null;
          Ee.bindFramebuffer(P.FRAMEBUFFER, fe);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(y, F, k, O, N, $, re) {
      if (!(y && y.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let ue = ve.get(y).__webglFramebuffer;
      if (y.isWebGLCubeRenderTarget && re !== void 0 && (ue = ue[re]), ue) {
        const fe = y.texture, Te = fe.format, De = fe.type;
        if (!ze.textureFormatReadable(Te))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!ze.textureTypeReadable(De))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (F >= 0 && F <= y.width - O && k >= 0 && k <= y.height - N) {
          Ee.bindFramebuffer(P.FRAMEBUFFER, ue);
          const Ce = P.createBuffer();
          P.bindBuffer(P.PIXEL_PACK_BUFFER, Ce), P.bufferData(P.PIXEL_PACK_BUFFER, $.byteLength, P.STREAM_READ), P.readPixels(F, k, O, N, Ne.convert(Te), Ne.convert(De), 0);
          const Ke = R !== null ? ve.get(R).__webglFramebuffer : null;
          Ee.bindFramebuffer(P.FRAMEBUFFER, Ke);
          const et = P.fenceSync(P.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return P.flush(), await Kd(P, et, 4), P.bindBuffer(P.PIXEL_PACK_BUFFER, Ce), P.getBufferSubData(P.PIXEL_PACK_BUFFER, 0, $), P.deleteBuffer(Ce), P.deleteSync(et), $;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(y, F = null, k = 0) {
      y.isTexture !== !0 && (as("WebGLRenderer: copyFramebufferToTexture function signature has changed."), F = arguments[0] || null, y = arguments[1]);
      const O = Math.pow(2, -k), N = Math.floor(y.image.width * O), $ = Math.floor(y.image.height * O), re = F !== null ? F.x : 0, ue = F !== null ? F.y : 0;
      M.setTexture2D(y, 0), P.copyTexSubImage2D(P.TEXTURE_2D, k, 0, 0, re, ue, N, $), Ee.unbindTexture();
    };
    const Id = P.createFramebuffer(), Md = P.createFramebuffer();
    this.copyTextureToTexture = function(y, F, k = null, O = null, N = 0, $ = null) {
      y.isTexture !== !0 && (as("WebGLRenderer: copyTextureToTexture function signature has changed."), O = arguments[0] || null, y = arguments[1], F = arguments[2], $ = arguments[3] || 0, k = null), $ === null && (N !== 0 ? (as("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), $ = N, N = 0) : $ = 0);
      let re, ue, fe, Te, De, Ce, Ke, et, Et;
      const gt = y.isCompressedTexture ? y.mipmaps[$] : y.image;
      if (k !== null)
        re = k.max.x - k.min.x, ue = k.max.y - k.min.y, fe = k.isBox3 ? k.max.z - k.min.z : 1, Te = k.min.x, De = k.min.y, Ce = k.isBox3 ? k.min.z : 0;
      else {
        const sn = Math.pow(2, -N);
        re = Math.floor(gt.width * sn), ue = Math.floor(gt.height * sn), y.isDataArrayTexture ? fe = gt.depth : y.isData3DTexture ? fe = Math.floor(gt.depth * sn) : fe = 1, Te = 0, De = 0, Ce = 0;
      }
      O !== null ? (Ke = O.x, et = O.y, Et = O.z) : (Ke = 0, et = 0, Et = 0);
      const je = Ne.convert(F.format), xe = Ne.convert(F.type);
      let Dt;
      F.isData3DTexture ? (M.setTexture3D(F, 0), Dt = P.TEXTURE_3D) : F.isDataArrayTexture || F.isCompressedArrayTexture ? (M.setTexture2DArray(F, 0), Dt = P.TEXTURE_2D_ARRAY) : (M.setTexture2D(F, 0), Dt = P.TEXTURE_2D), P.pixelStorei(P.UNPACK_FLIP_Y_WEBGL, F.flipY), P.pixelStorei(P.UNPACK_PREMULTIPLY_ALPHA_WEBGL, F.premultiplyAlpha), P.pixelStorei(P.UNPACK_ALIGNMENT, F.unpackAlignment);
      const tt = P.getParameter(P.UNPACK_ROW_LENGTH), An = P.getParameter(P.UNPACK_IMAGE_HEIGHT), Gi = P.getParameter(P.UNPACK_SKIP_PIXELS), jt = P.getParameter(P.UNPACK_SKIP_ROWS), Ms = P.getParameter(P.UNPACK_SKIP_IMAGES);
      P.pixelStorei(P.UNPACK_ROW_LENGTH, gt.width), P.pixelStorei(P.UNPACK_IMAGE_HEIGHT, gt.height), P.pixelStorei(P.UNPACK_SKIP_PIXELS, Te), P.pixelStorei(P.UNPACK_SKIP_ROWS, De), P.pixelStorei(P.UNPACK_SKIP_IMAGES, Ce);
      const ut = y.isDataArrayTexture || y.isData3DTexture, nn = F.isDataArrayTexture || F.isData3DTexture;
      if (y.isDepthTexture) {
        const sn = ve.get(y), Qt = ve.get(F), qt = ve.get(sn.__renderTarget), Aa = ve.get(Qt.__renderTarget);
        Ee.bindFramebuffer(P.READ_FRAMEBUFFER, qt.__webglFramebuffer), Ee.bindFramebuffer(P.DRAW_FRAMEBUFFER, Aa.__webglFramebuffer);
        for (let mi = 0; mi < fe; mi++)
          ut && (P.framebufferTextureLayer(P.READ_FRAMEBUFFER, P.COLOR_ATTACHMENT0, ve.get(y).__webglTexture, N, Ce + mi), P.framebufferTextureLayer(P.DRAW_FRAMEBUFFER, P.COLOR_ATTACHMENT0, ve.get(F).__webglTexture, $, Et + mi)), P.blitFramebuffer(Te, De, re, ue, Ke, et, re, ue, P.DEPTH_BUFFER_BIT, P.NEAREST);
        Ee.bindFramebuffer(P.READ_FRAMEBUFFER, null), Ee.bindFramebuffer(P.DRAW_FRAMEBUFFER, null);
      } else if (N !== 0 || y.isRenderTargetTexture || ve.has(y)) {
        const sn = ve.get(y), Qt = ve.get(F);
        Ee.bindFramebuffer(P.READ_FRAMEBUFFER, Id), Ee.bindFramebuffer(P.DRAW_FRAMEBUFFER, Md);
        for (let qt = 0; qt < fe; qt++)
          ut ? P.framebufferTextureLayer(P.READ_FRAMEBUFFER, P.COLOR_ATTACHMENT0, sn.__webglTexture, N, Ce + qt) : P.framebufferTexture2D(P.READ_FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, sn.__webglTexture, N), nn ? P.framebufferTextureLayer(P.DRAW_FRAMEBUFFER, P.COLOR_ATTACHMENT0, Qt.__webglTexture, $, Et + qt) : P.framebufferTexture2D(P.DRAW_FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, Qt.__webglTexture, $), N !== 0 ? P.blitFramebuffer(Te, De, re, ue, Ke, et, re, ue, P.COLOR_BUFFER_BIT, P.NEAREST) : nn ? P.copyTexSubImage3D(Dt, $, Ke, et, Et + qt, Te, De, re, ue) : P.copyTexSubImage2D(Dt, $, Ke, et, Te, De, re, ue);
        Ee.bindFramebuffer(P.READ_FRAMEBUFFER, null), Ee.bindFramebuffer(P.DRAW_FRAMEBUFFER, null);
      } else
        nn ? y.isDataTexture || y.isData3DTexture ? P.texSubImage3D(Dt, $, Ke, et, Et, re, ue, fe, je, xe, gt.data) : F.isCompressedArrayTexture ? P.compressedTexSubImage3D(Dt, $, Ke, et, Et, re, ue, fe, je, gt.data) : P.texSubImage3D(Dt, $, Ke, et, Et, re, ue, fe, je, xe, gt) : y.isDataTexture ? P.texSubImage2D(P.TEXTURE_2D, $, Ke, et, re, ue, je, xe, gt.data) : y.isCompressedTexture ? P.compressedTexSubImage2D(P.TEXTURE_2D, $, Ke, et, gt.width, gt.height, je, gt.data) : P.texSubImage2D(P.TEXTURE_2D, $, Ke, et, re, ue, je, xe, gt);
      P.pixelStorei(P.UNPACK_ROW_LENGTH, tt), P.pixelStorei(P.UNPACK_IMAGE_HEIGHT, An), P.pixelStorei(P.UNPACK_SKIP_PIXELS, Gi), P.pixelStorei(P.UNPACK_SKIP_ROWS, jt), P.pixelStorei(P.UNPACK_SKIP_IMAGES, Ms), $ === 0 && F.generateMipmaps && P.generateMipmap(Dt), Ee.unbindTexture();
    }, this.copyTextureToTexture3D = function(y, F, k = null, O = null, N = 0) {
      return y.isTexture !== !0 && (as("WebGLRenderer: copyTextureToTexture3D function signature has changed."), k = arguments[0] || null, O = arguments[1] || null, y = arguments[2], F = arguments[3], N = arguments[4] || 0), as('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(y, F, k, O, N);
    }, this.initRenderTarget = function(y) {
      ve.get(y).__webglFramebuffer === void 0 && M.setupRenderTarget(y);
    }, this.initTexture = function(y) {
      y.isCubeTexture ? M.setTextureCube(y, 0) : y.isData3DTexture ? M.setTexture3D(y, 0) : y.isDataArrayTexture || y.isCompressedArrayTexture ? M.setTexture2DArray(y, 0) : M.setTexture2D(y, 0), Ee.unbindTexture();
    }, this.resetState = function() {
      I = 0, B = 0, R = null, Ee.reset(), lt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return 2e3;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorspace = We._getDrawingBufferColorSpace(e), t.unpackColorSpace = We._getUnpackColorSpace();
  }
}
const Xb = 0, zc = 2, jb = 1, qc = 2, Jb = 0, Zb = 1, $b = 10, ev = 0, Zh = 9, $h = 15, eu = 16, tu = 22, nu = 37, iu = 43, su = 76, ru = 83, au = 97, ou = 100, lu = 103, cu = 109, hu = 165, uu = 166, Jo = 1000066e3;
class tv {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
}
class Ns {
  constructor(e, t, n, s) {
    this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = s, this._offset = 0;
  }
  _nextUint8() {
    const e = this._dataView.getUint8(this._offset);
    return this._offset += 1, e;
  }
  _nextUint16() {
    const e = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, e;
  }
  _nextUint32() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _nextUint64() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, e;
  }
  _nextInt32() {
    const e = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _nextUint8Array(e) {
    const t = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, e);
    return this._offset += e, t;
  }
  _skip(e) {
    return this._offset += e, this;
  }
  _scan(e, t) {
    t === void 0 && (t = 0);
    const n = this._offset;
    let s = 0;
    for (; this._dataView.getUint8(this._offset) !== t && s < e; ) s++, this._offset++;
    return s < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, s);
  }
}
const _t = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Wc(i) {
  return new TextDecoder().decode(i);
}
function nv(i) {
  const e = new Uint8Array(i.buffer, i.byteOffset, _t.length);
  if (e[0] !== _t[0] || e[1] !== _t[1] || e[2] !== _t[2] || e[3] !== _t[3] || e[4] !== _t[4] || e[5] !== _t[5] || e[6] !== _t[6] || e[7] !== _t[7] || e[8] !== _t[8] || e[9] !== _t[9] || e[10] !== _t[10] || e[11] !== _t[11]) throw new Error("Missing KTX 2.0 identifier.");
  const t = new tv(), n = 17 * Uint32Array.BYTES_PER_ELEMENT, s = new Ns(i, _t.length, n, !0);
  t.vkFormat = s._nextUint32(), t.typeSize = s._nextUint32(), t.pixelWidth = s._nextUint32(), t.pixelHeight = s._nextUint32(), t.pixelDepth = s._nextUint32(), t.layerCount = s._nextUint32(), t.faceCount = s._nextUint32();
  const r = s._nextUint32();
  t.supercompressionScheme = s._nextUint32();
  const a = s._nextUint32(), o = s._nextUint32(), l = s._nextUint32(), c = s._nextUint32(), h = s._nextUint64(), u = s._nextUint64(), d = new Ns(i, _t.length + n, 3 * r * 8, !0);
  for (let J = 0; J < r; J++) t.levels.push({ levelData: new Uint8Array(i.buffer, i.byteOffset + d._nextUint64(), d._nextUint64()), uncompressedByteLength: d._nextUint64() });
  const A = new Ns(i, a, o, !0), m = { vendorId: A._skip(4)._nextUint16(), descriptorType: A._nextUint16(), versionNumber: A._nextUint16(), descriptorBlockSize: A._nextUint16(), colorModel: A._nextUint8(), colorPrimaries: A._nextUint8(), transferFunction: A._nextUint8(), flags: A._nextUint8(), texelBlockDimension: [A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8()], bytesPlane: [A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8()], samples: [] }, g = (m.descriptorBlockSize / 4 - 6) / 4;
  for (let J = 0; J < g; J++) {
    const G = { bitOffset: A._nextUint16(), bitLength: A._nextUint8(), channelType: A._nextUint8(), samplePosition: [A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
    64 & G.channelType ? (G.sampleLower = A._nextInt32(), G.sampleUpper = A._nextInt32()) : (G.sampleLower = A._nextUint32(), G.sampleUpper = A._nextUint32()), m.samples[J] = G;
  }
  t.dataFormatDescriptor.length = 0, t.dataFormatDescriptor.push(m);
  const f = new Ns(i, l, c, !0);
  for (; f._offset < c; ) {
    const J = f._nextUint32(), G = f._scan(J), te = Wc(G);
    if (t.keyValue[te] = f._nextUint8Array(J - G.byteLength - 1), te.match(/^ktx/i)) {
      const le = Wc(t.keyValue[te]);
      t.keyValue[te] = le.substring(0, le.lastIndexOf("\0"));
    }
    f._skip(J % 4 ? 4 - J % 4 : 0);
  }
  if (u <= 0) return t;
  const p = new Ns(i, h, u, !0), v = p._nextUint16(), E = p._nextUint16(), b = p._nextUint32(), S = p._nextUint32(), I = p._nextUint32(), B = p._nextUint32(), R = [];
  for (let J = 0; J < r; J++) R.push({ imageFlags: p._nextUint32(), rgbSliceByteOffset: p._nextUint32(), rgbSliceByteLength: p._nextUint32(), alphaSliceByteOffset: p._nextUint32(), alphaSliceByteLength: p._nextUint32() });
  const w = h + p._offset, C = w + b, D = C + S, _ = D + I, Q = new Uint8Array(i.buffer, i.byteOffset + w, b), H = new Uint8Array(i.buffer, i.byteOffset + C, S), j = new Uint8Array(i.buffer, i.byteOffset + D, I), V = new Uint8Array(i.buffer, i.byteOffset + _, B);
  return t.globalData = { endpointCount: v, selectorCount: E, imageDescs: R, endpointsData: Q, selectorsData: H, tablesData: j, extendedData: V }, t;
}
function Yc(i, e) {
  if (e === 0)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), i;
  if (e === 2 || e === 1) {
    let t = i.getIndex();
    if (t === null) {
      const a = [], o = i.getAttribute("position");
      if (o !== void 0) {
        for (let l = 0; l < o.count; l++)
          a.push(l);
        i.setIndex(a), t = i.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), i;
    }
    const n = t.count - 2, s = [];
    if (e === 2)
      for (let a = 1; a <= n; a++)
        s.push(t.getX(0)), s.push(t.getX(a)), s.push(t.getX(a + 1));
    else
      for (let a = 0; a < n; a++)
        a % 2 === 0 ? (s.push(t.getX(a)), s.push(t.getX(a + 1)), s.push(t.getX(a + 2))) : (s.push(t.getX(a + 2)), s.push(t.getX(a + 1)), s.push(t.getX(a)));
    s.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const r = i.clone();
    return r.setIndex(s), r.clearGroups(), r;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), i;
}
class iv extends ki {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new lv(t);
    }), this.register(function(t) {
      return new cv(t);
    }), this.register(function(t) {
      return new bv(t);
    }), this.register(function(t) {
      return new vv(t);
    }), this.register(function(t) {
      return new Ev(t);
    }), this.register(function(t) {
      return new uv(t);
    }), this.register(function(t) {
      return new dv(t);
    }), this.register(function(t) {
      return new pv(t);
    }), this.register(function(t) {
      return new Av(t);
    }), this.register(function(t) {
      return new ov(t);
    }), this.register(function(t) {
      return new fv(t);
    }), this.register(function(t) {
      return new hv(t);
    }), this.register(function(t) {
      return new gv(t);
    }), this.register(function(t) {
      return new mv(t);
    }), this.register(function(t) {
      return new rv(t);
    }), this.register(function(t) {
      return new Cv(t);
    }), this.register(function(t) {
      return new xv(t);
    });
  }
  load(e, t, n, s) {
    const r = this;
    let a;
    if (this.resourcePath !== "")
      a = this.resourcePath;
    else if (this.path !== "") {
      const c = qs.extractUrlBase(e);
      a = qs.resolveURL(c, this.path);
    } else
      a = qs.extractUrlBase(e);
    this.manager.itemStart(e);
    const o = function(c) {
      s ? s(c) : console.error(c), r.manager.itemError(e), r.manager.itemEnd(e);
    }, l = new zs(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
      try {
        r.parse(c, a, function(h) {
          t(h), r.manager.itemEnd(e);
        }, o);
      } catch (h) {
        o(h);
      }
    }, n, o);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, s) {
    let r;
    const a = {}, o = {}, l = new TextDecoder();
    if (typeof e == "string")
      r = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === du) {
        try {
          a[_e.KHR_BINARY_GLTF] = new wv(e);
        } catch (u) {
          s && s(u);
          return;
        }
        r = JSON.parse(a[_e.KHR_BINARY_GLTF].content);
      } else
        r = JSON.parse(l.decode(e));
    else
      r = e;
    if (r.asset === void 0 || r.asset.version[0] < 2) {
      s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const c = new Uv(r, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const u = this.pluginCallbacks[h](c);
      u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[u.name] = u, a[u.name] = !0;
    }
    if (r.extensionsUsed)
      for (let h = 0; h < r.extensionsUsed.length; ++h) {
        const u = r.extensionsUsed[h], d = r.extensionsRequired || [];
        switch (u) {
          case _e.KHR_MATERIALS_UNLIT:
            a[u] = new av();
            break;
          case _e.KHR_DRACO_MESH_COMPRESSION:
            a[u] = new yv(r, this.dracoLoader);
            break;
          case _e.KHR_TEXTURE_TRANSFORM:
            a[u] = new Iv();
            break;
          case _e.KHR_MESH_QUANTIZATION:
            a[u] = new Mv();
            break;
          default:
            d.indexOf(u) >= 0 && o[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
        }
      }
    c.setExtensions(a), c.setPlugins(o), c.parse(n, s);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(s, r) {
      n.parse(e, t, s, r);
    });
  }
}
function sv() {
  let i = {};
  return {
    get: function(e) {
      return i[e];
    },
    add: function(e, t) {
      i[e] = t;
    },
    remove: function(e) {
      delete i[e];
    },
    removeAll: function() {
      i = {};
    }
  };
}
const _e = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class rv {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const r = t[n];
      r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let s = t.cache.get(n);
    if (s) return s;
    const r = t.json, l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
    let c;
    const h = new we(16777215);
    l.color !== void 0 && h.setRGB(l.color[0], l.color[1], l.color[2], Ut);
    const u = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        c = new Zp(h), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new jp(h), c.distance = u;
        break;
      case "spot":
        c = new Kp(h), c.distance = u, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return c.position.set(0, 0, 0), Gn(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), s = Promise.resolve(c), t.cache.add(n, s), s;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, r = n.json.nodes[e], o = (r.extensions && r.extensions[this.name] || {}).light;
    return o === void 0 ? null : this._loadLight(o).then(function(l) {
      return n._getNodeRef(t.cache, o, l);
    });
  }
}
class av {
  constructor() {
    this.name = _e.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Hn;
  }
  extendParams(e, t, n) {
    const s = [];
    e.color = new we(1, 1, 1), e.opacity = 1;
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const a = r.baseColorFactor;
        e.color.setRGB(a[0], a[1], a[2], Ut), e.opacity = a[3];
      }
      r.baseColorTexture !== void 0 && s.push(n.assignTexture(e, "map", r.baseColorTexture, Rt));
    }
    return Promise.all(s);
  }
}
class ov {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = s.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}
class lv {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Rn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
      const o = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Ie(o, o);
    }
    return Promise.all(r);
  }
}
class cv {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Rn;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = s.extensions[this.name];
    return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
  }
}
class hv {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Rn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r);
  }
}
class uv {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Rn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [];
    t.sheenColor = new we(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const a = s.extensions[this.name];
    if (a.sheenColorFactor !== void 0) {
      const o = a.sheenColorFactor;
      t.sheenColor.setRGB(o[0], o[1], o[2], Ut);
    }
    return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Rt)), a.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r);
  }
}
class dv {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Rn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r);
  }
}
class pv {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Rn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
    const o = a.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new we().setRGB(o[0], o[1], o[2], Ut), Promise.all(r);
  }
}
class Av {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Rn;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = s.extensions[this.name];
    return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
  }
}
class fv {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Rn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const o = a.specularColorFactor || [1, 1, 1];
    return t.specularColor = new we().setRGB(o[0], o[1], o[2], Ut), a.specularColorTexture !== void 0 && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, Rt)), Promise.all(r);
  }
}
class mv {
  constructor(e) {
    this.parser = e, this.name = _e.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Rn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && r.push(n.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(r);
  }
}
class gv {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Rn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const r = [], a = s.extensions[this.name];
    return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && r.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(r);
  }
}
class bv {
  constructor(e) {
    this.parser = e, this.name = _e.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[this.name])
      return null;
    const r = s.extensions[this.name], a = t.options.ktx2Loader;
    if (!a) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, r.source, a);
  }
}
class vv {
  constructor(e) {
    this.parser = e, this.name = _e.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, r = s.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const a = r.extensions[t], o = s.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return n.loadTextureImage(e, a.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class Ev {
  constructor(e) {
    this.parser = e, this.name = _e.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, r = s.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const a = r.extensions[t], o = s.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return n.loadTextureImage(e, a.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class Cv {
  constructor(e) {
    this.name = _e.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const s = n.extensions[this.name], r = this.parser.getDependency("buffer", s.buffer), a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return r.then(function(o) {
        const l = s.byteOffset || 0, c = s.byteLength || 0, h = s.count, u = s.byteStride, d = new Uint8Array(o, l, c);
        return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(h, u, d, s.mode, s.filter).then(function(A) {
          return A.buffer;
        }) : a.ready.then(function() {
          const A = new ArrayBuffer(h * u);
          return a.decodeGltfBuffer(new Uint8Array(A), h, u, d, s.mode, s.filter), A;
        });
      });
    } else
      return null;
  }
}
class xv {
  constructor(e) {
    this.name = _e.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const s = t.meshes[n.mesh];
    for (const c of s.primitives)
      if (c.mode !== on.TRIANGLES && c.mode !== on.TRIANGLE_STRIP && c.mode !== on.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const a = n.extensions[this.name].attributes, o = [], l = {};
    for (const c in a)
      o.push(this.parser.getDependency("accessor", a[c]).then((h) => (l[c] = h, l[c])));
    return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then((c) => {
      const h = c.pop(), u = h.isGroup ? h.children : [h], d = c[0].count, A = [];
      for (const m of u) {
        const g = new Pe(), f = new T(), p = new dn(), v = new T(1, 1, 1), E = new Ip(m.geometry, m.material, d);
        for (let b = 0; b < d; b++)
          l.TRANSLATION && f.fromBufferAttribute(l.TRANSLATION, b), l.ROTATION && p.fromBufferAttribute(l.ROTATION, b), l.SCALE && v.fromBufferAttribute(l.SCALE, b), E.setMatrixAt(b, g.compose(f, p, v));
        for (const b in l)
          if (b === "_COLOR_0") {
            const S = l[b];
            E.instanceColor = new mo(S.array, S.itemSize, S.normalized);
          } else b !== "TRANSLATION" && b !== "ROTATION" && b !== "SCALE" && m.geometry.setAttribute(b, l[b]);
        At.prototype.copy.call(E, m), this.parser.assignFinalMaterial(E), A.push(E);
      }
      return h.isGroup ? (h.clear(), h.add(...A), h) : A[0];
    }));
  }
}
const du = "glTF", Us = 12, Kc = { JSON: 1313821514, BIN: 5130562 };
class wv {
  constructor(e) {
    this.name = _e.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, Us), n = new TextDecoder();
    if (this.header = {
      magic: n.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== du)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const s = this.header.length - Us, r = new DataView(e, Us);
    let a = 0;
    for (; a < s; ) {
      const o = r.getUint32(a, !0);
      a += 4;
      const l = r.getUint32(a, !0);
      if (a += 4, l === Kc.JSON) {
        const c = new Uint8Array(e, Us + a, o);
        this.content = n.decode(c);
      } else if (l === Kc.BIN) {
        const c = Us + a;
        this.body = e.slice(c, c + o);
      }
      a += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class yv {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = _e.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json, s = this.dracoLoader, r = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, l = {}, c = {};
    for (const h in a) {
      const u = vo[h] || h.toLowerCase();
      o[u] = a[h];
    }
    for (const h in e.attributes) {
      const u = vo[h] || h.toLowerCase();
      if (a[h] !== void 0) {
        const d = n.accessors[e.attributes[h]], A = cs[d.componentType];
        c[u] = A.name, l[u] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", r).then(function(h) {
      return new Promise(function(u, d) {
        s.decodeDracoFile(h, function(A) {
          for (const m in A.attributes) {
            const g = A.attributes[m], f = l[m];
            f !== void 0 && (g.normalized = f);
          }
          u(A);
        }, o, c, Ut, d);
      });
    });
  }
}
class Iv {
  constructor() {
    this.name = _e.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class Mv {
  constructor() {
    this.name = _e.KHR_MESH_QUANTIZATION;
  }
}
class pu extends tr {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = e * s * 3 + s;
    for (let a = 0; a !== s; a++)
      t[a] = n[r + a];
    return t;
  }
  interpolate_(e, t, n, s) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = o * 2, c = o * 3, h = s - t, u = (n - t) / h, d = u * u, A = d * u, m = e * c, g = m - c, f = -2 * A + 3 * d, p = A - d, v = 1 - f, E = p - d + u;
    for (let b = 0; b !== o; b++) {
      const S = a[g + b + o], I = a[g + b + l] * h, B = a[m + b + o], R = a[m + b] * h;
      r[b] = v * S + E * I + f * B + p * R;
    }
    return r;
  }
}
const Sv = new dn();
class Bv extends pu {
  interpolate_(e, t, n, s) {
    const r = super.interpolate_(e, t, n, s);
    return Sv.fromArray(r).normalize().toArray(r), r;
  }
}
const on = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, cs = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, Xc = {
  9728: 1003,
  9729: 1006,
  9984: 1004,
  9985: 1007,
  9986: 1005,
  9987: 1008
}, jc = {
  33071: 1001,
  33648: 1002,
  10497: 1e3
}, Ka = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, vo = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, ri = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, Tv = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: 2301,
  STEP: 2300
}, Xa = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function Rv(i) {
  return i.DefaultMaterial === void 0 && (i.DefaultMaterial = new ra({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: 0
  })), i.DefaultMaterial;
}
function wi(i, e, t) {
  for (const n in t.extensions)
    i[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
}
function Gn(i, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(i.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function Dv(i, e, t) {
  let n = !1, s = !1, r = !1;
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (u.POSITION !== void 0 && (n = !0), u.NORMAL !== void 0 && (s = !0), u.COLOR_0 !== void 0 && (r = !0), n && s && r) break;
  }
  if (!n && !s && !r) return Promise.resolve(i);
  const a = [], o = [], l = [];
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (n) {
      const d = u.POSITION !== void 0 ? t.getDependency("accessor", u.POSITION) : i.attributes.position;
      a.push(d);
    }
    if (s) {
      const d = u.NORMAL !== void 0 ? t.getDependency("accessor", u.NORMAL) : i.attributes.normal;
      o.push(d);
    }
    if (r) {
      const d = u.COLOR_0 !== void 0 ? t.getDependency("accessor", u.COLOR_0) : i.attributes.color;
      l.push(d);
    }
  }
  return Promise.all([
    Promise.all(a),
    Promise.all(o),
    Promise.all(l)
  ]).then(function(c) {
    const h = c[0], u = c[1], d = c[2];
    return n && (i.morphAttributes.position = h), s && (i.morphAttributes.normal = u), r && (i.morphAttributes.color = d), i.morphTargetsRelative = !0, i;
  });
}
function Pv(i, e) {
  if (i.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, n = e.weights.length; t < n; t++)
      i.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (i.morphTargetInfluences.length === t.length) {
      i.morphTargetDictionary = {};
      for (let n = 0, s = t.length; n < s; n++)
        i.morphTargetDictionary[t[n]] = n;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function Lv(i) {
  let e;
  const t = i.extensions && i.extensions[_e.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + ja(t.attributes) : e = i.indices + ":" + ja(i.attributes) + ":" + i.mode, i.targets !== void 0)
    for (let n = 0, s = i.targets.length; n < s; n++)
      e += ":" + ja(i.targets[n]);
  return e;
}
function ja(i) {
  let e = "";
  const t = Object.keys(i).sort();
  for (let n = 0, s = t.length; n < s; n++)
    e += t[n] + ":" + i[t[n]] + ";";
  return e;
}
function Eo(i) {
  switch (i) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function Fv(i) {
  return i.search(/\.jpe?g($|\?)/i) > 0 || i.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : i.search(/\.webp($|\?)/i) > 0 || i.search(/^data\:image\/webp/) === 0 ? "image/webp" : i.search(/\.ktx2($|\?)/i) > 0 || i.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png";
}
const Nv = new Pe();
class Uv {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new sv(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = !1, s = -1, r = !1, a = -1;
    if (typeof navigator < "u") {
      const o = navigator.userAgent;
      n = /^((?!chrome|android).)*safari/i.test(o) === !0;
      const l = o.match(/Version\/(\d+)/);
      s = n && l ? parseInt(l[1], 10) : -1, r = o.indexOf("Firefox") > -1, a = r ? o.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    typeof createImageBitmap > "u" || n && s < 17 || r && a < 98 ? this.textureLoader = new Wh(this.options.manager) : this.textureLoader = new eA(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new zs(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, s = this.json, r = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
      return a._markDefs && a._markDefs();
    }), Promise.all(this._invokeAll(function(a) {
      return a.beforeRoot && a.beforeRoot();
    })).then(function() {
      return Promise.all([
        n.getDependencies("scene"),
        n.getDependencies("animation"),
        n.getDependencies("camera")
      ]);
    }).then(function(a) {
      const o = {
        scene: a[0][s.scene || 0],
        scenes: a[0],
        animations: a[1],
        cameras: a[2],
        asset: s.asset,
        parser: n,
        userData: {}
      };
      return wi(r, o, s), Gn(o, s), Promise.all(n._invokeAll(function(l) {
        return l.afterRoot && l.afterRoot(o);
      })).then(function() {
        for (const l of o.scenes)
          l.updateMatrixWorld();
        e(o);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let s = 0, r = t.length; s < r; s++) {
      const a = t[s].joints;
      for (let o = 0, l = a.length; o < l; o++)
        e[a[o]].isBone = !0;
    }
    for (let s = 0, r = e.length; s < r; s++) {
      const a = e[s];
      a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   *
   * @param {Object} cache
   * @param {Object3D} index
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /**
   * Returns a reference to a shared resource, cloning it if necessary.
   *
   * @param {Object} cache
   * @param {Number} index
   * @param {Object} object
   * @return {Object}
   */
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const s = n.clone(), r = (a, o) => {
      const l = this.associations.get(a);
      l != null && this.associations.set(o, l);
      for (const [c, h] of a.children.entries())
        r(h, o.children[c]);
    };
    return r(n, s), s.name += "_instance_" + e.uses[t]++, s;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      if (s) return s;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let s = 0; s < t.length; s++) {
      const r = e(t[s]);
      r && n.push(r);
    }
    return n;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const n = e + ":" + t;
    let s = this.cache.get(n);
    if (!s) {
      switch (e) {
        case "scene":
          s = this.loadScene(t);
          break;
        case "node":
          s = this._invokeOne(function(r) {
            return r.loadNode && r.loadNode(t);
          });
          break;
        case "mesh":
          s = this._invokeOne(function(r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          s = this.loadAccessor(t);
          break;
        case "bufferView":
          s = this._invokeOne(function(r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          s = this.loadBuffer(t);
          break;
        case "material":
          s = this._invokeOne(function(r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          s = this._invokeOne(function(r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          s = this.loadSkin(t);
          break;
        case "animation":
          s = this._invokeOne(function(r) {
            return r.loadAnimation && r.loadAnimation(t);
          });
          break;
        case "camera":
          s = this.loadCamera(t);
          break;
        default:
          if (s = this._invokeOne(function(r) {
            return r != this && r.getDependency && r.getDependency(e, t);
          }), !s)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, s);
    }
    return s;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, s = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(s.map(function(r, a) {
        return n.getDependency(e, a);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[_e.KHR_BINARY_GLTF].body);
    const s = this.options;
    return new Promise(function(r, a) {
      n.load(qs.resolveURL(t.uri, s.path), r, void 0, function() {
        a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(n) {
      const s = t.byteLength || 0, r = t.byteOffset || 0;
      return n.slice(r, r + s);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, n = this.json, s = this.json.accessors[e];
    if (s.bufferView === void 0 && s.sparse === void 0) {
      const a = Ka[s.type], o = cs[s.componentType], l = s.normalized === !0, c = new o(s.count * a);
      return Promise.resolve(new Ht(c, a, l));
    }
    const r = [];
    return s.bufferView !== void 0 ? r.push(this.getDependency("bufferView", s.bufferView)) : r.push(null), s.sparse !== void 0 && (r.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(r).then(function(a) {
      const o = a[0], l = Ka[s.type], c = cs[s.componentType], h = c.BYTES_PER_ELEMENT, u = h * l, d = s.byteOffset || 0, A = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, m = s.normalized === !0;
      let g, f;
      if (A && A !== u) {
        const p = Math.floor(d / A), v = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + p + ":" + s.count;
        let E = t.cache.get(v);
        E || (g = new c(o, p * A, s.count * A / h), E = new Ep(g, A / h), t.cache.add(v, E)), f = new Do(E, l, d % A / h, m);
      } else
        o === null ? g = new c(s.count * l) : g = new c(o, d, s.count * l), f = new Ht(g, l, m);
      if (s.sparse !== void 0) {
        const p = Ka.SCALAR, v = cs[s.sparse.indices.componentType], E = s.sparse.indices.byteOffset || 0, b = s.sparse.values.byteOffset || 0, S = new v(a[1], E, s.sparse.count * p), I = new c(a[2], b, s.sparse.count * l);
        o !== null && (f = new Ht(f.array.slice(), f.itemSize, f.normalized)), f.normalized = !1;
        for (let B = 0, R = S.length; B < R; B++) {
          const w = S[B];
          if (f.setX(w, I[B * l]), l >= 2 && f.setY(w, I[B * l + 1]), l >= 3 && f.setZ(w, I[B * l + 2]), l >= 4 && f.setW(w, I[B * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        f.normalized = m;
      }
      return f;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, n = this.options, r = t.textures[e].source, a = t.images[r];
    let o = this.textureLoader;
    if (a.uri) {
      const l = n.manager.getHandler(a.uri);
      l !== null && (o = l);
    }
    return this.loadTextureImage(e, r, o);
  }
  loadTextureImage(e, t, n) {
    const s = this, r = this.json, a = r.textures[e], o = r.images[t], l = (o.uri || o.bufferView) + ":" + a.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = this.loadImageSource(t, n).then(function(h) {
      h.flipY = !1, h.name = a.name || o.name || "", h.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (h.name = o.uri);
      const d = (r.samplers || {})[a.sampler] || {};
      return h.magFilter = Xc[d.magFilter] || 1006, h.minFilter = Xc[d.minFilter] || 1008, h.wrapS = jc[d.wrapS] || 1e3, h.wrapT = jc[d.wrapT] || 1e3, h.generateMipmaps = !h.isCompressedTexture && h.minFilter !== 1003 && h.minFilter !== 1006, s.associations.set(h, { textures: e }), h;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = c, c;
  }
  loadImageSource(e, t) {
    const n = this, s = this.json, r = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((u) => u.clone());
    const a = s.images[e], o = self.URL || self.webkitURL;
    let l = a.uri || "", c = !1;
    if (a.bufferView !== void 0)
      l = n.getDependency("bufferView", a.bufferView).then(function(u) {
        c = !0;
        const d = new Blob([u], { type: a.mimeType });
        return l = o.createObjectURL(d), l;
      });
    else if (a.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const h = Promise.resolve(l).then(function(u) {
      return new Promise(function(d, A) {
        let m = d;
        t.isImageBitmapLoader === !0 && (m = function(g) {
          const f = new It(g);
          f.needsUpdate = !0, d(f);
        }), t.load(qs.resolveURL(u, r.path), m, void 0, A);
      });
    }).then(function(u) {
      return c === !0 && o.revokeObjectURL(l), Gn(u, a), u.userData.mimeType = a.mimeType || Fv(a.uri), u;
    }).catch(function(u) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", l), u;
    });
    return this.sourceCache[e] = h, h;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   *
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @param {string} colorSpace
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, n, s) {
    const r = this;
    return this.getDependency("texture", n.index).then(function(a) {
      if (!a) return null;
      if (n.texCoord !== void 0 && n.texCoord > 0 && (a = a.clone(), a.channel = n.texCoord), r.extensions[_e.KHR_TEXTURE_TRANSFORM]) {
        const o = n.extensions !== void 0 ? n.extensions[_e.KHR_TEXTURE_TRANSFORM] : void 0;
        if (o) {
          const l = r.associations.get(a);
          a = r.extensions[_e.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), r.associations.set(a, l);
        }
      }
      return s !== void 0 && (a.colorSpace = s), e[t] = a, a;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const s = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const o = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l || (l = new Vh(), yn.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(o, l)), n = l;
    } else if (e.isLine) {
      const o = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l || (l = new No(), yn.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(o, l)), n = l;
    }
    if (s || r || a) {
      let o = "ClonedMaterial:" + n.uuid + ":";
      s && (o += "derivative-tangents:"), r && (o += "vertex-colors:"), a && (o += "flat-shading:");
      let l = this.cache.get(o);
      l || (l = n.clone(), r && (l.vertexColors = !0), a && (l.flatShading = !0), s && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(o, l), this.associations.set(l, this.associations.get(n))), n = l;
    }
    e.material = n;
  }
  getMaterialType() {
    return ra;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, n = this.json, s = this.extensions, r = n.materials[e];
    let a;
    const o = {}, l = r.extensions || {}, c = [];
    if (l[_e.KHR_MATERIALS_UNLIT]) {
      const u = s[_e.KHR_MATERIALS_UNLIT];
      a = u.getMaterialType(), c.push(u.extendParams(o, r, t));
    } else {
      const u = r.pbrMetallicRoughness || {};
      if (o.color = new we(1, 1, 1), o.opacity = 1, Array.isArray(u.baseColorFactor)) {
        const d = u.baseColorFactor;
        o.color.setRGB(d[0], d[1], d[2], Ut), o.opacity = d[3];
      }
      u.baseColorTexture !== void 0 && c.push(t.assignTexture(o, "map", u.baseColorTexture, Rt)), o.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1, o.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1, u.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(o, "metalnessMap", u.metallicRoughnessTexture)), c.push(t.assignTexture(o, "roughnessMap", u.metallicRoughnessTexture))), a = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), c.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(e, o);
      })));
    }
    r.doubleSided === !0 && (o.side = 2);
    const h = r.alphaMode || Xa.OPAQUE;
    if (h === Xa.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, h === Xa.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && a !== Hn && (c.push(t.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new Ie(1, 1), r.normalTexture.scale !== void 0)) {
      const u = r.normalTexture.scale;
      o.normalScale.set(u, u);
    }
    if (r.occlusionTexture !== void 0 && a !== Hn && (c.push(t.assignTexture(o, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && a !== Hn) {
      const u = r.emissiveFactor;
      o.emissive = new we().setRGB(u[0], u[1], u[2], Ut);
    }
    return r.emissiveTexture !== void 0 && a !== Hn && c.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture, Rt)), Promise.all(c).then(function() {
      const u = new a(o);
      return r.name && (u.name = r.name), Gn(u, r), t.associations.set(u, { materials: e }), r.extensions && wi(s, u, r), u;
    });
  }
  /**
   * When Object3D instances are targeted by animation, they need unique names.
   *
   * @param {String} originalName
   * @return {String}
   */
  createUniqueName(e) {
    const t = rt.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, n = this.extensions, s = this.primitiveCache;
    function r(o) {
      return n[_e.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(l) {
        return Jc(l, o, t);
      });
    }
    const a = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o], h = Lv(c), u = s[h];
      if (u)
        a.push(u.promise);
      else {
        let d;
        c.extensions && c.extensions[_e.KHR_DRACO_MESH_COMPRESSION] ? d = r(c) : d = Jc(new Bt(), c, t), s[h] = { primitive: c, promise: d }, a.push(d);
      }
    }
    return Promise.all(a);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, n = this.json, s = this.extensions, r = n.meshes[e], a = r.primitives, o = [];
    for (let l = 0, c = a.length; l < c; l++) {
      const h = a[l].material === void 0 ? Rv(this.cache) : this.getDependency("material", a[l].material);
      o.push(h);
    }
    return o.push(t.loadGeometries(a)), Promise.all(o).then(function(l) {
      const c = l.slice(0, l.length - 1), h = l[l.length - 1], u = [];
      for (let A = 0, m = h.length; A < m; A++) {
        const g = h[A], f = a[A];
        let p;
        const v = c[A];
        if (f.mode === on.TRIANGLES || f.mode === on.TRIANGLE_STRIP || f.mode === on.TRIANGLE_FAN || f.mode === void 0)
          p = r.isSkinnedMesh === !0 ? new xp(g, v) : new ot(g, v), p.isSkinnedMesh === !0 && p.normalizeSkinWeights(), f.mode === on.TRIANGLE_STRIP ? p.geometry = Yc(p.geometry, 1) : f.mode === on.TRIANGLE_FAN && (p.geometry = Yc(p.geometry, 2));
        else if (f.mode === on.LINES)
          p = new Hh(g, v);
        else if (f.mode === on.LINE_STRIP)
          p = new Uo(g, v);
        else if (f.mode === on.LINE_LOOP)
          p = new Bp(g, v);
        else if (f.mode === on.POINTS)
          p = new Tp(g, v);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + f.mode);
        Object.keys(p.geometry.morphAttributes).length > 0 && Pv(p, r), p.name = t.createUniqueName(r.name || "mesh_" + e), Gn(p, r), f.extensions && wi(s, p, f), t.assignFinalMaterial(p), u.push(p);
      }
      for (let A = 0, m = u.length; A < m; A++)
        t.associations.set(u[A], {
          meshes: e,
          primitives: A
        });
      if (u.length === 1)
        return r.extensions && wi(s, u[0], r), u[0];
      const d = new Bi();
      r.extensions && wi(s, d, r), t.associations.set(d, { meshes: e });
      for (let A = 0, m = u.length; A < m; A++)
        d.add(u[A]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], s = n[n.type];
    if (!s) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return n.type === "perspective" ? t = new Gt(Wd.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6) : n.type === "orthographic" && (t = new oa(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Gn(t, n), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let s = 0, r = t.joints.length; s < r; s++)
      n.push(this._loadNodeShallow(t.joints[s]));
    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(s) {
      const r = s.pop(), a = s, o = [], l = [];
      for (let c = 0, h = a.length; c < h; c++) {
        const u = a[c];
        if (u) {
          o.push(u);
          const d = new Pe();
          r !== null && d.fromArray(r.array, c * 16), l.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new Lo(o, l);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, n = this, s = t.animations[e], r = s.name ? s.name : "animation_" + e, a = [], o = [], l = [], c = [], h = [];
    for (let u = 0, d = s.channels.length; u < d; u++) {
      const A = s.channels[u], m = s.samplers[A.sampler], g = A.target, f = g.node, p = s.parameters !== void 0 ? s.parameters[m.input] : m.input, v = s.parameters !== void 0 ? s.parameters[m.output] : m.output;
      g.node !== void 0 && (a.push(this.getDependency("node", f)), o.push(this.getDependency("accessor", p)), l.push(this.getDependency("accessor", v)), c.push(m), h.push(g));
    }
    return Promise.all([
      Promise.all(a),
      Promise.all(o),
      Promise.all(l),
      Promise.all(c),
      Promise.all(h)
    ]).then(function(u) {
      const d = u[0], A = u[1], m = u[2], g = u[3], f = u[4], p = [];
      for (let v = 0, E = d.length; v < E; v++) {
        const b = d[v], S = A[v], I = m[v], B = g[v], R = f[v];
        if (b === void 0) continue;
        b.updateMatrix && b.updateMatrix();
        const w = n._createAnimationTracks(b, S, I, B, R);
        if (w)
          for (let C = 0; C < w.length; C++)
            p.push(w[C]);
      }
      return new Op(r, void 0, p);
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, s = t.nodes[e];
    return s.mesh === void 0 ? null : n.getDependency("mesh", s.mesh).then(function(r) {
      const a = n._getNodeRef(n.meshCache, s.mesh, r);
      return s.weights !== void 0 && a.traverse(function(o) {
        if (o.isMesh)
          for (let l = 0, c = s.weights.length; l < c; l++)
            o.morphTargetInfluences[l] = s.weights[l];
      }), a;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, n = this, s = t.nodes[e], r = n._loadNodeShallow(e), a = [], o = s.children || [];
    for (let c = 0, h = o.length; c < h; c++)
      a.push(n.getDependency("node", o[c]));
    const l = s.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", s.skin);
    return Promise.all([
      r,
      Promise.all(a),
      l
    ]).then(function(c) {
      const h = c[0], u = c[1], d = c[2];
      d !== null && h.traverse(function(A) {
        A.isSkinnedMesh && A.bind(d, Nv);
      });
      for (let A = 0, m = u.length; A < m; A++)
        h.add(u[A]);
      return h;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, n = this.extensions, s = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const r = t.nodes[e], a = r.name ? s.createUniqueName(r.name) : "", o = [], l = s._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return l && o.push(l), r.camera !== void 0 && o.push(s.getDependency("camera", r.camera).then(function(c) {
      return s._getNodeRef(s.cameraCache, r.camera, c);
    })), s._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      o.push(c);
    }), this.nodeCache[e] = Promise.all(o).then(function(c) {
      let h;
      if (r.isBone === !0 ? h = new Gh() : c.length > 1 ? h = new Bi() : c.length === 1 ? h = c[0] : h = new At(), h !== c[0])
        for (let u = 0, d = c.length; u < d; u++)
          h.add(c[u]);
      if (r.name && (h.userData.name = r.name, h.name = a), Gn(h, r), r.extensions && wi(n, h, r), r.matrix !== void 0) {
        const u = new Pe();
        u.fromArray(r.matrix), h.applyMatrix4(u);
      } else
        r.translation !== void 0 && h.position.fromArray(r.translation), r.rotation !== void 0 && h.quaternion.fromArray(r.rotation), r.scale !== void 0 && h.scale.fromArray(r.scale);
      return s.associations.has(h) || s.associations.set(h, {}), s.associations.get(h).nodes = e, h;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, n = this.json.scenes[e], s = this, r = new Bi();
    n.name && (r.name = s.createUniqueName(n.name)), Gn(r, n), n.extensions && wi(t, r, n);
    const a = n.nodes || [], o = [];
    for (let l = 0, c = a.length; l < c; l++)
      o.push(s.getDependency("node", a[l]));
    return Promise.all(o).then(function(l) {
      for (let h = 0, u = l.length; h < u; h++)
        r.add(l[h]);
      const c = (h) => {
        const u = /* @__PURE__ */ new Map();
        for (const [d, A] of s.associations)
          (d instanceof yn || d instanceof It) && u.set(d, A);
        return h.traverse((d) => {
          const A = s.associations.get(d);
          A != null && u.set(d, A);
        }), u;
      };
      return s.associations = c(r), r;
    });
  }
  _createAnimationTracks(e, t, n, s, r) {
    const a = [], o = e.name ? e.name : e.uuid, l = [];
    ri[r.path] === ri.weights ? e.traverse(function(d) {
      d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
    }) : l.push(o);
    let c;
    switch (ri[r.path]) {
      case ri.weights:
        c = As;
        break;
      case ri.rotation:
        c = fs;
        break;
      case ri.position:
      case ri.scale:
        c = ms;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            c = As;
            break;
          case 2:
          case 3:
          default:
            c = ms;
            break;
        }
        break;
    }
    const h = s.interpolation !== void 0 ? Tv[s.interpolation] : 2301, u = this._getArrayFromAccessor(n);
    for (let d = 0, A = l.length; d < A; d++) {
      const m = new c(
        l[d] + "." + ri[r.path],
        t.array,
        u,
        h
      );
      s.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(m), a.push(m);
    }
    return a;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = Eo(t.constructor), s = new Float32Array(t.length);
      for (let r = 0, a = t.length; r < a; r++)
        s[r] = t[r] * n;
      t = s;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(n) {
      const s = this instanceof fs ? Bv : pu;
      return new s(this.times, this.values, this.getValueSize() / 3, n);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function Qv(i, e, t) {
  const n = e.attributes, s = new Jn();
  if (n.POSITION !== void 0) {
    const o = t.json.accessors[n.POSITION], l = o.min, c = o.max;
    if (l !== void 0 && c !== void 0) {
      if (s.set(
        new T(l[0], l[1], l[2]),
        new T(c[0], c[1], c[2])
      ), o.normalized) {
        const h = Eo(cs[o.componentType]);
        s.min.multiplyScalar(h), s.max.multiplyScalar(h);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const r = e.targets;
  if (r !== void 0) {
    const o = new T(), l = new T();
    for (let c = 0, h = r.length; c < h; c++) {
      const u = r[c];
      if (u.POSITION !== void 0) {
        const d = t.json.accessors[u.POSITION], A = d.min, m = d.max;
        if (A !== void 0 && m !== void 0) {
          if (l.setX(Math.max(Math.abs(A[0]), Math.abs(m[0]))), l.setY(Math.max(Math.abs(A[1]), Math.abs(m[1]))), l.setZ(Math.max(Math.abs(A[2]), Math.abs(m[2]))), d.normalized) {
            const g = Eo(cs[d.componentType]);
            l.multiplyScalar(g);
          }
          o.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    s.expandByVector(o);
  }
  i.boundingBox = s;
  const a = new Tn();
  s.getCenter(a.center), a.radius = s.min.distanceTo(s.max) / 2, i.boundingSphere = a;
}
function Jc(i, e, t) {
  const n = e.attributes, s = [];
  function r(a, o) {
    return t.getDependency("accessor", a).then(function(l) {
      i.setAttribute(o, l);
    });
  }
  for (const a in n) {
    const o = vo[a] || a.toLowerCase();
    o in i.attributes || s.push(r(n[a], o));
  }
  if (e.indices !== void 0 && !i.index) {
    const a = t.getDependency("accessor", e.indices).then(function(o) {
      i.setIndex(o);
    });
    s.push(a);
  }
  return We.workingColorSpace !== Ut && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${We.workingColorSpace}" not supported.`), Gn(i, e), Qv(i, e, t), Promise.all(s).then(function() {
    return e.targets !== void 0 ? Dv(i, e.targets, t) : i;
  });
}
class kv {
  constructor(e = 4) {
    this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
  }
  _initWorker(e) {
    if (!this.workers[e]) {
      const t = this.workerCreator();
      t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t;
    }
  }
  _getIdleWorker() {
    for (let e = 0; e < this.pool; e++)
      if (!(this.workerStatus & 1 << e)) return e;
    return -1;
  }
  _onMessage(e, t) {
    const n = this.workersResolve[e];
    if (n && n(t), this.queue.length) {
      const { resolve: s, msg: r, transfer: a } = this.queue.shift();
      this.workersResolve[e] = s, this.workers[e].postMessage(r, a);
    } else
      this.workerStatus ^= 1 << e;
  }
  setWorkerCreator(e) {
    this.workerCreator = e;
  }
  setWorkerLimit(e) {
    this.pool = e;
  }
  postMessage(e, t) {
    return new Promise((n) => {
      const s = this._getIdleWorker();
      s !== -1 ? (this._initWorker(s), this.workerStatus |= 1 << s, this.workersResolve[s] = n, this.workers[s].postMessage(e, t)) : this.queue.push({ resolve: n, msg: e, transfer: t });
    });
  }
  dispose() {
    this.workers.forEach((e) => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
  }
}
let Ja, On, Co;
const Za = { env: { emscripten_notify_memory_growth: function(i) {
  Co = new Uint8Array(On.exports.memory.buffer);
} } };
class _v {
  init() {
    return Ja || (Ja = typeof fetch < "u" ? fetch("data:application/wasm;base64," + Zc).then((e) => e.arrayBuffer()).then((e) => WebAssembly.instantiate(e, Za)).then(this._init) : WebAssembly.instantiate(Buffer.from(Zc, "base64"), Za).then(this._init), Ja);
  }
  _init(e) {
    On = e.instance, Za.env.emscripten_notify_memory_growth(0);
  }
  decode(e, t = 0) {
    if (!On) throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const n = e.byteLength, s = On.exports.malloc(n);
    Co.set(e, s), t = t || Number(On.exports.ZSTD_findDecompressedSize(s, n));
    const r = On.exports.malloc(t), a = On.exports.ZSTD_decompress(r, t, s, n), o = Co.slice(r, r + a);
    return On.exports.free(s), On.exports.free(r), o;
  }
}
const Zc = "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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", Ov = "display-p3", Gv = "display-p3-linear", $a = /* @__PURE__ */ new WeakMap();
let eo = 0, to;
class hn extends ki {
  constructor(e) {
    super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new kv(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn(
      'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
    );
  }
  setTranscoderPath(e) {
    return this.transcoderPath = e, this;
  }
  setWorkerLimit(e) {
    return this.workerPool.setWorkerLimit(e), this;
  }
  async detectSupportAsync(e) {
    return this.workerConfig = {
      astcSupported: await e.hasFeatureAsync("texture-compression-astc"),
      astcHDRSupported: !1,
      // https://github.com/gpuweb/gpuweb/issues/3856
      etc1Supported: await e.hasFeatureAsync("texture-compression-etc1"),
      etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"),
      dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
      bptcSupported: await e.hasFeatureAsync("texture-compression-bptc"),
      pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc")
    }, this;
  }
  detectSupport(e) {
    return e.isWebGPURenderer === !0 ? this.workerConfig = {
      astcSupported: e.hasFeature("texture-compression-astc"),
      astcHDRSupported: !1,
      // https://github.com/gpuweb/gpuweb/issues/3856
      etc1Supported: e.hasFeature("texture-compression-etc1"),
      etc2Supported: e.hasFeature("texture-compression-etc2"),
      dxtSupported: e.hasFeature("texture-compression-bc"),
      bptcSupported: e.hasFeature("texture-compression-bptc"),
      pvrtcSupported: e.hasFeature("texture-compression-pvrtc")
    } : this.workerConfig = {
      astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
      astcHDRSupported: e.extensions.has("WEBGL_compressed_texture_astc") && e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),
      etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    }, this;
  }
  init() {
    if (!this.transcoderPending) {
      const e = new zs(this.manager);
      e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
      const t = e.loadAsync("basis_transcoder.js"), n = new zs(this.manager);
      n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
      const s = n.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([t, s]).then(([r, a]) => {
        const o = hn.BasisWorker.toString(), l = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(hn.EngineFormat),
          "let _EngineType = " + JSON.stringify(hn.EngineType),
          "let _TranscoderFormat = " + JSON.stringify(hn.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(hn.BasisFormat),
          "/* basis_transcoder.js */",
          r,
          "/* worker */",
          o.substring(o.indexOf("{") + 1, o.lastIndexOf("}"))
        ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([l])), this.transcoderBinary = a, this.workerPool.setWorkerCreator(() => {
          const c = new Worker(this.workerSourceURL), h = this.transcoderBinary.slice(0);
          return c.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: h }, [h]), c;
        });
      }), eo > 0 && console.warn(
        "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
      ), eo++;
    }
    return this.transcoderPending;
  }
  load(e, t, n, s) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    const r = new zs(this.manager);
    r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials), r.load(e, (a) => {
      this.parse(a, t, s);
    }, n, s);
  }
  parse(e, t, n) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    if ($a.has(e))
      return $a.get(e).promise.then(t).catch(n);
    this._createTexture(e).then((s) => t ? t(s) : null).catch(n);
  }
  _createTextureFrom(e, t) {
    const { type: n, error: s, data: { faces: r, width: a, height: o, format: l, type: c, dfdFlags: h } } = e;
    if (n === "error") return Promise.reject(s);
    let u;
    if (t.faceCount === 6)
      u = new Dp(r, l, c);
    else {
      const d = r[0].mipmaps;
      u = t.layerCount > 1 ? new Rp(d, a, o, t.layerCount, l, c) : new sa(d, a, o, l, c);
    }
    return u.minFilter = r[0].mipmaps.length === 1 ? 1006 : 1008, u.magFilter = 1006, u.generateMipmaps = !1, u.needsUpdate = !0, u.colorSpace = Au(t), u.premultiplyAlpha = !!(h & jb), u;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(e, t = {}) {
    const n = nv(new Uint8Array(e)), s = n.vkFormat === Jo && n.dataFormatDescriptor[0].colorModel === 167;
    if (!(n.vkFormat === ev || s && !this.workerConfig.astcHDRSupported))
      return Vv(n);
    const a = t, o = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: e, taskConfig: a }, [e])).then((l) => this._createTextureFrom(l.data, n));
    return $a.set(e, { promise: o }), o;
  }
  dispose() {
    return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), eo--, this;
  }
}
hn.BasisFormat = {
  ETC1S: 0,
  UASTC: 1,
  UASTC_HDR: 2
};
hn.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16,
  BC6H: 22,
  RGB_HALF: 24,
  RGBA_HALF: 25
};
hn.EngineFormat = {
  RGBAFormat: 1023,
  RGBA_ASTC_4x4_Format: 37808,
  RGB_BPTC_UNSIGNED_Format: 36495,
  RGBA_BPTC_Format: 36492,
  RGBA_ETC2_EAC_Format: 37496,
  RGBA_PVRTC_4BPPV1_Format: 35842,
  RGBA_S3TC_DXT5_Format: 33779,
  RGB_ETC1_Format: 36196,
  RGB_ETC2_Format: 37492,
  RGB_PVRTC_4BPPV1_Format: 35840,
  RGBA_S3TC_DXT1_Format: 33777
};
hn.EngineType = {
  UnsignedByteType: 1009,
  HalfFloatType: 1016,
  FloatType: 1015
};
hn.BasisWorker = function() {
  let i, e, t;
  const n = _EngineFormat, s = _EngineType, r = _TranscoderFormat, a = _BasisFormat;
  self.addEventListener("message", function(m) {
    const g = m.data;
    switch (g.type) {
      case "init":
        i = g.config, o(g.transcoderBinary);
        break;
      case "transcode":
        e.then(() => {
          try {
            const { faces: f, buffers: p, width: v, height: E, hasAlpha: b, format: S, type: I, dfdFlags: B } = l(g.buffer);
            self.postMessage({ type: "transcode", id: g.id, data: { faces: f, width: v, height: E, hasAlpha: b, format: S, type: I, dfdFlags: B } }, p);
          } catch (f) {
            console.error(f), self.postMessage({ type: "error", id: g.id, error: f.message });
          }
        });
        break;
    }
  });
  function o(m) {
    e = new Promise((g) => {
      t = { wasmBinary: m, onRuntimeInitialized: g }, BASIS(t);
    }).then(() => {
      t.initializeBasis(), t.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
    });
  }
  function l(m) {
    const g = new t.KTX2File(new Uint8Array(m));
    function f() {
      g.close(), g.delete();
    }
    if (!g.isValid())
      throw f(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    let p;
    if (g.isUASTC())
      p = a.UASTC;
    else if (g.isETC1S())
      p = a.ETC1S;
    else if (g.isHDR())
      p = a.UASTC_HDR;
    else
      throw new Error("THREE.KTX2Loader: Unknown Basis encoding");
    const v = g.getWidth(), E = g.getHeight(), b = g.getLayers() || 1, S = g.getLevels(), I = g.getFaces(), B = g.getHasAlpha(), R = g.getDFDFlags(), { transcoderFormat: w, engineFormat: C, engineType: D } = u(p, v, E, B);
    if (!v || !E || !S)
      throw f(), new Error("THREE.KTX2Loader:	Invalid texture");
    if (!g.startTranscoding())
      throw f(), new Error("THREE.KTX2Loader: .startTranscoding failed");
    const _ = [], Q = [];
    for (let H = 0; H < I; H++) {
      const j = [];
      for (let V = 0; V < S; V++) {
        const J = [];
        let G, te;
        for (let me = 0; me < b; me++) {
          const Re = g.getImageLevelInfo(V, me, H);
          H === 0 && V === 0 && me === 0 && (Re.origWidth % 4 !== 0 || Re.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), S > 1 ? (G = Re.origWidth, te = Re.origHeight) : (G = Re.width, te = Re.height);
          let Ge = new Uint8Array(g.getImageTranscodedSizeInBytes(V, me, 0, w));
          const q = g.transcodeImage(Ge, V, me, H, w, 0, -1, -1);
          if (D === s.HalfFloatType && (Ge = new Uint16Array(Ge.buffer, Ge.byteOffset, Ge.byteLength / Uint16Array.BYTES_PER_ELEMENT)), !q)
            throw f(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
          J.push(Ge);
        }
        const le = A(J);
        j.push({ data: le, width: G, height: te }), Q.push(le.buffer);
      }
      _.push({ mipmaps: j, width: v, height: E, format: C, type: D });
    }
    return f(), { faces: _, buffers: Q, width: v, height: E, hasAlpha: B, dfdFlags: R, format: C, type: D };
  }
  const c = [
    {
      if: "astcSupported",
      basisFormat: [a.UASTC],
      transcoderFormat: [r.ASTC_4x4, r.ASTC_4x4],
      engineFormat: [n.RGBA_ASTC_4x4_Format, n.RGBA_ASTC_4x4_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 1 / 0,
      priorityUASTC: 1,
      needsPowerOfTwo: !1
    },
    {
      if: "bptcSupported",
      basisFormat: [a.ETC1S, a.UASTC],
      transcoderFormat: [r.BC7_M5, r.BC7_M5],
      engineFormat: [n.RGBA_BPTC_Format, n.RGBA_BPTC_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: !1
    },
    {
      if: "dxtSupported",
      basisFormat: [a.ETC1S, a.UASTC],
      transcoderFormat: [r.BC1, r.BC3],
      engineFormat: [n.RGBA_S3TC_DXT1_Format, n.RGBA_S3TC_DXT5_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: !1
    },
    {
      if: "etc2Supported",
      basisFormat: [a.ETC1S, a.UASTC],
      transcoderFormat: [r.ETC1, r.ETC2],
      engineFormat: [n.RGB_ETC2_Format, n.RGBA_ETC2_EAC_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: !1
    },
    {
      if: "etc1Supported",
      basisFormat: [a.ETC1S, a.UASTC],
      transcoderFormat: [r.ETC1],
      engineFormat: [n.RGB_ETC1_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: !1
    },
    {
      if: "pvrtcSupported",
      basisFormat: [a.ETC1S, a.UASTC],
      transcoderFormat: [r.PVRTC1_4_RGB, r.PVRTC1_4_RGBA],
      engineFormat: [n.RGB_PVRTC_4BPPV1_Format, n.RGBA_PVRTC_4BPPV1_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: !0
    },
    {
      if: "bptcSupported",
      basisFormat: [a.UASTC_HDR],
      transcoderFormat: [r.BC6H],
      engineFormat: [n.RGB_BPTC_UNSIGNED_Format],
      engineType: [s.HalfFloatType],
      priorityHDR: 1,
      needsPowerOfTwo: !1
    },
    // Uncompressed fallbacks.
    {
      basisFormat: [a.ETC1S, a.UASTC],
      transcoderFormat: [r.RGBA32, r.RGBA32],
      engineFormat: [n.RGBAFormat, n.RGBAFormat],
      engineType: [s.UnsignedByteType, s.UnsignedByteType],
      priorityETC1S: 100,
      priorityUASTC: 100,
      needsPowerOfTwo: !1
    },
    {
      basisFormat: [a.UASTC_HDR],
      transcoderFormat: [r.RGBA_HALF],
      engineFormat: [n.RGBAFormat],
      engineType: [s.HalfFloatType],
      priorityHDR: 100,
      needsPowerOfTwo: !1
    }
  ], h = {
    // TODO: For ETC1S we intentionally sort by _UASTC_ priority, preserving
    // a historical accident shown to avoid performance pitfalls for Linux with
    // Firefox & AMD GPU (RadeonSI). Further work needed.
    // See https://github.com/mrdoob/three.js/pull/29730.
    [a.ETC1S]: c.filter((m) => m.basisFormat.includes(a.ETC1S)).sort((m, g) => m.priorityUASTC - g.priorityUASTC),
    [a.UASTC]: c.filter((m) => m.basisFormat.includes(a.UASTC)).sort((m, g) => m.priorityUASTC - g.priorityUASTC),
    [a.UASTC_HDR]: c.filter((m) => m.basisFormat.includes(a.UASTC_HDR)).sort((m, g) => m.priorityHDR - g.priorityHDR)
  };
  function u(m, g, f, p) {
    const v = h[m];
    for (let E = 0; E < v.length; E++) {
      const b = v[E];
      if (b.if && !i[b.if] || !b.basisFormat.includes(m) || p && b.transcoderFormat.length < 2 || b.needsPowerOfTwo && !(d(g) && d(f))) continue;
      const S = b.transcoderFormat[p ? 1 : 0], I = b.engineFormat[p ? 1 : 0], B = b.engineType[0];
      return { transcoderFormat: S, engineFormat: I, engineType: B };
    }
    throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.");
  }
  function d(m) {
    return m <= 2 ? !0 : (m & m - 1) === 0 && m !== 0;
  }
  function A(m) {
    if (m.length === 1) return m[0];
    let g = 0;
    for (let v = 0; v < m.length; v++) {
      const E = m[v];
      g += E.byteLength;
    }
    const f = new Uint8Array(g);
    let p = 0;
    for (let v = 0; v < m.length; v++) {
      const E = m[v];
      f.set(E, p), p += E.byteLength;
    }
    return f;
  }
};
const Hv = /* @__PURE__ */ new Set([1023, 1030, 1028]), no = {
  [cu]: 1023,
  [au]: 1023,
  [nu]: 1023,
  [iu]: 1023,
  [lu]: 1030,
  [ru]: 1030,
  [eu]: 1030,
  [tu]: 1030,
  [ou]: 1028,
  [su]: 1028,
  [$h]: 1028,
  [Zh]: 1028,
  [Jo]: 37808,
  [uu]: 37812,
  [hu]: 37812
}, io = {
  [cu]: 1015,
  [au]: 1016,
  [nu]: 1009,
  [iu]: 1009,
  [lu]: 1015,
  [ru]: 1016,
  [eu]: 1009,
  [tu]: 1009,
  [ou]: 1015,
  [su]: 1016,
  [$h]: 1009,
  [Zh]: 1009,
  [Jo]: 1016,
  [uu]: 1009,
  [hu]: 1009
};
async function Vv(i) {
  const { vkFormat: e } = i;
  if (no[e] === void 0)
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  let t;
  i.supercompressionScheme === zc && (to || (to = new Promise(async (r) => {
    const a = new _v();
    await a.init(), r(a);
  })), t = await to);
  const n = [];
  for (let r = 0; r < i.levels.length; r++) {
    const a = Math.max(1, i.pixelWidth >> r), o = Math.max(1, i.pixelHeight >> r), l = i.pixelDepth ? Math.max(1, i.pixelDepth >> r) : 0, c = i.levels[r];
    let h;
    if (i.supercompressionScheme === Xb)
      h = c.levelData;
    else if (i.supercompressionScheme === zc)
      h = t.decode(c.levelData, c.uncompressedByteLength);
    else
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    let u;
    io[e] === 1015 ? u = new Float32Array(
      h.buffer,
      h.byteOffset,
      h.byteLength / Float32Array.BYTES_PER_ELEMENT
    ) : io[e] === 1016 ? u = new Uint16Array(
      h.buffer,
      h.byteOffset,
      h.byteLength / Uint16Array.BYTES_PER_ELEMENT
    ) : u = h, n.push({
      data: u,
      width: a,
      height: o,
      depth: l
    });
  }
  let s;
  if (Hv.has(no[e]))
    s = i.pixelDepth === 0 ? new Po(n[0].data, i.pixelWidth, i.pixelHeight) : new Lh(n[0].data, i.pixelWidth, i.pixelHeight, i.pixelDepth);
  else {
    if (i.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    s = new sa(n, i.pixelWidth, i.pixelHeight), s.minFilter = n.length === 1 ? 1006 : 1008, s.magFilter = 1006;
  }
  return s.mipmaps = n, s.type = io[e], s.format = no[e], s.colorSpace = Au(i), s.needsUpdate = !0, Promise.resolve(s);
}
function Au(i) {
  const e = i.dataFormatDescriptor[0];
  return e.colorPrimaries === Zb ? e.transferFunction === qc ? Rt : Ut : e.colorPrimaries === $b ? e.transferFunction === qc ? Ov : Gv : (e.colorPrimaries === Jb || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`), xn);
}
var zv = function() {
  var i = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", e = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb", t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), n = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly != "object")
    return {
      supported: !1
    };
  var s = WebAssembly.validate(t) ? e : i, r, a = WebAssembly.instantiate(o(s), {}).then(function(p) {
    r = p.instance, r.exports.__wasm_call_ctors();
  });
  function o(p) {
    for (var v = new Uint8Array(p.length), E = 0; E < p.length; ++E) {
      var b = p.charCodeAt(E);
      v[E] = b > 96 ? b - 97 : b > 64 ? b - 39 : b + 4;
    }
    for (var S = 0, E = 0; E < p.length; ++E)
      v[S++] = v[E] < 60 ? n[v[E]] : (v[E] - 60) * 64 + v[++E];
    return v.buffer.slice(0, S);
  }
  function l(p, v, E, b, S, I) {
    var B = r.exports.sbrk, R = E + 3 & -4, w = B(R * b), C = B(S.length), D = new Uint8Array(r.exports.memory.buffer);
    D.set(S, C);
    var _ = p(w, E, b, C, S.length);
    if (_ == 0 && I && I(w, R, b), v.set(D.subarray(w, w + E * b)), B(w - B(0)), _ != 0)
      throw new Error("Malformed buffer data: " + _);
  }
  var c = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  }, h = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  }, u = [], d = 0;
  function A(p) {
    var v = {
      object: new Worker(p),
      pending: 0,
      requests: {}
    };
    return v.object.onmessage = function(E) {
      var b = E.data;
      v.pending -= b.count, v.requests[b.id][b.action](b.value), delete v.requests[b.id];
    }, v;
  }
  function m(p) {
    for (var v = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(o(s)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + l.toString() + f.toString(), E = new Blob([v], { type: "text/javascript" }), b = URL.createObjectURL(E), S = 0; S < p; ++S)
      u[S] = A(b);
    URL.revokeObjectURL(b);
  }
  function g(p, v, E, b, S) {
    for (var I = u[0], B = 1; B < u.length; ++B)
      u[B].pending < I.pending && (I = u[B]);
    return new Promise(function(R, w) {
      var C = new Uint8Array(E), D = d++;
      I.pending += p, I.requests[D] = { resolve: R, reject: w }, I.object.postMessage({ id: D, count: p, size: v, source: C, mode: b, filter: S }, [C.buffer]);
    });
  }
  function f(p) {
    a.then(function() {
      var v = p.data;
      try {
        var E = new Uint8Array(v.count * v.size);
        l(r.exports[v.mode], E, v.count, v.size, v.source, r.exports[v.filter]), self.postMessage({ id: v.id, count: v.count, action: "resolve", value: E }, [E.buffer]);
      } catch (b) {
        self.postMessage({ id: v.id, count: v.count, action: "reject", value: b });
      }
    });
  }
  return {
    ready: a,
    supported: !0,
    useWorkers: function(p) {
      m(p);
    },
    decodeVertexBuffer: function(p, v, E, b, S) {
      l(r.exports.meshopt_decodeVertexBuffer, p, v, E, b, r.exports[c[S]]);
    },
    decodeIndexBuffer: function(p, v, E, b) {
      l(r.exports.meshopt_decodeIndexBuffer, p, v, E, b);
    },
    decodeIndexSequence: function(p, v, E, b) {
      l(r.exports.meshopt_decodeIndexSequence, p, v, E, b);
    },
    decodeGltfBuffer: function(p, v, E, b, S, I) {
      l(r.exports[h[S]], p, v, E, b, r.exports[c[I]]);
    },
    decodeGltfBufferAsync: function(p, v, E, b, S) {
      return u.length > 0 ? g(p, v, E, h[b], c[S]) : a.then(function() {
        var I = new Uint8Array(p * v);
        return l(r.exports[h[b]], I, p, v, E, r.exports[c[S]]), I;
      });
    }
  };
}();
/**
 * spatial-controls v6.1.2 build Fri Jun 28 2024
 * https://github.com/vanruesc/spatial-controls
 * Copyright 2017 Raoul van Rüschen
 * @license Zlib
 */
var fu = /* @__PURE__ */ ((i) => (i.FIRST_PERSON = "first-person", i.THIRD_PERSON = "third-person", i))(fu || {}), mu = /* @__PURE__ */ ((i) => (i.DEFAULT = "default", i.LOCK = "lock", i.LOCK_HOLD = "lock-hold", i))(mu || {}), qv = class {
  /**
   * Constructs a new rotation strategy.
   *
   * @param controls - The controls.
   */
  constructor(i) {
    /**
     * The controls.
     */
    Y(this, "controls");
    this.controls = i;
  }
  execute(i, e) {
    const t = this.controls.settings.pointer.behaviour;
    (e.type === "mousedown" || e.type === "mouseup") && t !== "default" ? this.controls.setPointerLocked() : this.controls.setRotationEnabled(i);
  }
}, $c = class {
  /**
   * Constructs a new zoom strategy.
   *
   * @param rotationManager - A rotation manager.
   * @param zoomIn - Whether this strategy should zoom in.
   */
  constructor(i, e) {
    /**
     * A rotation manager.
     */
    Y(this, "rotationManager");
    /**
     * Indicates whether this zoom strategy should zoom in.
     */
    Y(this, "zoomIn");
    this.rotationManager = i, this.zoomIn = e;
  }
  execute(i) {
    i && this.rotationManager.zoom(this.zoomIn ? -1 : 1);
  }
}, gu = /* @__PURE__ */ new Map([
  [
    8,
    "Backspace"
    /* BACKSPACE */
  ],
  [
    9,
    "Tab"
    /* TAB */
  ],
  [
    13,
    "Enter"
    /* ENTER */
  ],
  [
    16,
    "ShiftLeft"
    /* SHIFT_LEFT */
  ],
  [
    17,
    "ControlLeft"
    /* CTRL_LEFT */
  ],
  [
    18,
    "AltLeft"
    /* ALT_LEFT */
  ],
  [
    19,
    "Pause"
    /* PAUSE */
  ],
  [
    20,
    "CapsLock"
    /* CAPS_LOCK */
  ],
  [
    27,
    "Escape"
    /* ESCAPE */
  ],
  [
    32,
    "Space"
    /* SPACE */
  ],
  [
    33,
    "PageUp"
    /* PAGE_UP */
  ],
  [
    34,
    "PageDown"
    /* PAGE_DOWN */
  ],
  [
    35,
    "End"
    /* END */
  ],
  [
    36,
    "Home"
    /* HOME */
  ],
  [
    37,
    "ArrowLeft"
    /* ARROW_LEFT */
  ],
  [
    38,
    "ArrowUp"
    /* ARROW_UP */
  ],
  [
    39,
    "ArrowRight"
    /* ARROW_RIGHT */
  ],
  [
    40,
    "ArrowDown"
    /* ARROW_DOWN */
  ],
  [
    45,
    "Insert"
    /* INSERT */
  ],
  [
    46,
    "Delete"
    /* DELETE */
  ],
  [
    48,
    "Digit0"
    /* DIGIT_0 */
  ],
  [
    49,
    "Digit1"
    /* DIGIT_1 */
  ],
  [
    50,
    "Digit2"
    /* DIGIT_2 */
  ],
  [
    51,
    "Digit3"
    /* DIGIT_3 */
  ],
  [
    52,
    "Digit4"
    /* DIGIT_4 */
  ],
  [
    53,
    "Digit5"
    /* DIGIT_5 */
  ],
  [
    54,
    "Digit6"
    /* DIGIT_6 */
  ],
  [
    55,
    "Digit7"
    /* DIGIT_7 */
  ],
  [
    56,
    "Digit8"
    /* DIGIT_8 */
  ],
  [
    57,
    "Digit9"
    /* DIGIT_9 */
  ],
  [
    65,
    "KeyA"
    /* KEY_A */
  ],
  [
    66,
    "KeyB"
    /* KEY_B */
  ],
  [
    67,
    "KeyC"
    /* KEY_C */
  ],
  [
    68,
    "KeyD"
    /* KEY_D */
  ],
  [
    69,
    "KeyE"
    /* KEY_E */
  ],
  [
    70,
    "KeyF"
    /* KEY_F */
  ],
  [
    71,
    "KeyG"
    /* KEY_G */
  ],
  [
    72,
    "KeyH"
    /* KEY_H */
  ],
  [
    73,
    "KeyI"
    /* KEY_I */
  ],
  [
    74,
    "KeyJ"
    /* KEY_J */
  ],
  [
    75,
    "KeyK"
    /* KEY_K */
  ],
  [
    76,
    "KeyL"
    /* KEY_L */
  ],
  [
    77,
    "KeyM"
    /* KEY_M */
  ],
  [
    78,
    "KeyN"
    /* KEY_N */
  ],
  [
    79,
    "KeyO"
    /* KEY_O */
  ],
  [
    80,
    "KeyP"
    /* KEY_P */
  ],
  [
    81,
    "KeyQ"
    /* KEY_Q */
  ],
  [
    82,
    "KeyR"
    /* KEY_R */
  ],
  [
    83,
    "KeyS"
    /* KEY_S */
  ],
  [
    84,
    "KeyT"
    /* KEY_T */
  ],
  [
    85,
    "KeyU"
    /* KEY_U */
  ],
  [
    86,
    "KeyV"
    /* KEY_V */
  ],
  [
    87,
    "KeyW"
    /* KEY_W */
  ],
  [
    88,
    "KeyX"
    /* KEY_X */
  ],
  [
    89,
    "KeyY"
    /* KEY_Y */
  ],
  [
    90,
    "KeyZ"
    /* KEY_Z */
  ],
  [
    91,
    "MetaLeft"
    /* META_LEFT */
  ],
  [
    92,
    "MetaRight"
    /* META_RIGHT */
  ],
  [
    93,
    "MediaSelect"
    /* MEDIA_SELECT */
  ],
  [
    96,
    "Numpad0"
    /* NUMPAD_0 */
  ],
  [
    97,
    "Numpad1"
    /* NUMPAD_1 */
  ],
  [
    98,
    "Numpad2"
    /* NUMPAD_2 */
  ],
  [
    99,
    "Numpad3"
    /* NUMPAD_3 */
  ],
  [
    100,
    "Numpad4"
    /* NUMPAD_4 */
  ],
  [
    101,
    "Numpad5"
    /* NUMPAD_5 */
  ],
  [
    102,
    "Numpad6"
    /* NUMPAD_6 */
  ],
  [
    103,
    "Numpad7"
    /* NUMPAD_7 */
  ],
  [
    104,
    "Numpad8"
    /* NUMPAD_8 */
  ],
  [
    105,
    "Numpad9"
    /* NUMPAD_9 */
  ],
  [
    106,
    "NumpadMultiply"
    /* NUMPAD_MULTIPLY */
  ],
  [
    107,
    "NumpadAdd"
    /* NUMPAD_ADD */
  ],
  [
    109,
    "NumpadSubtract"
    /* NUMPAD_SUBTRACT */
  ],
  [
    110,
    "NumpadDecimal"
    /* NUMPAD_DECIMAL */
  ],
  [
    111,
    "NumpadDivide"
    /* NUMPAD_DIVIDE */
  ],
  [
    112,
    "F1"
    /* F1 */
  ],
  [
    113,
    "F2"
    /* F2 */
  ],
  [
    114,
    "F3"
    /* F3 */
  ],
  [
    115,
    "F4"
    /* F4 */
  ],
  [
    116,
    "F5"
    /* F5 */
  ],
  [
    117,
    "F6"
    /* F6 */
  ],
  [
    118,
    "F7"
    /* F7 */
  ],
  [
    119,
    "F8"
    /* F8 */
  ],
  [
    120,
    "F9"
    /* F9 */
  ],
  [
    121,
    "F10"
    /* F10 */
  ],
  [
    122,
    "F11"
    /* F11 */
  ],
  [
    123,
    "F12"
    /* F12 */
  ],
  [
    144,
    "NumLock"
    /* NUM_LOCK */
  ],
  [
    145,
    "ScrollLock"
    /* SCROLL_LOCK */
  ],
  [
    186,
    "Semicolon"
    /* SEMICOLON */
  ],
  [
    187,
    "Equal"
    /* EQUAL */
  ],
  [
    188,
    "Comma"
    /* COMMA */
  ],
  [
    189,
    "Minus"
    /* MINUS */
  ],
  [
    190,
    "Period"
    /* PERIOD */
  ],
  [
    191,
    "Slash"
    /* SLASH */
  ],
  [
    192,
    "Backquote"
    /* BACKQUOTE */
  ],
  [
    219,
    "BracketLeft"
    /* BRACKET_LEFT */
  ],
  [
    221,
    "BracketRight"
    /* BRACKET_RIGHT */
  ],
  [
    220,
    "Backslash"
    /* BACKSLASH */
  ]
]), bu = 1 / 1e3, ln = class {
  /**
   * Constructs a new scalar damper.
   *
   * @param maxSpeed - The maximum speed at which the value can change.
   */
  constructor(i = Number.POSITIVE_INFINITY) {
    /**
     * The maximum speed.
     */
    Y(this, "maxSpeed");
    /**
     * The current velocity.
     */
    Y(this, "velocity");
    this.maxSpeed = i, this.velocity = 0;
  }
  /**
   * Resets the velocity.
   */
  resetVelocity() {
    this.velocity = 0;
  }
  /**
   * Smooth interpolation with exponential velocity gain/decay.
   *
   * @param a - The start value.
   * @param b - The target value.
   * @param lambda - A smoothing factor.
   * @param omega - See {@link ScalarDamper.calculateOmega}.
   * @param exp - See {@link ScalarDamper.calculateExp}.
   * @param dt - The delta time in seconds.
   * @return The interpolated value.
   */
  interpolate(i, e, t, n, s, r) {
    const a = this.maxSpeed * Math.max(t, 1e-4), o = Math.min(Math.max(i - e, -a), a), l = i - o, c = this.velocity, h = (c + n * o) * r;
    this.velocity = (c - n * h) * s;
    let u = l + (o + h) * s;
    return Math.abs(o) < 1e-6 ? (u = e, this.velocity = 0) : e - i > 0 == u > e && (this.velocity = (u - e) / r, u = e), u;
  }
  /**
   * Calculates the Omega coefficient which can be reused for interpolations during the same frame.
   *
   * @param lambda - A smoothing factor.
   * @return Omega.
   */
  static calculateOmega(i) {
    return 2 / Math.max(i, 1e-4);
  }
  /**
   * Calculates the exponentional factor which can be reused for interpolations during the same frame.
   *
   * @param omega - See {@link ScalarDamper.calculateOmega}.
   * @param dt - The delta time in seconds.
   * @return The exponentional interpolation factor.
   */
  static calculateExp(i, e) {
    const t = i * e, n = t * t;
    return 1 / (1 + t + 0.48 * n + 0.235 * t * n);
  }
}, ai = 2 * Math.PI, eh = /* @__PURE__ */ new T(), Gr = /* @__PURE__ */ new T(), so = /* @__PURE__ */ new Pe(), Ti, Wv = (Ti = class extends Pt {
  /**
   * Constructs a new rotation manager.
  	 *
  	 * @param position - The position.
  	 * @param quaternion - The quaternion.
  	 * @param target - The target.
  	 * @param settings - The settings.
   */
  constructor(t, n, s, r) {
    super();
    /**
     * @see {@link position}
     */
    Y(this, "_position");
    /**
     * @see {@link quaternion}
     */
    Y(this, "_quaternion");
    /**
     * @see {@link target}
     */
    Y(this, "_target");
    /**
     * The settings.
     */
    Y(this, "settings");
    /**
     * The current spherical coordinates.
     */
    Y(this, "spherical0");
    /**
     * The spherical target coordinates.
     */
    Y(this, "spherical1");
    /**
     * Scalar dampers.
     */
    Y(this, "scalarDampers");
    /**
     * A timestamp.
     */
    Y(this, "timestamp");
    /**
     * A reusable update event.
     */
    Y(this, "updateEvent");
    this._position = t, this._quaternion = n, this._target = s, this.settings = r, this.spherical0 = new bc(), this.spherical1 = new bc(), this.timestamp = 0, this.updateEvent = { type: Ti.EVENT_UPDATE }, this.scalarDampers = [
      new ln(),
      new ln(),
      new ln()
    ];
  }
  /**
   * The position.
   */
  get position() {
    return this._position;
  }
  set position(t) {
    this._position = t;
  }
  /**
   * The quaternion.
   */
  get quaternion() {
    return this._quaternion;
  }
  set quaternion(t) {
    this._quaternion = t;
  }
  /**
   * The target.
   */
  get target() {
    return this._target;
  }
  set target(t) {
    this._target = t;
  }
  /**
   * The current radius.
   */
  get radius() {
    return this.spherical0.radius;
  }
  /**
   * Resets the current velocity.
   */
  resetVelocity() {
    this.spherical1.copy(this.spherical0);
    for (const t of this.scalarDampers)
      t.resetVelocity();
  }
  /**
   * Restricts the spherical angles.
   *
   * @return This manager.
   */
  restrictAngles() {
    const t = this.spherical1, n = this.settings.rotation, s = n.minAzimuthalAngle, r = n.maxAzimuthalAngle, a = n.minPolarAngle, o = n.maxPolarAngle;
    return t.theta = Math.min(Math.max(t.theta, s), r), t.phi = Math.min(Math.max(t.phi, a), o), (t.phi === 0 || t.phi === Math.PI) && t.makeSafe(), this;
  }
  /**
   * Restricts the spherical radius.
   *
   * @return This manager.
   */
  restrictRadius() {
    const t = this.spherical1, n = this.settings.zoom, s = n.minDistance, r = n.maxDistance;
    return t.radius = Math.min(Math.max(t.radius, s), r), this;
  }
  /**
   * Restricts the spherical system.
   *
   * @return This manager.
   */
  restrictSpherical() {
    return this.restrictRadius().restrictAngles();
  }
  /**
   * Updates the spherical coordinates based on the position and target.
   *
   * @return This manager.
   */
  updateSpherical() {
    if (this.settings.general.mode === "third-person") {
      const t = this.settings.rotation.pivotOffset;
      Gr.subVectors(eh.subVectors(this.position, t), this.target), this.spherical1.setFromVector3(Gr);
    } else
      this.spherical1.setFromVector3(this.target);
    return this.restrictSpherical(), this.spherical0.copy(this.spherical1), this;
  }
  /**
   * Updates the position based on the spherical coordinates.
   *
   * @return This manager.
   */
  updatePosition() {
    if (this.settings.general.mode === "third-person") {
      const t = this.settings.rotation.pivotOffset;
      this.position.setFromSpherical(this.spherical0).add(this.target).add(t);
    }
    return this;
  }
  /**
   * Updates the quaternion.
   *
   * @return This manager.
   */
  updateQuaternion() {
    const t = this.settings, n = t.rotation, s = this.target, r = eh.copy(n.up), a = this.spherical0.phi % ai;
    return (a < 0 && a > -Math.PI || a > Math.PI && a < ai) && r.negate(), t.general.mode === "third-person" ? so.lookAt(Gr.subVectors(this.position, s), n.pivotOffset, r) : so.lookAt(Gr.set(0, 0, 0), s.setFromSpherical(this.spherical0), r), this.quaternion.setFromRotationMatrix(so), this.dispatchEvent(this.updateEvent), this;
  }
  /**
   * Adjusts the spherical system.
   *
   * @param theta - The angle to add to theta in radians.
   * @param phi - The angle to add to phi in radians.
   * @return This manager.
   */
  adjustSpherical(t, n) {
    const s = this.spherical1, r = this.settings, a = r.rotation, o = a.invertedY, l = r.general.mode === "third-person", c = (l || o) && !(l && o);
    return s.theta = a.invertedX ? s.theta + t : s.theta - t, s.phi = c ? s.phi - n : s.phi + n, this.restrictAngles();
  }
  /**
   * Zooms in or out. Only applies in third person mode.
   *
   * @param sign - The zoom sign. Possible values are [-1, 0, 1].
   * @return This manager.
   */
  zoom(t) {
    const n = this.spherical1, s = this.settings, r = s.zoom;
    if (r.enabled && s.general.mode === "third-person") {
      const a = t * r.sensitivity;
      n.radius = r.inverted ? n.radius - a : n.radius + a, this.restrictRadius();
    }
    return this;
  }
  /**
   * Looks at the given point.
   *
   * @param point - The target point.
   * @return This manager.
   */
  lookAt(t) {
    return this.settings.general.mode === "third-person" ? this.target.copy(t).sub(this.settings.rotation.pivotOffset) : this.target.subVectors(t, this.position).normalize(), this;
  }
  /**
   * Returns the current view direction.
   *
   * @param view - A vector to store the direction in.
   * @return The normalized view direction.
   */
  getViewDirection(t) {
    const s = this.settings.general.mode === "third-person";
    return t.setFromSpherical(this.spherical0).normalize(), s ? t.negate() : t;
  }
  update(t) {
    const n = this.spherical0, s = this.spherical1;
    if (n.radius === s.radius && n.theta === s.theta && n.phi === s.phi)
      Math.abs(n.theta) >= ai && (n.theta %= ai, s.theta %= ai), Math.abs(n.phi) >= ai && (n.phi %= ai, s.phi %= ai);
    else {
      const a = this.settings, o = this.scalarDampers, l = (t - this.timestamp) * bu;
      if (a.rotation.damping > 0) {
        const c = a.rotation.damping, h = ln.calculateOmega(c), u = ln.calculateExp(h, l);
        n.theta = o[0].interpolate(n.theta, s.theta, c, h, u, l), n.phi = o[1].interpolate(n.phi, s.phi, c, h, u, l);
      } else
        n.theta = s.theta, n.phi = s.phi;
      if (a.zoom.damping > 0) {
        const c = a.zoom.damping, h = ln.calculateOmega(c), u = ln.calculateExp(h, l);
        n.radius = o[2].interpolate(n.radius, s.radius, c, h, u, l);
      } else
        n.radius = s.radius;
      this.updatePosition().updateQuaternion();
    }
    this.timestamp = t;
  }
}, /**
 * Triggers when the position or quaternion is changed.
 *
 * @event
 */
Y(Ti, "EVENT_UPDATE", "update"), Ti), th = class vu {
  /**
   * Constructs new input bindings.
   */
  constructor() {
    /**
     * The default bindings.
     */
    Y(this, "defaultActions");
    /**
     * A collection that maps keys to actions.
     */
    Y(this, "actions");
    this.defaultActions = /* @__PURE__ */ new Map(), this.actions = /* @__PURE__ */ new Map();
  }
  /**
   * Resets the current bindings to match the default bindings.
   *
   * @return This instance.
   */
  reset() {
    return this.actions = new Map(this.defaultActions), this;
  }
  /**
   * Establishes default bindings and resets the current bindings.
   *
   * @param actions - A collection that maps keys to actions.
   * @return This instance.
   */
  setDefault(e) {
    return this.defaultActions = e, this.reset();
  }
  /**
   * Clears the default bindings.
   *
   * @return This instance.
   */
  clearDefault() {
    return this.defaultActions.clear(), this;
  }
  /**
   * Clears the current bindings.
   *
   * @return This instance.
   */
  clear() {
    return this.actions.clear(), this;
  }
  /**
   * Copies the given bindings, including the default bindings.
   *
   * @param bindings - Bindings.
   * @return This instance.
   */
  copy(e) {
    return this.defaultActions = new Map(e.defaultActions), this.actions = new Map(e.actions), this;
  }
  /**
   * Clones these bindings.
   *
   * @return The cloned bindings.
   */
  clone() {
    return new vu().copy(this);
  }
  /**
   * Copies the given JSON data.
   *
   * @param json - The JSON data.
   * @return This instance.
   */
  fromJSON(e) {
    return e !== void 0 && (this.defaultActions = new Map(e.defaultActions), this.actions = new Map(e.actions)), this;
  }
  /**
   * Checks if the given key is bound to an action.
   *
   * @param key - A key.
   * @return Whether the given key is bound to an action.
   */
  has(e) {
    return this.actions.has(e);
  }
  /**
   * Returns the action that is bound to the given key.
   *
   * @param key - A key.
   * @return The action, or undefined if the key is not bound to any action.
   */
  get(e) {
    return this.actions.get(e);
  }
  /**
   * Binds a key to an action.
   *
   * @param key - A key.
   * @param action - An action.
   * @return This instance.
   */
  set(e, t) {
    return this.actions.set(e, t), this;
  }
  /**
   * Unbinds a key.
   *
   * @param key - The key.
   * @return Whether the binding existed.
   */
  delete(e) {
    return this.actions.delete(e);
  }
  toJSON() {
    return {
      defaultActions: [...this.defaultActions],
      actions: [...this.actions]
    };
  }
}, di, Yv = (di = class extends Pt {
  /**
   * Constructs new general settings.
   */
  constructor() {
    super();
    /**
     * @see {@link mode}
     */
    Y(this, "_mode");
    /**
     * @see {@link previousMode}
     */
    Y(this, "_previousMode");
    this._mode = "first-person", this._previousMode = this._mode;
  }
  /**
   * The previous control mode.
   *
   * @internal
   */
  get previousMode() {
    return this._previousMode;
  }
  /**
   * The control mode.
   */
  get mode() {
    return this._mode;
  }
  set mode(t) {
    this._mode !== t && (this._mode = t, this.dispatchEvent({ type: di.EVENT_CHANGE }), this._previousMode = t);
  }
  /**
   * Copies the given general settings.
   *
   * @param settings - General settings.
   * @return This instance.
   */
  copy(t) {
    return this.mode = t.mode, this;
  }
  /**
   * Clones this general settings instance.
   *
   * @return The cloned general settings.
   */
  clone() {
    return new di().copy(this);
  }
  /**
   * Copies the given JSON data.
   *
   * @param json - The JSON data.
   * @return This instance.
   */
  fromJSON(t) {
    return this.mode = t.mode, this;
  }
  toJSON() {
    return {
      mode: this.mode
    };
  }
}, /**
 * Triggers when the settings are changed.
 *
 * @event
 */
Y(di, "EVENT_CHANGE", "change"), di), zn, Kv = (zn = class extends Pt {
  /**
   * Constructs new pointer settings.
   */
  constructor() {
    super();
    /**
     * @see {@link behaviour}
     */
    Y(this, "_behaviour");
    /**
     * @see {@link sensitivity}
     */
    Y(this, "_sensitivity");
    this._behaviour = "default", this._sensitivity = 1e-3;
  }
  /**
   * The pointer behaviour.
   */
  get behaviour() {
    return this._behaviour;
  }
  set behaviour(t) {
    this._behaviour = t, this.dispatchEvent({ type: zn.EVENT_CHANGE });
  }
  /**
   * Sets the sensitivity.
   *
   * This sensitivity acts as a baseline scale for pointer movement deltas. Default is `1e-3`.
   */
  get sensitivity() {
    return this._sensitivity;
  }
  set sensitivity(t) {
    this._sensitivity = t, this.dispatchEvent({ type: zn.EVENT_CHANGE });
  }
  /**
   * Copies the given pointer settings.
   *
   * @param settings - Pointer settings.
   * @return This instance.
   */
  copy(t) {
    return this.behaviour = t.behaviour, this.sensitivity = t.sensitivity, this;
  }
  /**
   * Clones this pointer settings instance.
   *
   * @return The cloned pointer settings.
   */
  clone() {
    return new zn().copy(this);
  }
  /**
   * Copies the given JSON data.
   *
   * @param json - The JSON data.
   * @return This instance.
   */
  fromJSON(t) {
    return this.behaviour = t.behaviour, this.sensitivity = t.sensitivity, this;
  }
  toJSON() {
    return {
      behaviour: this.behaviour,
      sensitivity: this.sensitivity
    };
  }
}, /**
 * Triggers when the settings are changed.
 *
 * @event
 */
Y(zn, "EVENT_CHANGE", "change"), zn);
new T(1, 0, 0);
var Xv = new T(0, 1, 0);
new T(0, 0, 1);
var xt, jv = (xt = class extends Pt {
  /**
   * Constructs new rotation settings.
   */
  constructor() {
    super();
    /**
     * @see {@link enabled}
     */
    Y(this, "_enabled");
    /**
     * @see {@link up}
     */
    Y(this, "_up");
    /**
     * @see {@link pivotOffset}
     */
    Y(this, "_pivotOffset");
    /**
     * @see {@link minAzimuthalAngle}
     */
    Y(this, "_minAzimuthalAngle");
    /**
     * @see {@link maxAzimuthalAngle}
     */
    Y(this, "_maxAzimuthalAngle");
    /**
     * @see {@link minPolarAngle}
     */
    Y(this, "_minPolarAngle");
    /**
     * @see {@link maxPolarAngle}
     */
    Y(this, "_maxPolarAngle");
    /**
     * @see {@link invertedX}
     */
    Y(this, "_invertedX");
    /**
     * @see {@link invertedY}
     */
    Y(this, "_invertedY");
    /**
     * @see {@link sensitivityX}
     */
    Y(this, "_sensitivityX");
    /**
     * @see {@link sensitivityY}
     */
    Y(this, "_sensitivityY");
    /**
     * @see {@link damping}
     */
    Y(this, "_damping");
    this._enabled = !0, this._up = new T(), this._up.copy(Xv), this._pivotOffset = new T(), this._minAzimuthalAngle = Number.NEGATIVE_INFINITY, this._maxAzimuthalAngle = Number.POSITIVE_INFINITY, this._minPolarAngle = 0, this._maxPolarAngle = Math.PI, this._invertedX = !1, this._invertedY = !1, this._sensitivityX = 1, this._sensitivityY = 1, this._damping = 0;
  }
  /**
   * Indicates whether rotation is enabled.
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * A normalized up vector.
   */
  get up() {
    return this._up;
  }
  set up(t) {
    this._up = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * The pivot offset.
   */
  get pivotOffset() {
    return this._pivotOffset;
  }
  set pivotOffset(t) {
    this._pivotOffset = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * The minimum azimuthal angle in radians. Range: [-Math.PI, Math.PI].
   */
  get minAzimuthalAngle() {
    return this._minAzimuthalAngle;
  }
  set minAzimuthalAngle(t) {
    this._minAzimuthalAngle = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * The maximum azimuthal angle in radians. Range: [-Math.PI, Math.PI].
   */
  get maxAzimuthalAngle() {
    return this._maxAzimuthalAngle;
  }
  set maxAzimuthalAngle(t) {
    this._maxAzimuthalAngle = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * The minimum polar angle in radians. Range: [0, Math.PI].
   */
  get minPolarAngle() {
    return this._minPolarAngle;
  }
  set minPolarAngle(t) {
    this._minPolarAngle = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * The maximum polar angle in radians. Range: [0, Math.PI].
   */
  get maxPolarAngle() {
    return this._maxPolarAngle;
  }
  set maxPolarAngle(t) {
    this._maxPolarAngle = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * Indicates whether the horizontal rotation is inverted.
   */
  get invertedX() {
    return this._invertedX;
  }
  set invertedX(t) {
    this._invertedX = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * Indicates whether the vertical rotation is inverted.
   */
  get invertedY() {
    return this._invertedY;
  }
  set invertedY(t) {
    this._invertedY = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * The horizontal rotation sensitivity.
   */
  get sensitivityX() {
    return this._sensitivityX;
  }
  set sensitivityX(t) {
    this._sensitivityX = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * The vertical rotation sensitivity.
   */
  get sensitivityY() {
    return this._sensitivityY;
  }
  set sensitivityY(t) {
    this._sensitivityY = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * Sets the horizontal and vertical rotation sensitivity.
   */
  set sensitivity(t) {
    this._sensitivityX = this._sensitivityY = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * The damping factor.
   */
  get damping() {
    return this._damping;
  }
  set damping(t) {
    this._damping = t, this.dispatchEvent({ type: xt.EVENT_CHANGE });
  }
  /**
   * Copies the given rotation settings.
   *
   * @param settings - Rotation settings.
   * @return This instance.
   */
  copy(t) {
    return this.up.copy(t.up), this.pivotOffset.copy(t.pivotOffset), this.minAzimuthalAngle = t.minAzimuthalAngle, this.maxAzimuthalAngle = t.maxAzimuthalAngle, this.minPolarAngle = t.minPolarAngle, this.maxPolarAngle = t.maxPolarAngle, this.invertedX = t.invertedX, this.invertedY = t.invertedY, this.sensitivityX = t.sensitivityX, this.sensitivityY = t.sensitivityY, this.damping = t.damping, this;
  }
  /**
   * Clones this rotation settings instance.
   *
   * @return The cloned rotation settings.
   */
  clone() {
    return new xt().copy(this);
  }
  /**
   * Copies the given JSON data.
   *
   * @param json - The JSON data.
   * @return This instance.
   */
  fromJSON(t) {
    return this.enabled = t.enabled, this.up.copy(t.up), this.pivotOffset.copy(t.pivotOffset), this.minAzimuthalAngle = t.minAzimuthalAngle !== null ? t.minAzimuthalAngle : Number.NEGATIVE_INFINITY, this.maxAzimuthalAngle = t.maxAzimuthalAngle !== null ? t.maxAzimuthalAngle : Number.POSITIVE_INFINITY, this.minPolarAngle = t.minPolarAngle !== null ? t.minPolarAngle : Number.NEGATIVE_INFINITY, this.maxPolarAngle = t.maxPolarAngle !== null ? t.maxPolarAngle : Number.POSITIVE_INFINITY, this.invertedX = t.invertedX, this.invertedY = t.invertedY, this.sensitivityX = t.sensitivityX, this.sensitivityY = t.sensitivityY, this.damping = t.damping, this;
  }
  toJSON() {
    return {
      enabled: this.enabled,
      up: this.up,
      pivotOffset: this.pivotOffset,
      minAzimuthalAngle: this.minAzimuthalAngle,
      maxAzimuthalAngle: this.maxAzimuthalAngle,
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: this.maxPolarAngle,
      invertedX: this.invertedX,
      invertedY: this.invertedY,
      sensitivityX: this.sensitivityX,
      sensitivityY: this.sensitivityY,
      damping: this.damping
    };
  }
}, /**
 * Triggers when the settings are changed.
 *
 * @event
 */
Y(xt, "EVENT_CHANGE", "change"), xt), cn, Jv = (cn = class extends Pt {
  /**
   * Constructs new translation settings.
   */
  constructor() {
    super();
    /**
     * @see {@link enabled}
     */
    Y(this, "_enabled");
    /**
     * @see {@link sensitivity}
     */
    Y(this, "_sensitivity");
    /**
     * @see {@link boostMultiplier}
     */
    Y(this, "_boostMultiplier");
    /**
     * @see {@link axisModifier}
     */
    Y(this, "_axisWeights");
    /**
     * @see {@link damping}
     */
    Y(this, "_damping");
    this._enabled = !0, this._sensitivity = 1, this._boostMultiplier = 2, this._axisWeights = new T(1, 1, 1), this._damping = 0;
  }
  /**
   * Indicates whether positional translation is enabled.
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = t, this.dispatchEvent({ type: cn.EVENT_CHANGE });
  }
  /**
   * The translation sensitivity.
   */
  get sensitivity() {
    return this._sensitivity;
  }
  set sensitivity(t) {
    this._sensitivity = t, this.dispatchEvent({ type: cn.EVENT_CHANGE });
  }
  /**
   * The translation boost multiplier.
   */
  get boostMultiplier() {
    return this._boostMultiplier;
  }
  set boostMultiplier(t) {
    this._boostMultiplier = Math.max(t, 1), this.dispatchEvent({ type: cn.EVENT_CHANGE });
  }
  /**
   * Weights that influence movement along each axis.
   */
  get axisWeights() {
    return this._axisWeights;
  }
  set axisWeights(t) {
    this._axisWeights = t, this.dispatchEvent({ type: cn.EVENT_CHANGE });
  }
  /**
   * The damping factor. Range is [0.0, +Infinity]. Set to 0 to disable.
   */
  get damping() {
    return this._damping;
  }
  set damping(t) {
    this._damping = t, this.dispatchEvent({ type: cn.EVENT_CHANGE });
  }
  /**
   * Copies the given translation settings.
   *
   * @param settings - Translation settings.
   * @return This instance.
   */
  copy(t) {
    return this.enabled = t.enabled, this.sensitivity = t.sensitivity, this.boostMultiplier = t.boostMultiplier, this.damping = t.damping, this;
  }
  /**
   * Clones this translation settings instance.
   *
   * @return The cloned translation settings.
   */
  clone() {
    return new cn().copy(this);
  }
  /**
   * Copies the given JSON data.
   *
   * @param json - The JSON data.
   * @return This instance.
   */
  fromJSON(t) {
    return this.enabled = t.enabled, this.sensitivity = t.sensitivity, this.boostMultiplier = t.boostMultiplier, this.damping = t.damping, t.axisWeights !== void 0 && this.axisWeights.copy(t.axisWeights), this;
  }
  toJSON() {
    return {
      enabled: this.enabled,
      sensitivity: this.sensitivity,
      boostMultiplier: this.boostMultiplier,
      axisWeights: this.axisWeights,
      damping: this.damping
    };
  }
}, /**
 * Triggers when the settings are changed.
 *
 * @event
 */
Y(cn, "EVENT_CHANGE", "change"), cn), Wt, Zv = (Wt = class extends Pt {
  /**
   * Constructs new zoom settings.
   */
  constructor() {
    super();
    /**
     * @see {@link enabled}
     */
    Y(this, "_enabled");
    /**
     * @see {@link inverted}
     */
    Y(this, "_inverted");
    /**
     * @see {@link minDistance}
     */
    Y(this, "_minDistance");
    /**
     * @see {@link maxDistance}
     */
    Y(this, "_maxDistance");
    /**
     * @see {@link sensitivity}
     */
    Y(this, "_sensitivity");
    /**
     * @see {@link damping}
     */
    Y(this, "_damping");
    this._enabled = !0, this._inverted = !1, this._minDistance = 1e-6, this._maxDistance = Number.POSITIVE_INFINITY, this._sensitivity = 1, this._damping = 0;
  }
  /**
   * Indicates whether zooming is enabled.
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = t, this.dispatchEvent({ type: Wt.EVENT_CHANGE });
  }
  /**
   * Indicates whether the zoom controls should be inverted.
   */
  get inverted() {
    return this._inverted;
  }
  set inverted(t) {
    this._inverted = t, this.dispatchEvent({ type: Wt.EVENT_CHANGE });
  }
  /**
   * The minimum zoom distance.
   */
  get minDistance() {
    return this._minDistance;
  }
  set minDistance(t) {
    this._minDistance = Math.min(
      Math.max(t, 1e-6),
      Number.POSITIVE_INFINITY
    ), this.dispatchEvent({ type: Wt.EVENT_CHANGE });
  }
  /**
   * The maximum zoom distance.
   */
  get maxDistance() {
    return this._maxDistance;
  }
  set maxDistance(t) {
    this._maxDistance = Math.min(
      Math.max(t, this._minDistance),
      Number.POSITIVE_INFINITY
    ), this.dispatchEvent({ type: Wt.EVENT_CHANGE });
  }
  /**
   * Sets the minimum and maximum zoom distance.
   *
   * @param min - The minimum distance.
   * @param max - The maximum distance.
   */
  setRange(t, n) {
    this._minDistance = t, this._maxDistance = n, this.dispatchEvent({ type: Wt.EVENT_CHANGE });
  }
  /**
   * The zoom sensitivity.
   */
  get sensitivity() {
    return this._sensitivity;
  }
  set sensitivity(t) {
    this._sensitivity = t, this.dispatchEvent({ type: Wt.EVENT_CHANGE });
  }
  /**
   * The damping factor.
   */
  get damping() {
    return this._damping;
  }
  set damping(t) {
    this._damping = t, this.dispatchEvent({ type: Wt.EVENT_CHANGE });
  }
  /**
   * Copies the given zoom settings.
   *
   * @param settings - Zoom settings.
   * @return This instance.
   */
  copy(t) {
    return this.enabled = t.enabled, this.inverted = t.inverted, this.minDistance = t.minDistance, this.maxDistance = t.maxDistance, this.sensitivity = t.sensitivity, this.damping = t.damping, this;
  }
  /**
   * Clones this zoom settings instance.
   *
   * @return The cloned zoom settings.
   */
  clone() {
    return new Wt().copy(this);
  }
  /**
   * Copies the given JSON data.
   *
   * @param json - The JSON data.
   * @return This instance.
   */
  fromJSON(t) {
    return this.enabled = t.enabled, this.inverted = t.inverted, this.minDistance = t.minDistance, this.maxDistance = t.maxDistance || Number.POSITIVE_INFINITY, this.sensitivity = t.sensitivity, this.damping = t.damping, this;
  }
  toJSON() {
    return {
      enabled: this.enabled,
      inverted: this.inverted,
      minDistance: this.minDistance,
      maxDistance: this.maxDistance,
      sensitivity: this.sensitivity,
      damping: this.damping
    };
  }
}, /**
 * Triggers when the settings are changed.
 *
 * @event
 */
Y(Wt, "EVENT_CHANGE", "change"), Wt), Yt, Zo = (Yt = class extends Pt {
  /**
   * Constructs new settings.
   */
  constructor() {
    super();
    /**
     * Key bindings.
     *
     * This collection maps {@linkplain KeyCode key codes} to {@linkplain Action actions}.
     */
    Y(this, "keyBindings");
    /**
     * Pointer bindings.
     *
     * This collection maps {@linkplain PointerButton pointer buttons} to {@linkplain Action actions}.
     */
    Y(this, "pointerBindings");
    /**
     * General settings.
     */
    Y(this, "general");
    /**
     * Pointer settings.
     */
    Y(this, "pointer");
    /**
     * Rotation settings.
     */
    Y(this, "rotation");
    /**
     * Translation settings.
     */
    Y(this, "translation");
    /**
     * Zoom settings.
     */
    Y(this, "zoom");
    this.keyBindings = new th(), this.keyBindings.setDefault(/* @__PURE__ */ new Map([
      [
        "KeyW",
        0
        /* MOVE_FORWARD */
      ],
      [
        "KeyA",
        1
        /* MOVE_LEFT */
      ],
      [
        "KeyS",
        2
        /* MOVE_BACKWARD */
      ],
      [
        "KeyD",
        3
        /* MOVE_RIGHT */
      ],
      [
        "ArrowUp",
        0
        /* MOVE_FORWARD */
      ],
      [
        "ArrowLeft",
        1
        /* MOVE_LEFT */
      ],
      [
        "ArrowDown",
        2
        /* MOVE_BACKWARD */
      ],
      [
        "ArrowRight",
        3
        /* MOVE_RIGHT */
      ],
      [
        "KeyX",
        4
        /* MOVE_DOWN */
      ],
      [
        "Space",
        5
        /* MOVE_UP */
      ],
      [
        "PageDown",
        6
        /* ZOOM_OUT */
      ],
      [
        "PageUp",
        7
        /* ZOOM_IN */
      ],
      [
        "ShiftLeft",
        8
        /* BOOST */
      ]
    ])), this.pointerBindings = new th(), this.pointerBindings.setDefault(/* @__PURE__ */ new Map([
      [
        0,
        9
        /* ROTATE */
      ]
    ])), this.general = new Yv(), this.pointer = new Kv(), this.rotation = new jv(), this.translation = new Jv(), this.zoom = new Zv(), this.general.addEventListener(Yt.EVENT_CHANGE, (t) => this.dispatchEvent(t)), this.pointer.addEventListener(Yt.EVENT_CHANGE, (t) => this.dispatchEvent(t)), this.rotation.addEventListener(Yt.EVENT_CHANGE, (t) => this.dispatchEvent(t)), this.translation.addEventListener(Yt.EVENT_CHANGE, (t) => this.dispatchEvent(t)), this.zoom.addEventListener(Yt.EVENT_CHANGE, (t) => this.dispatchEvent(t));
  }
  /**
   * Copies the given settings.
   *
   * @param settings - Settings.
   * @return This instance.
   */
  copy(t) {
    return this.keyBindings.copy(t.keyBindings), this.pointerBindings.copy(t.pointerBindings), this.general.copy(t.general), this.pointer.copy(t.pointer), this.rotation.copy(t.rotation), this.translation.copy(t.translation), this.zoom.copy(t.zoom), this.dispatchEvent({ type: Yt.EVENT_CHANGE }), this;
  }
  /**
   * Clones these settings.
   *
   * @return The cloned settings.
   */
  clone() {
    return new Yt().copy(this);
  }
  /**
   * Copies the given JSON data.
   *
   * @param json - The JSON data string.
   * @return This instance.
   */
  fromJSON(t) {
    const n = JSON.parse(t);
    return this.keyBindings.fromJSON(n.keyBindings), this.pointerBindings.fromJSON(n.pointerBindings), this.general.fromJSON(n.general), this.pointer.fromJSON(n.pointer), this.rotation.fromJSON(n.rotation), this.translation.fromJSON(n.translation), this.zoom.fromJSON(n.zoom), this.dispatchEvent({ type: Yt.EVENT_CHANGE }), this;
  }
  /**
   * Exports these settings as a data blob.
   *
   * @return The settings blob.
   */
  toBlob() {
    return new Blob([JSON.stringify(this)], {
      type: "text/json"
    });
  }
  toJSON() {
    return {
      keyBindings: this.keyBindings,
      pointerBindings: this.pointerBindings,
      general: this.general,
      pointer: this.pointer,
      rotation: this.rotation,
      translation: this.translation,
      zoom: this.zoom
    };
  }
}, /**
 * Triggers when the settings are changed.
 *
 * @event
 */
Y(Yt, "EVENT_CHANGE", "change"), Yt), ro = /* @__PURE__ */ new T(), Hr = /* @__PURE__ */ new Ie(), Ri, $v = (Ri = class extends Pt {
  /**
   * Constructs new controls.
   *
   * @param position - A position.
   * @param quaternion - A quaternion.
   * @param target - A target.
   * @param settings - The settings.
   */
  constructor(t = new T(), n = new dn(), s = new T(), r = new Zo()) {
    super();
    /**
     * @see {@link domElement}
     */
    Y(this, "_domElement");
    /**
     * A rotation manager.
     */
    Y(this, "rotationManager");
    /**
     * A map that links actions to specific strategies.
     */
    Y(this, "strategies");
    /**
     * Indicates whether the user is currently holding the pointer button down.
     */
    Y(this, "dragging");
    /**
     * @see {@link enabled}
     */
    Y(this, "_enabled");
    /**
     * The control settings.
     */
    Y(this, "settings");
    this._domElement = null, this._enabled = !1, this.dragging = !1, this.settings = r, r.addEventListener("change", (a) => this.handleEvent(a)), this.rotationManager = new Wv(t, n, s, r), this.rotationManager.addEventListener(Ri.EVENT_UPDATE, (a) => this.dispatchEvent(a)), this.strategies = /* @__PURE__ */ new Map([
      [6, new $c(this.rotationManager, !1)],
      [7, new $c(this.rotationManager, !0)],
      [9, new qv(this)]
    ]);
  }
  /**
   * A DOM element. Acts as the primary event target.
   */
  get domElement() {
    return this._domElement;
  }
  set domElement(t) {
    this._domElement = t;
    const n = this.enabled;
    this.dispose(), this.enabled = n;
  }
  /**
   * The position.
   */
  get position() {
    return this.rotationManager.position;
  }
  set position(t) {
    this.rotationManager.position = t;
  }
  /**
   * The quaternion.
   */
  get quaternion() {
    return this.rotationManager.quaternion;
  }
  set quaternion(t) {
    this.rotationManager.quaternion = t;
  }
  /**
   * The target.
   */
  get target() {
    return this.rotationManager.target;
  }
  set target(t) {
    this.rotationManager.target = t;
  }
  /**
   * Looks at the given point.
   *
   * @param x - The X-coordinate, or a point.
   * @param y - The Y-coordinate.
   * @param z - The Z-coordinate.
   * @return This instance.
   */
  lookAt(t, n, s) {
    return t instanceof T ? this.rotationManager.lookAt(t) : this.rotationManager.lookAt(ro.set(t, n, s)), this;
  }
  /**
   * Returns the current view direction.
   *
   * @param view - A vector to store the direction in.
   * @return The normalized view direction.
   */
  getViewDirection(t) {
    return this.rotationManager.getViewDirection(t);
  }
  /**
   * Indicates whether the controls are enabled.
   *
   * Event listeners will be registered or unregistered depending on this flag.
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    if (this.domElement === null || typeof document > "u")
      return;
    const n = this.domElement;
    t && !this._enabled ? (n.style.touchAction = "none", document.addEventListener("pointerlockchange", this), document.addEventListener("pointerlockerror", this), document.addEventListener("visibilitychange", this), document.body.addEventListener("keyup", this), document.body.addEventListener("keydown", this), n.addEventListener("mousedown", this), n.addEventListener("mouseup", this), n.addEventListener("pointerdown", this), n.addEventListener("pointerup", this), n.addEventListener("pointercancel", this), n.addEventListener("wheel", this, { passive: !0 })) : !t && this._enabled && (n.style.touchAction = "", document.removeEventListener("pointerlockchange", this), document.removeEventListener("pointerlockerror", this), document.removeEventListener("visibilitychange", this), document.body.removeEventListener("keyup", this), document.body.removeEventListener("keydown", this), n.removeEventListener("mousedown", this), n.removeEventListener("mouseup", this), n.removeEventListener("pointerdown", this), n.removeEventListener("pointerup", this), n.removeEventListener("pointercancel", this), n.removeEventListener("wheel", this), n.removeEventListener("pointermove", this)), this.rotationManager.resetVelocity(), this.setPointerLocked(!1), this._enabled = t;
  }
  /**
   * Locks or unlocks the pointer.
   *
   * @see {@link handlePointerLockEvent}
   * @param locked - Whether the pointer should be locked.
   */
  setPointerLocked(t = !0) {
    var n;
    t ? document.pointerLockElement !== this.domElement && ((n = this.domElement) == null ? void 0 : n.requestPointerLock) !== void 0 && this.domElement.requestPointerLock() : document.exitPointerLock !== void 0 && document.exitPointerLock();
  }
  /**
   * Enables or disables the rotation mode.
   *
   * @param enabled - Whether the rotation mode should be activated.
   */
  setRotationEnabled(t) {
    var n, s;
    this.settings.rotation.enabled && t ? (n = this.domElement) == null || n.addEventListener("pointermove", this, { passive: !0 }) : (s = this.domElement) == null || s.removeEventListener("pointermove", this);
  }
  /**
   * Handles pointer move events.
   *
   * @param event - A pointer event.
   */
  handlePointerMoveEvent(t) {
    const n = this.settings, s = n.rotation, r = n.pointer.behaviour, a = n.pointer.sensitivity, o = this.rotationManager;
    if (r !== "lock-hold" || this.dragging) {
      let { movementX: l, movementY: c } = t;
      (l === void 0 || c === void 0) && (l = t.clientX - Hr.x, c = t.clientY - Hr.y, Hr.set(t.clientX, t.clientY)), o.adjustSpherical(
        l * a * s.sensitivityX,
        c * a * s.sensitivityY
      );
    }
  }
  /**
   * Handles pointer button events.
   *
   * @param event - A pointer event.
   * @param pressed - Whether the pointer button has been pressed down.
   */
  handlePointerButtonEvent(t, n) {
    var a;
    const s = this.settings.pointerBindings, r = this.settings.pointer.behaviour;
    if (s.has(t.button)) {
      Hr.set(t.clientX, t.clientY);
      const o = s.get(t.button);
      if (!(t instanceof PointerEvent && t.pointerType === "mouse")) {
        const l = this.strategies.get(o);
        l == null || l.execute(n, t), o === 9 && (this.dragging = n);
      }
      t instanceof PointerEvent && n && r === "default" && ((a = this.domElement) == null || a.setPointerCapture(t.pointerId));
    }
  }
  /**
   * Handles pointer cancel and leave events.
   *
   * @param event - A pointer event.
   */
  handlePointerCancelEvent(t) {
    var n;
    (n = this.domElement) == null || n.removeEventListener("pointermove", this);
  }
  /**
   * Handles wheel events.
   *
   * @param event - A wheel event.
   */
  handleWheelEvent(t) {
    this.rotationManager.zoom(Math.sign(t.deltaY));
  }
  /**
   * Enables or disables controls based on the pointer lock state.
   */
  handlePointerLockEvent() {
    this.setRotationEnabled(document.pointerLockElement === this.domElement);
  }
  /**
   * Handles keyboard events.
   *
   * @param event - A keyboard event.
   * @param pressed - Whether the key has been pressed down.
   */
  handleKeyboardEvent(t, n) {
    const s = this.settings.keyBindings, r = t.code !== void 0 ? t.code : gu.get(t.keyCode);
    if (s.has(r)) {
      t.preventDefault();
      const a = this.strategies.get(s.get(r));
      a == null || a.execute(n);
    }
  }
  /**
   * Cancels active interactions on visibility loss.
   */
  handleVisibilityChangeEvent() {
    var t;
    document.hidden && ((t = this.domElement) == null || t.removeEventListener("pointermove", this));
  }
  /**
   * Reacts to setting changes.
   *
   * @param event - An event.
   */
  onSettingsChanged(t) {
    const n = this.rotationManager, s = this.settings, r = s.general;
    s.rotation.enabled || this.rotationManager.resetVelocity(), r.mode !== r.previousMode ? (r.mode === "third-person" ? (ro.copy(this.target), this.target.copy(this.position), this.position.sub(ro)) : (this.position.copy(this.target), this.target.set(0, 0, -1).applyQuaternion(this.quaternion)), n.updateSpherical()) : n.restrictSpherical(), n.updatePosition().updateQuaternion();
  }
  /**
   * Synchronizes the internal state with external changes.
   *
   * @param previousPosition - The previous position.
   * @param previousQuaternion - The previous quaternion.
   * @param previousTarget - The previous target.
   */
  synchronize(t, n, s) {
    const r = this.settings.general.mode, a = this.rotationManager, o = this.position, l = this.quaternion, c = this.target;
    n.equals(l) ? s.equals(c) ? t.equals(o) || r === "third-person" && a.updateSpherical().updateQuaternion() : t.equals(o) && r === "third-person" ? a.updatePosition() : a.updateSpherical().updateQuaternion() : (r === "third-person" ? (c.set(0, 0, -1).applyQuaternion(l), c.multiplyScalar(a.radius), c.add(o)) : c.set(0, 0, -1).applyQuaternion(l), a.updateSpherical());
  }
  handleEvent(t) {
    switch (t.type) {
      case "pointermove":
        this.handlePointerMoveEvent(t);
        break;
      case "pointerdown":
      case "mousedown":
        this.handlePointerButtonEvent(t, !0);
        break;
      case "pointerup":
      case "mouseup":
        this.handlePointerButtonEvent(t, !1);
        break;
      case "pointercancel":
        this.handlePointerCancelEvent(t);
        break;
      case "wheel":
        this.handleWheelEvent(t);
        break;
      case "pointerlockchange":
        this.handlePointerLockEvent();
        break;
      case "keydown":
        this.handleKeyboardEvent(t, !0);
        break;
      case "keyup":
        this.handleKeyboardEvent(t, !1);
        break;
      case "visibilitychange":
        this.handleVisibilityChangeEvent();
        break;
      case "change":
        this.onSettingsChanged(t);
        break;
    }
  }
  update(t) {
    this.rotationManager.update(t);
  }
  dispose() {
    this.enabled = !1;
  }
}, /**
 * Triggers when the quaternion is changed.
 *
 * @event
 */
Y(Ri, "EVENT_UPDATE", "update"), Ri), eE = class {
  /**
   * Constructs a new boost strategy.
   *
   * @param movementState - A movement state.
   */
  constructor(i) {
    /**
     * A movement state.
     */
    Y(this, "movementState");
    this.movementState = i;
  }
  execute(i) {
    this.movementState.boost = i;
  }
}, ns = class {
  /**
   * Constructs a new movement strategy.
   *
   * @param movementState - A movement state.
   * @param direction - A direction.
   */
  constructor(i, e) {
    /**
     * A movement state.
     */
    Y(this, "movementState");
    /**
     * A direction.
     */
    Y(this, "direction");
    this.movementState = i, this.direction = e;
  }
  execute(i) {
    const e = this.movementState;
    switch (this.direction) {
      case 2:
        e.backward = i, e.backwardBeforeForward = i;
        break;
      case 0:
        e.forward = i, e.backwardBeforeForward = !i;
        break;
      case 3:
        e.right = i, e.rightBeforeLeft = i;
        break;
      case 1:
        e.left = i, e.rightBeforeLeft = !i;
        break;
      case 5:
        e.up = i, e.upBeforeDown = i;
        break;
      case 4:
        e.down = i, e.upBeforeDown = !i;
        break;
    }
  }
}, tE = class {
  /**
   * Constructs a new movement state.
   */
  constructor() {
    /**
     * Movement to the left.
     */
    Y(this, "left");
    /**
     * Movement to the right.
     */
    Y(this, "right");
    /**
     * Forward motion.
     */
    Y(this, "forward");
    /**
     * Backward motion.
     */
    Y(this, "backward");
    /**
     * Ascension.
     */
    Y(this, "up");
    /**
     * Descent.
     */
    Y(this, "down");
    /**
     * Controls whether backward movement currently has priority.
     */
    Y(this, "backwardBeforeForward");
    /**
     * Controls whether right movement currently has priority.
     */
    Y(this, "rightBeforeLeft");
    /**
     * Controls whether up movement currently has priority.
     */
    Y(this, "upBeforeDown");
    /**
     * Whether the boost multiplier should be used.
     */
    Y(this, "boost");
    this.reset();
  }
  /**
   * Indicates whether any flag is currently active.
   */
  get active() {
    return this.forward || this.backward || this.left || this.right || this.up || this.down;
  }
  /**
   * Resets this state.
   *
   * @return This state.
   */
  reset() {
    return this.left = !1, this.right = !1, this.forward = !1, this.backward = !1, this.up = !1, this.down = !1, this.backwardBeforeForward = !1, this.rightBeforeLeft = !1, this.upBeforeDown = !1, this.boost = !1, this;
  }
}, ao = /* @__PURE__ */ new T(), is = /* @__PURE__ */ new T(), Di, nE = (Di = class extends Pt {
  /**
   * Constructs a new translation manager.
   *
   * @param position - The position.
   * @param quaternion - The quaternion.
   * @param target - The target.
   * @param settings - The settings.
   */
  constructor(t, n, s, r) {
    super();
    /**
     * @see {@link position}
     */
    Y(this, "_position");
    /**
     * @see {@link quaternion}
     */
    Y(this, "_quaternion");
    /**
     * @see {@link target}
     */
    Y(this, "_target");
    /**
     * The settings.
     */
    Y(this, "settings");
    /**
     * The movement state.
     */
    Y(this, "movementState");
    /**
     * The current velocity.
     */
    Y(this, "velocity0");
    /**
     * The target velocity.
     */
    Y(this, "velocity1");
    /**
     * Scalar dampers.
     */
    Y(this, "scalarDampers");
    /**
     * A timestamp.
     */
    Y(this, "timestamp");
    /**
     * A reusable update event.
     */
    Y(this, "updateEvent");
    this._position = t, this._quaternion = n, this._target = s, this.settings = r, this.movementState = new tE(), this.velocity0 = new T(), this.velocity1 = new T(), this.timestamp = 0, this.updateEvent = { type: Di.EVENT_UPDATE }, this.scalarDampers = [
      new ln(),
      new ln(),
      new ln()
    ];
  }
  /**
   * The position.
   */
  get position() {
    return this._position;
  }
  set position(t) {
    this._position = t;
  }
  /**
   * The quaternion.
   */
  get quaternion() {
    return this._quaternion;
  }
  set quaternion(t) {
    this._quaternion = t;
  }
  /**
   * The target.
   */
  get target() {
    return this._target;
  }
  set target(t) {
    this._target = t;
  }
  /**
   * Resets the current velocity.
   */
  resetVelocity() {
    this.velocity0.set(0, 0, 0), this.velocity1.set(0, 0, 0);
    for (const t of this.scalarDampers)
      t.resetVelocity();
  }
  /**
   * Changes the position based on the current velocity and elapsed time.
   *
   * @param position - The position to translate.
   * @param velocity - The velocity.
   * @param elapsed - The time since the last frame in seconds.
   */
  translate(t, n, s) {
    const r = this.settings.translation.axisWeights;
    is.copy(n).applyQuaternion(this.quaternion), r.x !== 1 || r.y !== 1 || r.z !== 1 ? (is.multiply(this.settings.translation.axisWeights).normalize(), is.multiplyScalar(n.length() * s)) : is.multiplyScalar(s), t.add(is), this.dispatchEvent(this.updateEvent);
  }
  update(t) {
    if (!this.settings.translation.enabled) {
      this.timestamp = t;
      return;
    }
    const s = this.movementState, r = this.settings.translation, a = s.boost ? r.boostMultiplier : 1, o = r.sensitivity, l = this.scalarDampers, c = this.velocity0, h = this.velocity1;
    h.setScalar(0), s.active && (s.backward && s.forward ? h.z = s.backwardBeforeForward ? 1 : -1 : s.backward ? h.z = 1 : s.forward && (h.z = -1), s.right && s.left ? h.x = s.rightBeforeLeft ? 1 : -1 : s.right ? h.x = 1 : s.left && (h.x = -1), s.up && s.down ? h.y = s.upBeforeDown ? 1 : -1 : s.up ? h.y = 1 : s.down && (h.y = -1));
    const u = o * a;
    h.normalize().multiplyScalar(u);
    const d = (t - this.timestamp) * bu;
    if (this.timestamp = t, !c.equals(h))
      if (r.damping > 0) {
        const A = r.damping, m = ln.calculateOmega(A), g = ln.calculateExp(m, d);
        c.x = l[0].interpolate(c.x, h.x, A, m, g, d), c.y = l[1].interpolate(c.y, h.y, A, m, g, d), c.z = l[2].interpolate(c.z, h.z, A, m, g, d);
      } else
        c.copy(h);
    (c.x !== 0 || c.y !== 0 || c.z !== 0) && (this.settings.general.mode === "third-person" ? (ao.copy(this.target), this.translate(this.target, c, d), this.target.copy(this.target), this.position.add(is.subVectors(this.target, ao))) : (ao.copy(this.position), this.translate(this.position, c, d), this.position.copy(this.position)));
  }
}, /**
 * Triggers when the position or quaternion is changed.
 *
 * @event
 */
Y(Di, "EVENT_UPDATE", "update"), Di), Pi, iE = (Pi = class extends Pt {
  /**
   * Constructs new controls.
   *
   * @param position - A position.
   * @param quaternion - A quaternion.
   * @param target - A target.
   * @param settings - The settings.
   */
  constructor(t = new T(), n = new dn(), s = new T(), r = new Zo()) {
    super();
    /**
     * A translation manager.
     */
    Y(this, "translationManager");
    /**
     * A map that links actions to specific strategies.
     */
    Y(this, "strategies");
    /**
     * @see {@link enabled}
     */
    Y(this, "_enabled");
    /**
     * The settings.
     */
    Y(this, "settings");
    this._enabled = !1, this.settings = r, r.addEventListener("change", (o) => this.handleEvent(o)), this.translationManager = new nE(t, n, s, r), this.translationManager.addEventListener(Pi.EVENT_UPDATE, (o) => this.dispatchEvent(o));
    const a = this.translationManager.movementState;
    this.strategies = /* @__PURE__ */ new Map([
      [0, new ns(
        a,
        0
        /* FORWARD */
      )],
      [1, new ns(
        a,
        1
        /* LEFT */
      )],
      [2, new ns(
        a,
        2
        /* BACKWARD */
      )],
      [3, new ns(
        a,
        3
        /* RIGHT */
      )],
      [4, new ns(
        a,
        4
        /* DOWN */
      )],
      [5, new ns(
        a,
        5
        /* UP */
      )],
      [8, new eE(a)]
    ]);
  }
  /**
   * The position.
   */
  set position(t) {
    this.translationManager.position = t;
  }
  /**
   * The quaternion.
   */
  set quaternion(t) {
    this.translationManager.quaternion = t;
  }
  /**
   * The target.
   */
  set target(t) {
    this.translationManager.target = t;
  }
  /**
   * Indicates whether the controls are enabled.
   *
   * Event listeners will be registered or unregistered depending on this flag.
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    typeof document > "u" || (this.translationManager.movementState.reset(), t && !this._enabled ? (document.addEventListener("visibilitychange", this), document.body.addEventListener("keyup", this), document.body.addEventListener("keydown", this)) : !t && this._enabled && (document.removeEventListener("visibilitychange", this), document.body.removeEventListener("keyup", this), document.body.removeEventListener("keydown", this)), this.translationManager.resetVelocity(), this._enabled = t);
  }
  /**
   * Handles keyboard events.
   *
   * @param event - A keyboard event.
   * @param pressed - Whether the key has been pressed down.
   */
  handleKeyboardEvent(t, n) {
    const s = this.settings.keyBindings, r = t.code !== void 0 ? t.code : gu.get(t.keyCode);
    if (s.has(r)) {
      t.preventDefault();
      const a = this.strategies.get(s.get(r));
      a == null || a.execute(n);
    }
  }
  /**
   * Cancels active interactions on visibility loss.
   */
  handleVisibilityChangeEvent() {
    document.hidden && this.translationManager.movementState.reset();
  }
  /**
   * Reacts to setting changes.
   *
   * @param event - An event.
   */
  onSettingsChanged(t) {
    this.settings.translation.enabled || this.translationManager.resetVelocity();
  }
  handleEvent(t) {
    switch (t.type) {
      case "keydown":
        this.handleKeyboardEvent(t, !0);
        break;
      case "keyup":
        this.handleKeyboardEvent(t, !1);
        break;
      case "visibilitychange":
        this.handleVisibilityChangeEvent();
        break;
      case "change":
        this.onSettingsChanged(t);
        break;
    }
  }
  update(t) {
    this.translationManager.update(t);
  }
  dispose() {
    this.enabled = !1;
  }
}, /**
 * Triggers when the position or quaternion is changed.
 *
 * @event
 */
Y(Pi, "EVENT_UPDATE", "update"), Pi), Vr = /* @__PURE__ */ new T();
function nh(i, e) {
  for (const t of e)
    i = t(i);
  return i;
}
var qn, sE = (qn = class extends Pt {
  /**
   * Constructs new controls.
   *
   * @param position - A position.
   * @param quaternion - A quaternion.
   * @param domElement - A DOM element. Serves as the primary event target.
   */
  constructor(t = new T(), n = new dn(), s = null) {
    super();
    /**
     * @see {@link domElement}
     */
    Y(this, "_domElement");
    /**
     * @see {@link position}
     */
    Y(this, "_position");
    /**
     * @see {@link quaternion}
     */
    Y(this, "_quaternion");
    /**
     * @see {@link target}
     */
    Y(this, "_target");
    /**
     * The previous position.
     */
    Y(this, "previousPosition");
    /**
     * The previous quaternion.
     */
    Y(this, "previousQuaternion");
    /**
     * The previous target.
     */
    Y(this, "previousTarget");
    /**
     * Rotation controls.
     */
    Y(this, "rotationControls");
    /**
     * Translation controls.
     */
    Y(this, "translationControls");
    /**
     * @see {@link enabled}
     */
    Y(this, "_enabled");
    /**
     * The control settings.
     */
    Y(this, "settings");
    /**
     * Custom constraints for {@link position} and {@link target}.
     */
    Y(this, "constraints");
    s === null && typeof document < "u" && (s = document.body), this._domElement = null, this._enabled = !1;
    const r = new T();
    this._target = r, this._position = t, this._quaternion = n, this.previousPosition = new T(), this.previousQuaternion = new dn(), this.previousTarget = new T();
    const a = new Zo();
    a.addEventListener("change", (l) => this.handleEvent(l)), this.settings = a;
    const o = /* @__PURE__ */ new Set();
    this.constraints = o, this.rotationControls = new $v(t, n, r, a), this.translationControls = new iE(t, n, r, a), this.rotationControls.addEventListener(qn.EVENT_UPDATE, (l) => this.dispatchEvent(l)), this.translationControls.addEventListener(qn.EVENT_UPDATE, (l) => this.dispatchEvent(l)), t !== null && n !== null && (this._target.set(0, 0, -1).applyQuaternion(this._quaternion), this.lookAt(this._target), this.domElement = s, this.enabled = !0, this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), this.previousTarget.copy(this.target));
  }
  /**
   * A DOM element. Acts as the primary event target.
   */
  get domElement() {
    return this._domElement;
  }
  set domElement(t) {
    this._domElement = t, this.rotationControls.domElement = t;
    const n = this.enabled;
    this.dispose(), this.enabled = n;
  }
  /**
   * The position.
   */
  get position() {
    return this._position;
  }
  set position(t) {
    this._position = t, this.rotationControls.position = t, this.translationControls.position = t;
  }
  /**
   * The quaternion.
   */
  get quaternion() {
    return this._quaternion;
  }
  set quaternion(t) {
    this._quaternion = t, this.rotationControls.quaternion = t, this.translationControls.quaternion = t;
  }
  /**
   * The target.
   */
  get target() {
    return this._target;
  }
  set target(t) {
    this._target = t, this.rotationControls.target = t, this.translationControls.target = t;
  }
  /**
   * Looks at the given point.
   *
   * @param x - The X-coordinate, or a point.
   * @param y - The Y-coordinate.
   * @param z - The Z-coordinate.
   * @return This instance.
   */
  lookAt(t, n, s) {
    return t instanceof T ? this.rotationControls.lookAt(t) : this.rotationControls.lookAt(Vr.set(t, n, s)), this;
  }
  /**
   * Returns the current view direction.
   *
   * @param view - A vector to store the direction in.
   * @return The normalized view direction.
   */
  getViewDirection(t) {
    return this.rotationControls.getViewDirection(t);
  }
  /**
   * Indicates whether the controls are enabled.
   *
   * Event listeners will be registered or unregistered depending on this flag.
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = t, this.rotationControls.enabled = t, this.translationControls.enabled = t;
  }
  /**
   * Copies the given controls.
   *
   * @param controls - A controls instance.
   * @return This instance.
   */
  copy(t) {
    return this.position = t.position, this.quaternion = t.quaternion, this.target = t.target, this.domElement = t.domElement, this.settings.copy(t.settings), this.lookAt(this.target);
  }
  /**
   * Clones this instance.
   *
   * @return The cloned controls.
   */
  clone() {
    return new qn().copy(this);
  }
  /**
   * Synchronizes the internal state with external changes.
   */
  synchronize() {
    this.rotationControls.synchronize(
      this.previousPosition,
      this.previousQuaternion,
      this.previousTarget
    );
  }
  /**
   * Constrains the given vector.
   *
   * @param A vector.
   * @return The constrained vector.
   */
  applyConstraints() {
    this.constraints.size !== 0 && (this.settings.general.mode === "third-person" ? (Vr.copy(this.target), this.target.copy(nh(this.target, this.constraints)), this.position.add(Vr.subVectors(this.target, Vr))) : this.position.copy(nh(this.position, this.constraints)));
  }
  /**
   * Reacts to setting changes.
   *
   * @param event - An event.
   */
  onSettingsChanged(t) {
    this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), this.previousTarget.copy(this.target);
  }
  handleEvent(t) {
    switch (t.type) {
      case "change":
        this.onSettingsChanged(t);
        break;
    }
  }
  update(t) {
    this.synchronize(), this.rotationControls.update(t), this.translationControls.update(t), this.applyConstraints(), this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), this.previousTarget.copy(this.target);
  }
  dispose() {
    this.enabled = !1;
  }
}, /**
 * Triggers when the position or quaternion is changed.
 *
 * @event
 */
Y(qn, "EVENT_UPDATE", "update"), qn);
/*! Tweakpane 4.0.5 (c) 2016 cocopon, licensed under the MIT license. */
function ct(i) {
  return i == null;
}
function $o(i) {
  return i !== null && typeof i == "object";
}
function xo(i) {
  return i !== null && typeof i == "object";
}
function rE(i, e) {
  if (i.length !== e.length)
    return !1;
  for (let t = 0; t < i.length; t++)
    if (i[t] !== e[t])
      return !1;
  return !0;
}
function Ni(i, e) {
  return Array.from(/* @__PURE__ */ new Set([...Object.keys(i), ...Object.keys(e)])).reduce((n, s) => {
    const r = i[s], a = e[s];
    return xo(r) && xo(a) ? Object.assign(Object.assign({}, n), { [s]: Ni(r, a) }) : Object.assign(Object.assign({}, n), { [s]: s in e ? a : r });
  }, {});
}
function el(i) {
  return $o(i) ? "target" in i : !1;
}
const aE = {
  alreadydisposed: () => "View has been already disposed",
  invalidparams: (i) => `Invalid parameters for '${i.name}'`,
  nomatchingcontroller: (i) => `No matching controller for '${i.key}'`,
  nomatchingview: (i) => `No matching view for '${JSON.stringify(i.params)}'`,
  notbindable: () => "Value is not bindable",
  notcompatible: (i) => `Not compatible with  plugin '${i.id}'`,
  propertynotfound: (i) => `Property '${i.name}' not found`,
  shouldneverhappen: () => "This error should never happen"
};
class bt {
  static alreadyDisposed() {
    return new bt({ type: "alreadydisposed" });
  }
  static notBindable() {
    return new bt({
      type: "notbindable"
    });
  }
  static notCompatible(e, t) {
    return new bt({
      type: "notcompatible",
      context: {
        id: `${e}.${t}`
      }
    });
  }
  static propertyNotFound(e) {
    return new bt({
      type: "propertynotfound",
      context: {
        name: e
      }
    });
  }
  static shouldNeverHappen() {
    return new bt({ type: "shouldneverhappen" });
  }
  constructor(e) {
    var t;
    this.message = (t = aE[e.type](e.context)) !== null && t !== void 0 ? t : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = e.type;
  }
  toString() {
    return this.message;
  }
}
class Zr {
  constructor(e, t) {
    this.obj_ = e, this.key = t;
  }
  static isBindable(e) {
    return !(e === null || typeof e != "object" && typeof e != "function");
  }
  read() {
    return this.obj_[this.key];
  }
  write(e) {
    this.obj_[this.key] = e;
  }
  writeProperty(e, t) {
    const n = this.read();
    if (!Zr.isBindable(n))
      throw bt.notBindable();
    if (!(e in n))
      throw bt.propertyNotFound(e);
    n[e] = t;
  }
}
class wt {
  constructor() {
    this.observers_ = {};
  }
  on(e, t, n) {
    var s;
    let r = this.observers_[e];
    return r || (r = this.observers_[e] = []), r.push({
      handler: t,
      key: (s = n == null ? void 0 : n.key) !== null && s !== void 0 ? s : t
    }), this;
  }
  off(e, t) {
    const n = this.observers_[e];
    return n && (this.observers_[e] = n.filter((s) => s.key !== t)), this;
  }
  emit(e, t) {
    const n = this.observers_[e];
    n && n.forEach((s) => {
      s.handler(t);
    });
  }
}
class oE {
  constructor(e, t) {
    var n;
    this.constraint_ = t == null ? void 0 : t.constraint, this.equals_ = (n = t == null ? void 0 : t.equals) !== null && n !== void 0 ? n : (s, r) => s === r, this.emitter = new wt(), this.rawValue_ = e;
  }
  get constraint() {
    return this.constraint_;
  }
  get rawValue() {
    return this.rawValue_;
  }
  set rawValue(e) {
    this.setRawValue(e, {
      forceEmit: !1,
      last: !0
    });
  }
  setRawValue(e, t) {
    const n = t ?? {
      forceEmit: !1,
      last: !0
    }, s = this.constraint_ ? this.constraint_.constrain(e) : e, r = this.rawValue_;
    this.equals_(r, s) && !n.forceEmit || (this.emitter.emit("beforechange", {
      sender: this
    }), this.rawValue_ = s, this.emitter.emit("change", {
      options: n,
      previousRawValue: r,
      rawValue: s,
      sender: this
    }));
  }
}
class lE {
  constructor(e) {
    this.emitter = new wt(), this.value_ = e;
  }
  get rawValue() {
    return this.value_;
  }
  set rawValue(e) {
    this.setRawValue(e, {
      forceEmit: !1,
      last: !0
    });
  }
  setRawValue(e, t) {
    const n = t ?? {
      forceEmit: !1,
      last: !0
    }, s = this.value_;
    s === e && !n.forceEmit || (this.emitter.emit("beforechange", {
      sender: this
    }), this.value_ = e, this.emitter.emit("change", {
      options: n,
      previousRawValue: s,
      rawValue: this.value_,
      sender: this
    }));
  }
}
class cE {
  constructor(e) {
    this.emitter = new wt(), this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.value_ = e, this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_);
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  onValueBeforeChange_(e) {
    this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), { sender: this }));
  }
  onValueChange_(e) {
    this.emitter.emit("change", Object.assign(Object.assign({}, e), { sender: this }));
  }
}
function dt(i, e) {
  const t = e == null ? void 0 : e.constraint, n = e == null ? void 0 : e.equals;
  return !t && !n ? new lE(i) : new oE(i, e);
}
function hE(i) {
  return [
    new cE(i),
    (e, t) => {
      i.setRawValue(e, t);
    }
  ];
}
class ke {
  constructor(e) {
    this.emitter = new wt(), this.valMap_ = e;
    for (const t in this.valMap_)
      this.valMap_[t].emitter.on("change", () => {
        this.emitter.emit("change", {
          key: t,
          sender: this
        });
      });
  }
  static createCore(e) {
    return Object.keys(e).reduce((n, s) => Object.assign(n, {
      [s]: dt(e[s])
    }), {});
  }
  static fromObject(e) {
    const t = this.createCore(e);
    return new ke(t);
  }
  get(e) {
    return this.valMap_[e].rawValue;
  }
  set(e, t) {
    this.valMap_[e].rawValue = t;
  }
  value(e) {
    return this.valMap_[e];
  }
}
class nr {
  constructor(e) {
    this.values = ke.fromObject({
      max: e.max,
      min: e.min
    });
  }
  constrain(e) {
    const t = this.values.get("max"), n = this.values.get("min");
    return Math.min(Math.max(e, n), t);
  }
}
class uE {
  constructor(e) {
    this.values = ke.fromObject({
      max: e.max,
      min: e.min
    });
  }
  constrain(e) {
    const t = this.values.get("max"), n = this.values.get("min");
    let s = e;
    return ct(n) || (s = Math.max(s, n)), ct(t) || (s = Math.min(s, t)), s;
  }
}
class dE {
  constructor(e, t = 0) {
    this.step = e, this.origin = t;
  }
  constrain(e) {
    const t = this.origin % this.step, n = Math.round((e - t) / this.step);
    return t + n * this.step;
  }
}
class pE {
  constructor(e) {
    this.text = e;
  }
  evaluate() {
    return Number(this.text);
  }
  toString() {
    return this.text;
  }
}
const AE = {
  "**": (i, e) => Math.pow(i, e),
  "*": (i, e) => i * e,
  "/": (i, e) => i / e,
  "%": (i, e) => i % e,
  "+": (i, e) => i + e,
  "-": (i, e) => i - e,
  "<<": (i, e) => i << e,
  ">>": (i, e) => i >> e,
  ">>>": (i, e) => i >>> e,
  "&": (i, e) => i & e,
  "^": (i, e) => i ^ e,
  "|": (i, e) => i | e
};
class fE {
  constructor(e, t, n) {
    this.left = t, this.operator = e, this.right = n;
  }
  evaluate() {
    const e = AE[this.operator];
    if (!e)
      throw new Error(`unexpected binary operator: '${this.operator}`);
    return e(this.left.evaluate(), this.right.evaluate());
  }
  toString() {
    return [
      "b(",
      this.left.toString(),
      this.operator,
      this.right.toString(),
      ")"
    ].join(" ");
  }
}
const mE = {
  "+": (i) => i,
  "-": (i) => -i,
  "~": (i) => ~i
};
class gE {
  constructor(e, t) {
    this.operator = e, this.expression = t;
  }
  evaluate() {
    const e = mE[this.operator];
    if (!e)
      throw new Error(`unexpected unary operator: '${this.operator}`);
    return e(this.expression.evaluate());
  }
  toString() {
    return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
  }
}
function tl(i) {
  return (e, t) => {
    for (let n = 0; n < i.length; n++) {
      const s = i[n](e, t);
      if (s !== "")
        return s;
    }
    return "";
  };
}
function Ks(i, e) {
  var t;
  const n = i.substr(e).match(/^\s+/);
  return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function bE(i, e) {
  const t = i.substr(e, 1);
  return t.match(/^[1-9]$/) ? t : "";
}
function Xs(i, e) {
  var t;
  const n = i.substr(e).match(/^[0-9]+/);
  return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function vE(i, e) {
  const t = Xs(i, e);
  if (t !== "")
    return t;
  const n = i.substr(e, 1);
  if (e += 1, n !== "-" && n !== "+")
    return "";
  const s = Xs(i, e);
  return s === "" ? "" : n + s;
}
function nl(i, e) {
  const t = i.substr(e, 1);
  if (e += 1, t.toLowerCase() !== "e")
    return "";
  const n = vE(i, e);
  return n === "" ? "" : t + n;
}
function Eu(i, e) {
  const t = i.substr(e, 1);
  if (t === "0")
    return t;
  const n = bE(i, e);
  return e += n.length, n === "" ? "" : n + Xs(i, e);
}
function EE(i, e) {
  const t = Eu(i, e);
  if (e += t.length, t === "")
    return "";
  const n = i.substr(e, 1);
  if (e += n.length, n !== ".")
    return "";
  const s = Xs(i, e);
  return e += s.length, t + n + s + nl(i, e);
}
function CE(i, e) {
  const t = i.substr(e, 1);
  if (e += t.length, t !== ".")
    return "";
  const n = Xs(i, e);
  return e += n.length, n === "" ? "" : t + n + nl(i, e);
}
function xE(i, e) {
  const t = Eu(i, e);
  return e += t.length, t === "" ? "" : t + nl(i, e);
}
const wE = tl([
  EE,
  CE,
  xE
]);
function yE(i, e) {
  var t;
  const n = i.substr(e).match(/^[01]+/);
  return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function IE(i, e) {
  const t = i.substr(e, 2);
  if (e += t.length, t.toLowerCase() !== "0b")
    return "";
  const n = yE(i, e);
  return n === "" ? "" : t + n;
}
function ME(i, e) {
  var t;
  const n = i.substr(e).match(/^[0-7]+/);
  return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function SE(i, e) {
  const t = i.substr(e, 2);
  if (e += t.length, t.toLowerCase() !== "0o")
    return "";
  const n = ME(i, e);
  return n === "" ? "" : t + n;
}
function BE(i, e) {
  var t;
  const n = i.substr(e).match(/^[0-9a-f]+/i);
  return (t = n && n[0]) !== null && t !== void 0 ? t : "";
}
function TE(i, e) {
  const t = i.substr(e, 2);
  if (e += t.length, t.toLowerCase() !== "0x")
    return "";
  const n = BE(i, e);
  return n === "" ? "" : t + n;
}
const RE = tl([
  IE,
  SE,
  TE
]), DE = tl([
  RE,
  wE
]);
function PE(i, e) {
  const t = DE(i, e);
  return e += t.length, t === "" ? null : {
    evaluable: new pE(t),
    cursor: e
  };
}
function LE(i, e) {
  const t = i.substr(e, 1);
  if (e += t.length, t !== "(")
    return null;
  const n = xu(i, e);
  if (!n)
    return null;
  e = n.cursor, e += Ks(i, e).length;
  const s = i.substr(e, 1);
  return e += s.length, s !== ")" ? null : {
    evaluable: n.evaluable,
    cursor: e
  };
}
function FE(i, e) {
  var t;
  return (t = PE(i, e)) !== null && t !== void 0 ? t : LE(i, e);
}
function Cu(i, e) {
  const t = FE(i, e);
  if (t)
    return t;
  const n = i.substr(e, 1);
  if (e += n.length, n !== "+" && n !== "-" && n !== "~")
    return null;
  const s = Cu(i, e);
  return s ? (e = s.cursor, {
    cursor: e,
    evaluable: new gE(n, s.evaluable)
  }) : null;
}
function NE(i, e, t) {
  t += Ks(e, t).length;
  const n = i.filter((s) => e.startsWith(s, t))[0];
  return n ? (t += n.length, t += Ks(e, t).length, {
    cursor: t,
    operator: n
  }) : null;
}
function UE(i, e) {
  return (t, n) => {
    const s = i(t, n);
    if (!s)
      return null;
    n = s.cursor;
    let r = s.evaluable;
    for (; ; ) {
      const a = NE(e, t, n);
      if (!a)
        break;
      n = a.cursor;
      const o = i(t, n);
      if (!o)
        return null;
      n = o.cursor, r = new fE(a.operator, r, o.evaluable);
    }
    return r ? {
      cursor: n,
      evaluable: r
    } : null;
  };
}
const QE = [
  ["**"],
  ["*", "/", "%"],
  ["+", "-"],
  ["<<", ">>>", ">>"],
  ["&"],
  ["^"],
  ["|"]
].reduce((i, e) => UE(i, e), Cu);
function xu(i, e) {
  return e += Ks(i, e).length, QE(i, e);
}
function kE(i) {
  const e = xu(i, 0);
  return !e || e.cursor + Ks(i, e.cursor).length !== i.length ? null : e.evaluable;
}
function Xn(i) {
  var e;
  const t = kE(i);
  return (e = t == null ? void 0 : t.evaluate()) !== null && e !== void 0 ? e : null;
}
function wu(i) {
  if (typeof i == "number")
    return i;
  if (typeof i == "string") {
    const e = Xn(i);
    if (!ct(e))
      return e;
  }
  return 0;
}
function _E(i) {
  return String(i);
}
function Xt(i) {
  return (e) => e.toFixed(Math.max(Math.min(i, 20), 0));
}
function nt(i, e, t, n, s) {
  const r = (i - e) / (t - e);
  return n + r * (s - n);
}
function ih(i) {
  return String(i.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
}
function yt(i, e, t) {
  return Math.min(Math.max(i, e), t);
}
function yu(i, e) {
  return (i % e + e) % e;
}
function OE(i, e) {
  return ct(i.step) ? Math.max(ih(e), 2) : ih(i.step);
}
function Iu(i) {
  var e;
  return (e = i.step) !== null && e !== void 0 ? e : 1;
}
function Mu(i, e) {
  var t;
  const n = Math.abs((t = i.step) !== null && t !== void 0 ? t : e);
  return n === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(n)) - 1);
}
function Su(i, e) {
  return ct(i.step) ? null : new dE(i.step, e);
}
function Bu(i) {
  return !ct(i.max) && !ct(i.min) ? new nr({
    max: i.max,
    min: i.min
  }) : !ct(i.max) || !ct(i.min) ? new uE({
    max: i.max,
    min: i.min
  }) : null;
}
function Tu(i, e) {
  var t, n, s;
  return {
    formatter: (t = i.format) !== null && t !== void 0 ? t : Xt(OE(i, e)),
    keyScale: (n = i.keyScale) !== null && n !== void 0 ? n : Iu(i),
    pointerScale: (s = i.pointerScale) !== null && s !== void 0 ? s : Mu(i, e)
  };
}
function Ru(i) {
  return {
    format: i.optional.function,
    keyScale: i.optional.number,
    max: i.optional.number,
    min: i.optional.number,
    pointerScale: i.optional.number,
    step: i.optional.number
  };
}
function il(i) {
  return {
    constraint: i.constraint,
    textProps: ke.fromObject(Tu(i.params, i.initialValue))
  };
}
class _i {
  constructor(e) {
    this.controller = e;
  }
  get element() {
    return this.controller.view.element;
  }
  get disabled() {
    return this.controller.viewProps.get("disabled");
  }
  set disabled(e) {
    this.controller.viewProps.set("disabled", e);
  }
  get hidden() {
    return this.controller.viewProps.get("hidden");
  }
  set hidden(e) {
    this.controller.viewProps.set("hidden", e);
  }
  dispose() {
    this.controller.viewProps.set("disposed", !0);
  }
  importState(e) {
    return this.controller.importState(e);
  }
  exportState() {
    return this.controller.exportState();
  }
}
class ca {
  constructor(e) {
    this.target = e;
  }
}
class ir extends ca {
  constructor(e, t, n) {
    super(e), this.value = t, this.last = n ?? !0;
  }
}
class GE extends ca {
  constructor(e, t) {
    super(e), this.expanded = t;
  }
}
class HE extends ca {
  constructor(e, t) {
    super(e), this.index = t;
  }
}
class VE extends ca {
  constructor(e, t) {
    super(e), this.native = t;
  }
}
class js extends _i {
  constructor(e) {
    super(e), this.onValueChange_ = this.onValueChange_.bind(this), this.emitter_ = new wt(), this.controller.value.emitter.on("change", this.onValueChange_);
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(e) {
    this.controller.labelController.props.set("label", e);
  }
  get key() {
    return this.controller.value.binding.target.key;
  }
  get tag() {
    return this.controller.tag;
  }
  set tag(e) {
    this.controller.tag = e;
  }
  on(e, t) {
    const n = t.bind(this);
    return this.emitter_.on(e, (s) => {
      n(s);
    }, {
      key: t
    }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
  refresh() {
    this.controller.value.fetch();
  }
  onValueChange_(e) {
    const t = this.controller.value;
    this.emitter_.emit("change", new ir(this, t.binding.target.read(), e.options.last));
  }
}
class zE {
  constructor(e, t) {
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.binding = t, this.value_ = e, this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_), this.emitter = new wt();
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  set rawValue(e) {
    this.value_.rawValue = e;
  }
  setRawValue(e, t) {
    this.value_.setRawValue(e, t);
  }
  fetch() {
    this.value_.rawValue = this.binding.read();
  }
  push() {
    this.binding.write(this.value_.rawValue);
  }
  onValueBeforeChange_(e) {
    this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), { sender: this }));
  }
  onValueChange_(e) {
    this.push(), this.emitter.emit("change", Object.assign(Object.assign({}, e), { sender: this }));
  }
}
function qE(i) {
  if (!("binding" in i))
    return !1;
  const e = i.binding;
  return el(e) && "read" in e && "write" in e;
}
function WE(i, e) {
  const n = Object.keys(e).reduce((s, r) => {
    if (s === void 0)
      return;
    const a = e[r], o = a(i[r]);
    return o.succeeded ? Object.assign(Object.assign({}, s), { [r]: o.value }) : void 0;
  }, {});
  return n;
}
function YE(i, e) {
  return i.reduce((t, n) => {
    if (t === void 0)
      return;
    const s = e(n);
    if (!(!s.succeeded || s.value === void 0))
      return [...t, s.value];
  }, []);
}
function KE(i) {
  return i === null ? !1 : typeof i == "object";
}
function _n(i) {
  return (e) => (t) => {
    if (!e && t === void 0)
      return {
        succeeded: !1,
        value: void 0
      };
    if (e && t === void 0)
      return {
        succeeded: !0,
        value: void 0
      };
    const n = i(t);
    return n !== void 0 ? {
      succeeded: !0,
      value: n
    } : {
      succeeded: !1,
      value: void 0
    };
  };
}
function sh(i) {
  return {
    custom: (e) => _n(e)(i),
    boolean: _n((e) => typeof e == "boolean" ? e : void 0)(i),
    number: _n((e) => typeof e == "number" ? e : void 0)(i),
    string: _n((e) => typeof e == "string" ? e : void 0)(i),
    function: _n((e) => typeof e == "function" ? e : void 0)(i),
    constant: (e) => _n((t) => t === e ? e : void 0)(i),
    raw: _n((e) => e)(i),
    object: (e) => _n((t) => {
      if (KE(t))
        return WE(t, e);
    })(i),
    array: (e) => _n((t) => {
      if (Array.isArray(t))
        return YE(t, e);
    })(i)
  };
}
const wo = {
  optional: sh(!0),
  required: sh(!1)
};
function ft(i, e) {
  const t = e(wo), n = wo.required.object(t)(i);
  return n.succeeded ? n.value : void 0;
}
function $t(i, e, t, n) {
  if (e && !e(i))
    return !1;
  const s = ft(i, t);
  return s ? n(s) : !1;
}
function en(i, e) {
  var t;
  return Ni((t = i == null ? void 0 : i()) !== null && t !== void 0 ? t : {}, e);
}
function Fi(i) {
  return "value" in i;
}
function Du(i) {
  if (!$o(i) || !("binding" in i))
    return !1;
  const e = i.binding;
  return el(e);
}
const wn = "http://www.w3.org/2000/svg";
function $r(i) {
  i.offsetHeight;
}
function XE(i, e) {
  const t = i.style.transition;
  i.style.transition = "none", e(), i.style.transition = t;
}
function sl(i) {
  return i.ontouchstart !== void 0;
}
function jE() {
  return globalThis;
}
function JE() {
  return jE().document;
}
function ZE(i) {
  const e = i.ownerDocument.defaultView;
  return e && "document" in e ? i.getContext("2d", {
    willReadFrequently: !0
  }) : null;
}
const $E = {
  check: '<path d="M2 8l4 4l8 -8"/>',
  dropdown: '<path d="M5 7h6l-3 3 z"/>',
  p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
};
function ha(i, e) {
  const t = i.createElementNS(wn, "svg");
  return t.innerHTML = $E[e], t;
}
function Pu(i, e, t) {
  i.insertBefore(e, i.children[t]);
}
function rl(i) {
  i.parentElement && i.parentElement.removeChild(i);
}
function Lu(i) {
  for (; i.children.length > 0; )
    i.removeChild(i.children[0]);
}
function e0(i) {
  for (; i.childNodes.length > 0; )
    i.removeChild(i.childNodes[0]);
}
function Fu(i) {
  return i.relatedTarget ? i.relatedTarget : "explicitOriginalTarget" in i ? i.explicitOriginalTarget : null;
}
function Yn(i, e) {
  i.emitter.on("change", (t) => {
    e(t.rawValue);
  }), e(i.rawValue);
}
function Sn(i, e, t) {
  Yn(i.value(e), t);
}
const t0 = "tp";
function Xe(i) {
  return (t, n) => [
    t0,
    "-",
    i,
    "v",
    t ? `_${t}` : "",
    n ? `-${n}` : ""
  ].join("");
}
const Qs = Xe("lbl");
function n0(i, e) {
  const t = i.createDocumentFragment();
  return e.split(`
`).map((s) => i.createTextNode(s)).forEach((s, r) => {
    r > 0 && t.appendChild(i.createElement("br")), t.appendChild(s);
  }), t;
}
class Nu {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Qs()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("div");
    n.classList.add(Qs("l")), Sn(t.props, "label", (r) => {
      ct(r) ? this.element.classList.add(Qs(void 0, "nol")) : (this.element.classList.remove(Qs(void 0, "nol")), e0(n), n.appendChild(n0(e, r)));
    }), this.element.appendChild(n), this.labelElement = n;
    const s = e.createElement("div");
    s.classList.add(Qs("v")), this.element.appendChild(s), this.valueElement = s;
  }
}
class Uu {
  constructor(e, t) {
    this.props = t.props, this.valueController = t.valueController, this.viewProps = t.valueController.viewProps, this.view = new Nu(e, {
      props: t.props,
      viewProps: this.viewProps
    }), this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importProps(e) {
    return $t(e, null, (t) => ({
      label: t.optional.string
    }), (t) => (this.props.set("label", t.label), !0));
  }
  exportProps() {
    return en(null, {
      label: this.props.get("label")
    });
  }
}
function i0() {
  return ["veryfirst", "first", "last", "verylast"];
}
const rh = Xe(""), ah = {
  veryfirst: "vfst",
  first: "fst",
  last: "lst",
  verylast: "vlst"
};
class ua {
  constructor(e) {
    this.parent_ = null, this.blade = e.blade, this.view = e.view, this.viewProps = e.viewProps;
    const t = this.view.element;
    this.blade.value("positions").emitter.on("change", () => {
      i0().forEach((n) => {
        t.classList.remove(rh(void 0, ah[n]));
      }), this.blade.get("positions").forEach((n) => {
        t.classList.add(rh(void 0, ah[n]));
      });
    }), this.viewProps.handleDispose(() => {
      rl(t);
    });
  }
  get parent() {
    return this.parent_;
  }
  set parent(e) {
    this.parent_ = e, this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
  }
  importState(e) {
    return $t(e, null, (t) => ({
      disabled: t.required.boolean,
      hidden: t.required.boolean
    }), (t) => (this.viewProps.importState(t), !0));
  }
  exportState() {
    return en(null, Object.assign({}, this.viewProps.exportState()));
  }
}
class Ui extends ua {
  constructor(e, t) {
    if (t.value !== t.valueController.value)
      throw bt.shouldNeverHappen();
    const n = t.valueController.viewProps, s = new Uu(e, {
      blade: t.blade,
      props: t.props,
      valueController: t.valueController
    });
    super(Object.assign(Object.assign({}, t), { view: new Nu(e, {
      props: t.props,
      viewProps: n
    }), viewProps: n })), this.labelController = s, this.value = t.value, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importState(e) {
    return $t(e, (t) => {
      var n, s, r;
      return super.importState(t) && this.labelController.importProps(t) && ((r = (s = (n = this.valueController).importProps) === null || s === void 0 ? void 0 : s.call(n, e)) !== null && r !== void 0 ? r : !0);
    }, (t) => ({
      value: t.optional.raw
    }), (t) => (t.value && (this.value.rawValue = t.value), !0));
  }
  exportState() {
    var e, t, n;
    return en(() => super.exportState(), Object.assign(Object.assign({ value: this.value.rawValue }, this.labelController.exportProps()), (n = (t = (e = this.valueController).exportProps) === null || t === void 0 ? void 0 : t.call(e)) !== null && n !== void 0 ? n : {}));
  }
}
function oh(i) {
  const e = Object.assign({}, i);
  return delete e.value, e;
}
class Qu extends Ui {
  constructor(e, t) {
    super(e, t), this.tag = t.tag;
  }
  importState(e) {
    return $t(
      e,
      (t) => super.importState(oh(e)),
      (t) => ({
        tag: t.optional.string
      }),
      (t) => (this.tag = t.tag, !0)
    );
  }
  exportState() {
    return en(() => oh(super.exportState()), {
      binding: {
        key: this.value.binding.target.key,
        value: this.value.binding.target.read()
      },
      tag: this.tag
    });
  }
}
function s0(i) {
  return Fi(i) && Du(i.value);
}
class r0 extends Qu {
  importState(e) {
    return $t(e, (t) => super.importState(t), (t) => ({
      binding: t.required.object({
        value: t.required.raw
      })
    }), (t) => (this.value.binding.inject(t.binding.value), this.value.fetch(), !0));
  }
}
function a0(i) {
  return Fi(i) && qE(i.value);
}
function ku(i, e) {
  for (; i.length < e; )
    i.push(void 0);
}
function o0(i) {
  const e = [];
  return ku(e, i), e;
}
function l0(i) {
  const e = i.indexOf(void 0);
  return e < 0 ? i : i.slice(0, e);
}
function c0(i, e) {
  const t = [...l0(i), e];
  return t.length > i.length ? t.splice(0, t.length - i.length) : ku(t, i.length), t;
}
class h0 {
  constructor(e) {
    this.emitter = new wt(), this.onTick_ = this.onTick_.bind(this), this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.binding = e.binding, this.value_ = dt(o0(e.bufferSize)), this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_), this.ticker = e.ticker, this.ticker.emitter.on("tick", this.onTick_), this.fetch();
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  set rawValue(e) {
    this.value_.rawValue = e;
  }
  setRawValue(e, t) {
    this.value_.setRawValue(e, t);
  }
  fetch() {
    this.value_.rawValue = c0(this.value_.rawValue, this.binding.read());
  }
  onTick_() {
    this.fetch();
  }
  onValueBeforeChange_(e) {
    this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), { sender: this }));
  }
  onValueChange_(e) {
    this.emitter.emit("change", Object.assign(Object.assign({}, e), { sender: this }));
  }
}
function u0(i) {
  if (!("binding" in i))
    return !1;
  const e = i.binding;
  return el(e) && "read" in e && !("write" in e);
}
class d0 extends Qu {
  exportState() {
    return en(() => super.exportState(), {
      binding: {
        readonly: !0
      }
    });
  }
}
function p0(i) {
  return Fi(i) && u0(i.value);
}
class A0 extends _i {
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(e) {
    this.controller.labelController.props.set("label", e);
  }
  get title() {
    var e;
    return (e = this.controller.buttonController.props.get("title")) !== null && e !== void 0 ? e : "";
  }
  set title(e) {
    this.controller.buttonController.props.set("title", e);
  }
  on(e, t) {
    const n = t.bind(this);
    return this.controller.buttonController.emitter.on(e, (r) => {
      n(new VE(this, r.nativeEvent));
    }), this;
  }
  off(e, t) {
    return this.controller.buttonController.emitter.off(e, t), this;
  }
}
function f0(i, e, t) {
  t ? i.classList.add(e) : i.classList.remove(e);
}
function xs(i, e) {
  return (t) => {
    f0(i, e, t);
  };
}
function al(i, e) {
  Yn(i, (t) => {
    e.textContent = t ?? "";
  });
}
const oo = Xe("btn");
class m0 {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(oo()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("button");
    n.classList.add(oo("b")), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n;
    const s = e.createElement("div");
    s.classList.add(oo("t")), al(t.props.value("title"), s), this.buttonElement.appendChild(s);
  }
}
class g0 {
  constructor(e, t) {
    this.emitter = new wt(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new m0(e, {
      props: this.props,
      viewProps: this.viewProps
    }), this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  importProps(e) {
    return $t(e, null, (t) => ({
      title: t.optional.string
    }), (t) => (this.props.set("title", t.title), !0));
  }
  exportProps() {
    return en(null, {
      title: this.props.get("title")
    });
  }
  onClick_(e) {
    this.emitter.emit("click", {
      nativeEvent: e,
      sender: this
    });
  }
}
class lh extends ua {
  constructor(e, t) {
    const n = new g0(e, {
      props: t.buttonProps,
      viewProps: t.viewProps
    }), s = new Uu(e, {
      blade: t.blade,
      props: t.labelProps,
      valueController: n
    });
    super({
      blade: t.blade,
      view: s.view,
      viewProps: t.viewProps
    }), this.buttonController = n, this.labelController = s;
  }
  importState(e) {
    return $t(e, (t) => super.importState(t) && this.buttonController.importProps(t) && this.labelController.importProps(t), () => ({}), () => !0);
  }
  exportState() {
    return en(() => super.exportState(), Object.assign(Object.assign({}, this.buttonController.exportProps()), this.labelController.exportProps()));
  }
}
class _u {
  constructor(e) {
    const [t, n] = e.split("-"), s = t.split(".");
    this.major = parseInt(s[0], 10), this.minor = parseInt(s[1], 10), this.patch = parseInt(s[2], 10), this.prerelease = n ?? null;
  }
  toString() {
    const e = [this.major, this.minor, this.patch].join(".");
    return this.prerelease !== null ? [e, this.prerelease].join("-") : e;
  }
}
const ws = new _u("2.0.5");
function zt(i) {
  return Object.assign({ core: ws }, i);
}
const b0 = zt({
  id: "button",
  type: "blade",
  accept(i) {
    const e = ft(i, (t) => ({
      title: t.required.string,
      view: t.required.constant("button"),
      label: t.optional.string
    }));
    return e ? { params: e } : null;
  },
  controller(i) {
    return new lh(i.document, {
      blade: i.blade,
      buttonProps: ke.fromObject({
        title: i.params.title
      }),
      labelProps: ke.fromObject({
        label: i.params.label
      }),
      viewProps: i.viewProps
    });
  },
  api(i) {
    return i.controller instanceof lh ? new A0(i.controller) : null;
  }
});
function v0(i, e) {
  return i.addBlade(Object.assign(Object.assign({}, e), { view: "button" }));
}
function E0(i, e) {
  return i.addBlade(Object.assign(Object.assign({}, e), { view: "folder" }));
}
function C0(i, e) {
  return i.addBlade(Object.assign(Object.assign({}, e), { view: "tab" }));
}
function x0(i) {
  return $o(i) ? "refresh" in i && typeof i.refresh == "function" : !1;
}
function w0(i, e) {
  if (!Zr.isBindable(i))
    throw bt.notBindable();
  return new Zr(i, e);
}
class y0 {
  constructor(e, t) {
    this.onRackValueChange_ = this.onRackValueChange_.bind(this), this.controller_ = e, this.emitter_ = new wt(), this.pool_ = t, this.controller_.rack.emitter.on("valuechange", this.onRackValueChange_);
  }
  get children() {
    return this.controller_.rack.children.map((e) => this.pool_.createApi(e));
  }
  addBinding(e, t, n) {
    const s = n ?? {}, r = this.controller_.element.ownerDocument, a = this.pool_.createBinding(r, w0(e, t), s), o = this.pool_.createBindingApi(a);
    return this.add(o, s.index);
  }
  addFolder(e) {
    return E0(this, e);
  }
  addButton(e) {
    return v0(this, e);
  }
  addTab(e) {
    return C0(this, e);
  }
  add(e, t) {
    const n = e.controller;
    return this.controller_.rack.add(n, t), e;
  }
  remove(e) {
    this.controller_.rack.remove(e.controller);
  }
  addBlade(e) {
    const t = this.controller_.element.ownerDocument, n = this.pool_.createBlade(t, e), s = this.pool_.createApi(n);
    return this.add(s, e.index);
  }
  on(e, t) {
    const n = t.bind(this);
    return this.emitter_.on(e, (s) => {
      n(s);
    }, {
      key: t
    }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
  refresh() {
    this.children.forEach((e) => {
      x0(e) && e.refresh();
    });
  }
  onRackValueChange_(e) {
    const t = e.bladeController, n = this.pool_.createApi(t), s = Du(t.value) ? t.value.binding : null;
    this.emitter_.emit("change", new ir(n, s ? s.target.read() : t.value.rawValue, e.options.last));
  }
}
class ol extends _i {
  constructor(e, t) {
    super(e), this.rackApi_ = new y0(e.rackController, t);
  }
  refresh() {
    this.rackApi_.refresh();
  }
}
class ll extends ua {
  constructor(e) {
    super({
      blade: e.blade,
      view: e.view,
      viewProps: e.rackController.viewProps
    }), this.rackController = e.rackController;
  }
  importState(e) {
    return $t(e, (t) => super.importState(t), (t) => ({
      children: t.required.array(t.required.raw)
    }), (t) => this.rackController.rack.children.every((n, s) => n.importState(t.children[s])));
  }
  exportState() {
    return en(() => super.exportState(), {
      children: this.rackController.rack.children.map((e) => e.exportState())
    });
  }
}
function yo(i) {
  return "rackController" in i;
}
class I0 {
  constructor(e) {
    this.emitter = new wt(), this.items_ = [], this.cache_ = /* @__PURE__ */ new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = e;
  }
  get items() {
    return this.items_;
  }
  allItems() {
    return Array.from(this.cache_);
  }
  find(e) {
    for (const t of this.allItems())
      if (e(t))
        return t;
    return null;
  }
  includes(e) {
    return this.cache_.has(e);
  }
  add(e, t) {
    if (this.includes(e))
      throw bt.shouldNeverHappen();
    const n = t !== void 0 ? t : this.items_.length;
    this.items_.splice(n, 0, e), this.cache_.add(e);
    const s = this.extract_(e);
    s && (s.emitter.on("add", this.onSubListAdd_), s.emitter.on("remove", this.onSubListRemove_), s.allItems().forEach((r) => {
      this.cache_.add(r);
    })), this.emitter.emit("add", {
      index: n,
      item: e,
      root: this,
      target: this
    });
  }
  remove(e) {
    const t = this.items_.indexOf(e);
    if (t < 0)
      return;
    this.items_.splice(t, 1), this.cache_.delete(e);
    const n = this.extract_(e);
    n && (n.allItems().forEach((s) => {
      this.cache_.delete(s);
    }), n.emitter.off("add", this.onSubListAdd_), n.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
      index: t,
      item: e,
      root: this,
      target: this
    });
  }
  onSubListAdd_(e) {
    this.cache_.add(e.item), this.emitter.emit("add", {
      index: e.index,
      item: e.item,
      root: this,
      target: e.target
    });
  }
  onSubListRemove_(e) {
    this.cache_.delete(e.item), this.emitter.emit("remove", {
      index: e.index,
      item: e.item,
      root: this,
      target: e.target
    });
  }
}
function M0(i, e) {
  for (let t = 0; t < i.length; t++) {
    const n = i[t];
    if (Fi(n) && n.value === e)
      return n;
  }
  return null;
}
function S0(i) {
  return yo(i) ? i.rackController.rack.bcSet_ : null;
}
class B0 {
  constructor(e) {
    var t, n;
    this.emitter = new wt(), this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onRackLayout_ = this.onRackLayout_.bind(this), this.onRackValueChange_ = this.onRackValueChange_.bind(this), this.blade_ = (t = e.blade) !== null && t !== void 0 ? t : null, (n = this.blade_) === null || n === void 0 || n.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = e.viewProps, this.bcSet_ = new I0(S0), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
  }
  get children() {
    return this.bcSet_.items;
  }
  add(e, t) {
    var n;
    (n = e.parent) === null || n === void 0 || n.remove(e), e.parent = this, this.bcSet_.add(e, t);
  }
  remove(e) {
    e.parent = null, this.bcSet_.remove(e);
  }
  find(e) {
    return this.bcSet_.allItems().filter(e);
  }
  onSetAdd_(e) {
    this.updatePositions_();
    const t = e.target === e.root;
    if (this.emitter.emit("add", {
      bladeController: e.item,
      index: e.index,
      root: t,
      sender: this
    }), !t)
      return;
    const n = e.item;
    if (n.viewProps.emitter.on("change", this.onChildViewPropsChange_), n.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), n.viewProps.handleDispose(this.onChildDispose_), Fi(n))
      n.value.emitter.on("change", this.onChildValueChange_);
    else if (yo(n)) {
      const s = n.rackController.rack;
      if (s) {
        const r = s.emitter;
        r.on("layout", this.onRackLayout_), r.on("valuechange", this.onRackValueChange_);
      }
    }
  }
  onSetRemove_(e) {
    this.updatePositions_();
    const t = e.target === e.root;
    if (this.emitter.emit("remove", {
      bladeController: e.item,
      root: t,
      sender: this
    }), !t)
      return;
    const n = e.item;
    if (Fi(n))
      n.value.emitter.off("change", this.onChildValueChange_);
    else if (yo(n)) {
      const s = n.rackController.rack;
      if (s) {
        const r = s.emitter;
        r.off("layout", this.onRackLayout_), r.off("valuechange", this.onRackValueChange_);
      }
    }
  }
  updatePositions_() {
    const e = this.bcSet_.items.filter((s) => !s.viewProps.get("hidden")), t = e[0], n = e[e.length - 1];
    this.bcSet_.items.forEach((s) => {
      const r = [];
      s === t && (r.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && r.push("veryfirst")), s === n && (r.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && r.push("verylast")), s.blade.set("positions", r);
    });
  }
  onChildPositionsChange_() {
    this.updatePositions_(), this.emitter.emit("layout", {
      sender: this
    });
  }
  onChildViewPropsChange_(e) {
    this.updatePositions_(), this.emitter.emit("layout", {
      sender: this
    });
  }
  onChildDispose_() {
    this.bcSet_.items.filter((t) => t.viewProps.get("disposed")).forEach((t) => {
      this.bcSet_.remove(t);
    });
  }
  onChildValueChange_(e) {
    const t = M0(this.find(Fi), e.sender);
    if (!t)
      throw bt.alreadyDisposed();
    this.emitter.emit("valuechange", {
      bladeController: t,
      options: e.options,
      sender: this
    });
  }
  onRackLayout_(e) {
    this.updatePositions_(), this.emitter.emit("layout", {
      sender: this
    });
  }
  onRackValueChange_(e) {
    this.emitter.emit("valuechange", {
      bladeController: e.bladeController,
      options: e.options,
      sender: this
    });
  }
  onBladePositionsChange_() {
    this.updatePositions_();
  }
}
class cl {
  constructor(e) {
    this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.element = e.element, this.viewProps = e.viewProps;
    const t = new B0({
      blade: e.root ? void 0 : e.blade,
      viewProps: e.viewProps
    });
    t.emitter.on("add", this.onRackAdd_), t.emitter.on("remove", this.onRackRemove_), this.rack = t, this.viewProps.handleDispose(() => {
      for (let n = this.rack.children.length - 1; n >= 0; n--)
        this.rack.children[n].viewProps.set("disposed", !0);
    });
  }
  onRackAdd_(e) {
    e.root && Pu(this.element, e.bladeController.view.element, e.index);
  }
  onRackRemove_(e) {
    e.root && rl(e.bladeController.view.element);
  }
}
function ys() {
  return new ke({
    positions: dt([], {
      equals: rE
    })
  });
}
class sr extends ke {
  constructor(e) {
    super(e);
  }
  static create(e) {
    const t = {
      completed: !0,
      expanded: e,
      expandedHeight: null,
      shouldFixHeight: !1,
      temporaryExpanded: null
    }, n = ke.createCore(t);
    return new sr(n);
  }
  get styleExpanded() {
    var e;
    return (e = this.get("temporaryExpanded")) !== null && e !== void 0 ? e : this.get("expanded");
  }
  get styleHeight() {
    if (!this.styleExpanded)
      return "0";
    const e = this.get("expandedHeight");
    return this.get("shouldFixHeight") && !ct(e) ? `${e}px` : "auto";
  }
  bindExpandedClass(e, t) {
    const n = () => {
      this.styleExpanded ? e.classList.add(t) : e.classList.remove(t);
    };
    Sn(this, "expanded", n), Sn(this, "temporaryExpanded", n);
  }
  cleanUpTransition() {
    this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0);
  }
}
function T0(i, e) {
  let t = 0;
  return XE(e, () => {
    i.set("expandedHeight", null), i.set("temporaryExpanded", !0), $r(e), t = e.clientHeight, i.set("temporaryExpanded", null), $r(e);
  }), t;
}
function ch(i, e) {
  e.style.height = i.styleHeight;
}
function hl(i, e) {
  i.value("expanded").emitter.on("beforechange", () => {
    if (i.set("completed", !1), ct(i.get("expandedHeight"))) {
      const t = T0(i, e);
      t > 0 && i.set("expandedHeight", t);
    }
    i.set("shouldFixHeight", !0), $r(e);
  }), i.emitter.on("change", () => {
    ch(i, e);
  }), ch(i, e), e.addEventListener("transitionend", (t) => {
    t.propertyName === "height" && i.cleanUpTransition();
  });
}
class Ou extends ol {
  constructor(e, t) {
    super(e, t), this.emitter_ = new wt(), this.controller.foldable.value("expanded").emitter.on("change", (n) => {
      this.emitter_.emit("fold", new GE(this, n.sender.rawValue));
    }), this.rackApi_.on("change", (n) => {
      this.emitter_.emit("change", n);
    });
  }
  get expanded() {
    return this.controller.foldable.get("expanded");
  }
  set expanded(e) {
    this.controller.foldable.set("expanded", e);
  }
  get title() {
    return this.controller.props.get("title");
  }
  set title(e) {
    this.controller.props.set("title", e);
  }
  get children() {
    return this.rackApi_.children;
  }
  addBinding(e, t, n) {
    return this.rackApi_.addBinding(e, t, n);
  }
  addFolder(e) {
    return this.rackApi_.addFolder(e);
  }
  addButton(e) {
    return this.rackApi_.addButton(e);
  }
  addTab(e) {
    return this.rackApi_.addTab(e);
  }
  add(e, t) {
    return this.rackApi_.add(e, t);
  }
  remove(e) {
    this.rackApi_.remove(e);
  }
  addBlade(e) {
    return this.rackApi_.addBlade(e);
  }
  on(e, t) {
    const n = t.bind(this);
    return this.emitter_.on(e, (s) => {
      n(s);
    }, {
      key: t
    }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
}
const Gu = Xe("cnt");
class R0 {
  constructor(e, t) {
    var n;
    this.className_ = Xe((n = t.viewName) !== null && n !== void 0 ? n : "fld"), this.element = e.createElement("div"), this.element.classList.add(this.className_(), Gu()), t.viewProps.bindClassModifiers(this.element), this.foldable_ = t.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), Sn(this.foldable_, "completed", xs(this.element, this.className_(void 0, "cpl")));
    const s = e.createElement("button");
    s.classList.add(this.className_("b")), Sn(t.props, "title", (c) => {
      ct(c) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
    }), t.viewProps.bindDisabled(s), this.element.appendChild(s), this.buttonElement = s;
    const r = e.createElement("div");
    r.classList.add(this.className_("i")), this.element.appendChild(r);
    const a = e.createElement("div");
    a.classList.add(this.className_("t")), al(t.props.value("title"), a), this.buttonElement.appendChild(a), this.titleElement = a;
    const o = e.createElement("div");
    o.classList.add(this.className_("m")), this.buttonElement.appendChild(o);
    const l = e.createElement("div");
    l.classList.add(this.className_("c")), this.element.appendChild(l), this.containerElement = l;
  }
}
class Io extends ll {
  constructor(e, t) {
    var n;
    const s = sr.create((n = t.expanded) !== null && n !== void 0 ? n : !0), r = new R0(e, {
      foldable: s,
      props: t.props,
      viewName: t.root ? "rot" : void 0,
      viewProps: t.viewProps
    });
    super(Object.assign(Object.assign({}, t), { rackController: new cl({
      blade: t.blade,
      element: r.containerElement,
      root: t.root,
      viewProps: t.viewProps
    }), view: r })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = t.props, this.foldable = s, hl(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
      this.foldable.cleanUpTransition();
    }), this.rackController.rack.emitter.on("remove", () => {
      this.foldable.cleanUpTransition();
    }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
  }
  get document() {
    return this.view.element.ownerDocument;
  }
  importState(e) {
    return $t(e, (t) => super.importState(t), (t) => ({
      expanded: t.required.boolean,
      title: t.optional.string
    }), (t) => (this.foldable.set("expanded", t.expanded), this.props.set("title", t.title), !0));
  }
  exportState() {
    return en(() => super.exportState(), {
      expanded: this.foldable.get("expanded"),
      title: this.props.get("title")
    });
  }
  onTitleClick_() {
    this.foldable.set("expanded", !this.foldable.get("expanded"));
  }
}
const D0 = zt({
  id: "folder",
  type: "blade",
  accept(i) {
    const e = ft(i, (t) => ({
      title: t.required.string,
      view: t.required.constant("folder"),
      expanded: t.optional.boolean
    }));
    return e ? { params: e } : null;
  },
  controller(i) {
    return new Io(i.document, {
      blade: i.blade,
      expanded: i.params.expanded,
      props: ke.fromObject({
        title: i.params.title
      }),
      viewProps: i.viewProps
    });
  },
  api(i) {
    return i.controller instanceof Io ? new Ou(i.controller, i.pool) : null;
  }
}), P0 = Xe("");
function hh(i, e) {
  return xs(i, P0(void 0, e));
}
class Zn extends ke {
  constructor(e) {
    var t;
    super(e), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = hE(dt(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), (t = this.get("parent")) === null || t === void 0 || t.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
  }
  static create(e) {
    var t, n, s;
    const r = e ?? {};
    return new Zn(ke.createCore({
      disabled: (t = r.disabled) !== null && t !== void 0 ? t : !1,
      disposed: !1,
      hidden: (n = r.hidden) !== null && n !== void 0 ? n : !1,
      parent: (s = r.parent) !== null && s !== void 0 ? s : null
    }));
  }
  get globalDisabled() {
    return this.globalDisabled_;
  }
  bindClassModifiers(e) {
    Yn(this.globalDisabled_, hh(e, "disabled")), Sn(this, "hidden", hh(e, "hidden"));
  }
  bindDisabled(e) {
    Yn(this.globalDisabled_, (t) => {
      e.disabled = t;
    });
  }
  bindTabIndex(e) {
    Yn(this.globalDisabled_, (t) => {
      e.tabIndex = t ? -1 : 0;
    });
  }
  handleDispose(e) {
    this.value("disposed").emitter.on("change", (t) => {
      t && e();
    });
  }
  importState(e) {
    this.set("disabled", e.disabled), this.set("hidden", e.hidden);
  }
  exportState() {
    return {
      disabled: this.get("disabled"),
      hidden: this.get("hidden")
    };
  }
  getGlobalDisabled_() {
    const e = this.get("parent");
    return (e ? e.globalDisabled.rawValue : !1) || this.get("disabled");
  }
  updateGlobalDisabled_() {
    this.setGlobalDisabled_(this.getGlobalDisabled_());
  }
  onDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentGlobalDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentChange_(e) {
    var t;
    const n = e.previousRawValue;
    n == null || n.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), (t = this.get("parent")) === null || t === void 0 || t.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_();
  }
}
const uh = Xe("tbp");
class L0 {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(uh()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("div");
    n.classList.add(uh("c")), this.element.appendChild(n), this.containerElement = n;
  }
}
const ks = Xe("tbi");
class F0 {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(ks()), t.viewProps.bindClassModifiers(this.element), Sn(t.props, "selected", (r) => {
      r ? this.element.classList.add(ks(void 0, "sel")) : this.element.classList.remove(ks(void 0, "sel"));
    });
    const n = e.createElement("button");
    n.classList.add(ks("b")), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n;
    const s = e.createElement("div");
    s.classList.add(ks("t")), al(t.props.value("title"), s), this.buttonElement.appendChild(s), this.titleElement = s;
  }
}
class N0 {
  constructor(e, t) {
    this.emitter = new wt(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new F0(e, {
      props: t.props,
      viewProps: t.viewProps
    }), this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this
    });
  }
}
class Mo extends ll {
  constructor(e, t) {
    const n = new L0(e, {
      viewProps: t.viewProps
    });
    super(Object.assign(Object.assign({}, t), { rackController: new cl({
      blade: t.blade,
      element: n.containerElement,
      viewProps: t.viewProps
    }), view: n })), this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new N0(e, {
      props: t.itemProps,
      viewProps: Zn.create()
    }), this.ic_.emitter.on("click", this.onItemClick_), this.props = t.props, Sn(this.props, "selected", (s) => {
      this.itemController.props.set("selected", s), this.viewProps.set("hidden", !s);
    });
  }
  get itemController() {
    return this.ic_;
  }
  importState(e) {
    return $t(e, (t) => super.importState(t), (t) => ({
      selected: t.required.boolean,
      title: t.required.string
    }), (t) => (this.ic_.props.set("selected", t.selected), this.ic_.props.set("title", t.title), !0));
  }
  exportState() {
    return en(() => super.exportState(), {
      selected: this.ic_.props.get("selected"),
      title: this.ic_.props.get("title")
    });
  }
  onItemClick_() {
    this.props.set("selected", !0);
  }
}
class U0 extends ol {
  constructor(e, t) {
    super(e, t), this.emitter_ = new wt(), this.onSelect_ = this.onSelect_.bind(this), this.pool_ = t, this.rackApi_.on("change", (n) => {
      this.emitter_.emit("change", n);
    }), this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_);
  }
  get pages() {
    return this.rackApi_.children;
  }
  addPage(e) {
    const t = this.controller.view.element.ownerDocument, n = new Mo(t, {
      blade: ys(),
      itemProps: ke.fromObject({
        selected: !1,
        title: e.title
      }),
      props: ke.fromObject({
        selected: !1
      }),
      viewProps: Zn.create()
    }), s = this.pool_.createApi(n);
    return this.rackApi_.add(s, e.index);
  }
  removePage(e) {
    this.rackApi_.remove(this.rackApi_.children[e]);
  }
  on(e, t) {
    const n = t.bind(this);
    return this.emitter_.on(e, (s) => {
      n(s);
    }, {
      key: t
    }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
  onSelect_(e) {
    this.emitter_.emit("select", new HE(this, e.rawValue));
  }
}
class Q0 extends ol {
  get title() {
    var e;
    return (e = this.controller.itemController.props.get("title")) !== null && e !== void 0 ? e : "";
  }
  set title(e) {
    this.controller.itemController.props.set("title", e);
  }
  get selected() {
    return this.controller.props.get("selected");
  }
  set selected(e) {
    this.controller.props.set("selected", e);
  }
  get children() {
    return this.rackApi_.children;
  }
  addButton(e) {
    return this.rackApi_.addButton(e);
  }
  addFolder(e) {
    return this.rackApi_.addFolder(e);
  }
  addTab(e) {
    return this.rackApi_.addTab(e);
  }
  add(e, t) {
    this.rackApi_.add(e, t);
  }
  remove(e) {
    this.rackApi_.remove(e);
  }
  addBinding(e, t, n) {
    return this.rackApi_.addBinding(e, t, n);
  }
  addBlade(e) {
    return this.rackApi_.addBlade(e);
  }
}
const dh = -1;
class k0 {
  constructor() {
    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = dt(!0), this.selectedIndex = dt(dh), this.items_ = [];
  }
  add(e, t) {
    const n = t ?? this.items_.length;
    this.items_.splice(n, 0, e), e.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_();
  }
  remove(e) {
    const t = this.items_.indexOf(e);
    t < 0 || (this.items_.splice(t, 1), e.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_());
  }
  keepSelection_() {
    if (this.items_.length === 0) {
      this.selectedIndex.rawValue = dh, this.empty.rawValue = !0;
      return;
    }
    const e = this.items_.findIndex((t) => t.rawValue);
    e < 0 ? (this.items_.forEach((t, n) => {
      t.rawValue = n === 0;
    }), this.selectedIndex.rawValue = 0) : (this.items_.forEach((t, n) => {
      t.rawValue = n === e;
    }), this.selectedIndex.rawValue = e), this.empty.rawValue = !1;
  }
  onItemSelectedChange_(e) {
    if (e.rawValue) {
      const t = this.items_.findIndex((n) => n === e.sender);
      this.items_.forEach((n, s) => {
        n.rawValue = s === t;
      }), this.selectedIndex.rawValue = t;
    } else
      this.keepSelection_();
  }
}
const _s = Xe("tab");
class _0 {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(_s(), Gu()), t.viewProps.bindClassModifiers(this.element), Yn(t.empty, xs(this.element, _s(void 0, "nop")));
    const n = e.createElement("div");
    n.classList.add(_s("t")), this.element.appendChild(n), this.itemsElement = n;
    const s = e.createElement("div");
    s.classList.add(_s("i")), this.element.appendChild(s);
    const r = e.createElement("div");
    r.classList.add(_s("c")), this.element.appendChild(r), this.contentsElement = r;
  }
}
class ph extends ll {
  constructor(e, t) {
    const n = new k0(), s = new _0(e, {
      empty: n.empty,
      viewProps: t.viewProps
    });
    super({
      blade: t.blade,
      rackController: new cl({
        blade: t.blade,
        element: s.contentsElement,
        viewProps: t.viewProps
      }),
      view: s
    }), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
    const r = this.rackController.rack;
    r.emitter.on("add", this.onRackAdd_), r.emitter.on("remove", this.onRackRemove_), this.tab = n;
  }
  add(e, t) {
    this.rackController.rack.add(e, t);
  }
  remove(e) {
    this.rackController.rack.remove(this.rackController.rack.children[e]);
  }
  onRackAdd_(e) {
    if (!e.root)
      return;
    const t = e.bladeController;
    Pu(this.view.itemsElement, t.itemController.view.element, e.index), t.itemController.viewProps.set("parent", this.viewProps), this.tab.add(t.props.value("selected"));
  }
  onRackRemove_(e) {
    if (!e.root)
      return;
    const t = e.bladeController;
    rl(t.itemController.view.element), t.itemController.viewProps.set("parent", null), this.tab.remove(t.props.value("selected"));
  }
}
const Hu = zt({
  id: "tab",
  type: "blade",
  accept(i) {
    const e = ft(i, (t) => ({
      pages: t.required.array(t.required.object({ title: t.required.string })),
      view: t.required.constant("tab")
    }));
    return !e || e.pages.length === 0 ? null : { params: e };
  },
  controller(i) {
    const e = new ph(i.document, {
      blade: i.blade,
      viewProps: i.viewProps
    });
    return i.params.pages.forEach((t) => {
      const n = new Mo(i.document, {
        blade: ys(),
        itemProps: ke.fromObject({
          selected: !1,
          title: t.title
        }),
        props: ke.fromObject({
          selected: !1
        }),
        viewProps: Zn.create()
      });
      e.add(n);
    }), e;
  },
  api(i) {
    return i.controller instanceof ph ? new U0(i.controller, i.pool) : i.controller instanceof Mo ? new Q0(i.controller, i.pool) : null;
  }
});
function O0(i, e) {
  const t = i.accept(e.params);
  if (!t)
    return null;
  const n = ft(e.params, (s) => ({
    disabled: s.optional.boolean,
    hidden: s.optional.boolean
  }));
  return i.controller({
    blade: ys(),
    document: e.document,
    params: Object.assign(Object.assign({}, t.params), { disabled: n == null ? void 0 : n.disabled, hidden: n == null ? void 0 : n.hidden }),
    viewProps: Zn.create({
      disabled: n == null ? void 0 : n.disabled,
      hidden: n == null ? void 0 : n.hidden
    })
  });
}
class ul extends js {
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(e) {
    this.controller.valueController.props.set("options", e);
  }
}
class G0 {
  constructor() {
    this.disabled = !1, this.emitter = new wt();
  }
  dispose() {
  }
  tick() {
    this.disabled || this.emitter.emit("tick", {
      sender: this
    });
  }
}
class H0 {
  constructor(e, t) {
    this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = e, this.emitter = new wt(), this.interval_ = t, this.setTimer_();
  }
  get disabled() {
    return this.disabled_;
  }
  set disabled(e) {
    this.disabled_ = e, this.disabled_ ? this.clearTimer_() : this.setTimer_();
  }
  dispose() {
    this.clearTimer_();
  }
  clearTimer_() {
    if (this.timerId_ === null)
      return;
    const e = this.doc_.defaultView;
    e && e.clearInterval(this.timerId_), this.timerId_ = null;
  }
  setTimer_() {
    if (this.clearTimer_(), this.interval_ <= 0)
      return;
    const e = this.doc_.defaultView;
    e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_));
  }
  onTick_() {
    this.disabled_ || this.emitter.emit("tick", {
      sender: this
    });
  }
}
class rr {
  constructor(e) {
    this.constraints = e;
  }
  constrain(e) {
    return this.constraints.reduce((t, n) => n.constrain(t), e);
  }
}
function ea(i, e) {
  if (i instanceof e)
    return i;
  if (i instanceof rr) {
    const t = i.constraints.reduce((n, s) => n || (s instanceof e ? s : null), null);
    if (t)
      return t;
  }
  return null;
}
class ar {
  constructor(e) {
    this.values = ke.fromObject({
      options: e
    });
  }
  constrain(e) {
    const t = this.values.get("options");
    return t.length === 0 || t.filter((s) => s.value === e).length > 0 ? e : t[0].value;
  }
}
function or(i) {
  var e;
  const t = wo;
  if (Array.isArray(i))
    return (e = ft({ items: i }, (n) => ({
      items: n.required.array(n.required.object({
        text: n.required.string,
        value: n.required.raw
      }))
    }))) === null || e === void 0 ? void 0 : e.items;
  if (typeof i == "object")
    return t.required.raw(i).value;
}
function dl(i) {
  if (Array.isArray(i))
    return i;
  const e = [];
  return Object.keys(i).forEach((t) => {
    e.push({ text: t, value: i[t] });
  }), e;
}
function pl(i) {
  return ct(i) ? null : new ar(dl(i));
}
const lo = Xe("lst");
class V0 {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.element = e.createElement("div"), this.element.classList.add(lo()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("select");
    n.classList.add(lo("s")), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.selectElement = n;
    const s = e.createElement("div");
    s.classList.add(lo("m")), s.appendChild(ha(e, "dropdown")), this.element.appendChild(s), t.value.emitter.on("change", this.onValueChange_), this.value_ = t.value, Sn(this.props_, "options", (r) => {
      Lu(this.selectElement), r.forEach((a) => {
        const o = e.createElement("option");
        o.textContent = a.text, this.selectElement.appendChild(o);
      }), this.update_();
    });
  }
  update_() {
    const e = this.props_.get("options").map((t) => t.value);
    this.selectElement.selectedIndex = e.indexOf(this.value_.rawValue);
  }
  onValueChange_() {
    this.update_();
  }
}
class Ai {
  constructor(e, t) {
    this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new V0(e, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
  }
  onSelectChange_(e) {
    const t = e.currentTarget;
    this.value.rawValue = this.props.get("options")[t.selectedIndex].value;
  }
  importProps(e) {
    return $t(e, null, (t) => ({
      options: t.required.custom(or)
    }), (t) => (this.props.set("options", dl(t.options)), !0));
  }
  exportProps() {
    return en(null, {
      options: this.props.get("options")
    });
  }
}
const Ah = Xe("pop");
class z0 {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Ah()), t.viewProps.bindClassModifiers(this.element), Yn(t.shows, xs(this.element, Ah(void 0, "v")));
  }
}
class Vu {
  constructor(e, t) {
    this.shows = dt(!1), this.viewProps = t.viewProps, this.view = new z0(e, {
      shows: this.shows,
      viewProps: this.viewProps
    });
  }
}
const fh = Xe("txt");
class q0 {
  constructor(e, t) {
    this.onChange_ = this.onChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(fh()), t.viewProps.bindClassModifiers(this.element), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_);
    const n = e.createElement("input");
    n.classList.add(fh("i")), n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, t.value.emitter.on("change", this.onChange_), this.value_ = t.value, this.refresh();
  }
  refresh() {
    const e = this.props_.get("formatter");
    this.inputElement.value = e(this.value_.rawValue);
  }
  onChange_() {
    this.refresh();
  }
}
class Js {
  constructor(e, t) {
    this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new q0(e, {
      props: t.props,
      value: this.value,
      viewProps: this.viewProps
    }), this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const n = e.currentTarget.value, s = this.parser_(n);
    ct(s) || (this.value.rawValue = s), this.view.refresh();
  }
}
function W0(i) {
  return String(i);
}
function zu(i) {
  return i === "false" ? !1 : !!i;
}
function mh(i) {
  return W0(i);
}
function Y0(i) {
  return (e) => i.reduce((t, n) => t !== null ? t : n(e), null);
}
const K0 = Xt(0);
function ta(i) {
  return K0(i) + "%";
}
function qu(i) {
  return String(i);
}
function So(i) {
  return i;
}
function Is({ primary: i, secondary: e, forward: t, backward: n }) {
  let s = !1;
  function r(a) {
    s || (s = !0, a(), s = !1);
  }
  i.emitter.on("change", (a) => {
    r(() => {
      e.setRawValue(t(i.rawValue, e.rawValue), a.options);
    });
  }), e.emitter.on("change", (a) => {
    r(() => {
      i.setRawValue(n(i.rawValue, e.rawValue), a.options);
    }), r(() => {
      e.setRawValue(t(i.rawValue, e.rawValue), a.options);
    });
  }), r(() => {
    e.setRawValue(t(i.rawValue, e.rawValue), {
      forceEmit: !1,
      last: !0
    });
  });
}
function Kt(i, e) {
  const t = i * (e.altKey ? 0.1 : 1) * (e.shiftKey ? 10 : 1);
  return e.upKey ? +t : e.downKey ? -t : 0;
}
function Zs(i) {
  return {
    altKey: i.altKey,
    downKey: i.key === "ArrowDown",
    shiftKey: i.shiftKey,
    upKey: i.key === "ArrowUp"
  };
}
function jn(i) {
  return {
    altKey: i.altKey,
    downKey: i.key === "ArrowLeft",
    shiftKey: i.shiftKey,
    upKey: i.key === "ArrowRight"
  };
}
function X0(i) {
  return i === "ArrowUp" || i === "ArrowDown";
}
function Wu(i) {
  return X0(i) || i === "ArrowLeft" || i === "ArrowRight";
}
function co(i, e) {
  var t, n;
  const s = e.ownerDocument.defaultView, r = e.getBoundingClientRect();
  return {
    x: i.pageX - (((t = s && s.scrollX) !== null && t !== void 0 ? t : 0) + r.left),
    y: i.pageY - (((n = s && s.scrollY) !== null && n !== void 0 ? n : 0) + r.top)
  };
}
class Oi {
  constructor(e) {
    this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = e, this.emitter = new wt(), e.addEventListener("touchstart", this.onTouchStart_, {
      passive: !1
    }), e.addEventListener("touchmove", this.onTouchMove_, {
      passive: !0
    }), e.addEventListener("touchend", this.onTouchEnd_), e.addEventListener("mousedown", this.onMouseDown_);
  }
  computePosition_(e) {
    const t = this.elem_.getBoundingClientRect();
    return {
      bounds: {
        width: t.width,
        height: t.height
      },
      point: e ? {
        x: e.x,
        y: e.y
      } : null
    };
  }
  onMouseDown_(e) {
    var t;
    e.preventDefault(), (t = e.currentTarget) === null || t === void 0 || t.focus();
    const n = this.elem_.ownerDocument;
    n.addEventListener("mousemove", this.onDocumentMouseMove_), n.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
      altKey: e.altKey,
      data: this.computePosition_(co(e, this.elem_)),
      sender: this,
      shiftKey: e.shiftKey
    });
  }
  onDocumentMouseMove_(e) {
    this.emitter.emit("move", {
      altKey: e.altKey,
      data: this.computePosition_(co(e, this.elem_)),
      sender: this,
      shiftKey: e.shiftKey
    });
  }
  onDocumentMouseUp_(e) {
    const t = this.elem_.ownerDocument;
    t.removeEventListener("mousemove", this.onDocumentMouseMove_), t.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
      altKey: e.altKey,
      data: this.computePosition_(co(e, this.elem_)),
      sender: this,
      shiftKey: e.shiftKey
    });
  }
  onTouchStart_(e) {
    e.preventDefault();
    const t = e.targetTouches.item(0), n = this.elem_.getBoundingClientRect();
    this.emitter.emit("down", {
      altKey: e.altKey,
      data: this.computePosition_(t ? {
        x: t.clientX - n.left,
        y: t.clientY - n.top
      } : void 0),
      sender: this,
      shiftKey: e.shiftKey
    }), this.lastTouch_ = t;
  }
  onTouchMove_(e) {
    const t = e.targetTouches.item(0), n = this.elem_.getBoundingClientRect();
    this.emitter.emit("move", {
      altKey: e.altKey,
      data: this.computePosition_(t ? {
        x: t.clientX - n.left,
        y: t.clientY - n.top
      } : void 0),
      sender: this,
      shiftKey: e.shiftKey
    }), this.lastTouch_ = t;
  }
  onTouchEnd_(e) {
    var t;
    const n = (t = e.targetTouches.item(0)) !== null && t !== void 0 ? t : this.lastTouch_, s = this.elem_.getBoundingClientRect();
    this.emitter.emit("up", {
      altKey: e.altKey,
      data: this.computePosition_(n ? {
        x: n.clientX - s.left,
        y: n.clientY - s.top
      } : void 0),
      sender: this,
      shiftKey: e.shiftKey
    });
  }
}
const an = Xe("txt");
class j0 {
  constructor(e, t) {
    this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(an(), an(void 0, "num")), t.arrayPosition && this.element.classList.add(an(void 0, t.arrayPosition)), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("input");
    n.classList.add(an("i")), n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = t.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(an()), this.inputElement.classList.add(an("i"));
    const s = e.createElement("div");
    s.classList.add(an("k")), this.element.appendChild(s), this.knobElement = s;
    const r = e.createElementNS(wn, "svg");
    r.classList.add(an("g")), this.knobElement.appendChild(r);
    const a = e.createElementNS(wn, "path");
    a.classList.add(an("gb")), r.appendChild(a), this.guideBodyElem_ = a;
    const o = e.createElementNS(wn, "path");
    o.classList.add(an("gh")), r.appendChild(o), this.guideHeadElem_ = o;
    const l = e.createElement("div");
    l.classList.add(Xe("tt")()), this.knobElement.appendChild(l), this.tooltipElem_ = l, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.refresh();
  }
  onDraggingChange_(e) {
    if (e.rawValue === null) {
      this.element.classList.remove(an(void 0, "drg"));
      return;
    }
    this.element.classList.add(an(void 0, "drg"));
    const t = e.rawValue / this.props_.get("pointerScale"), n = t + (t > 0 ? -1 : t < 0 ? 1 : 0), s = yt(-n, -4, 4);
    this.guideHeadElem_.setAttributeNS(null, "d", [`M ${n + s},0 L${n},4 L${n + s},8`, `M ${t},-1 L${t},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t},4`);
    const r = this.props_.get("formatter");
    this.tooltipElem_.textContent = r(this.value.rawValue), this.tooltipElem_.style.left = `${t}px`;
  }
  refresh() {
    const e = this.props_.get("formatter");
    this.inputElement.value = e(this.value.rawValue);
  }
  onChange_() {
    this.refresh();
  }
}
class lr {
  constructor(e, t) {
    var n;
    this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.parser_ = t.parser, this.props = t.props, this.sliderProps_ = (n = t.sliderProps) !== null && n !== void 0 ? n : null, this.value = t.value, this.viewProps = t.viewProps, this.dragging_ = dt(null), this.view = new j0(e, {
      arrayPosition: t.arrayPosition,
      dragging: this.dragging_,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
    const s = new Oi(this.view.knobElement);
    s.emitter.on("down", this.onPointerDown_), s.emitter.on("move", this.onPointerMove_), s.emitter.on("up", this.onPointerUp_);
  }
  constrainValue_(e) {
    var t, n;
    const s = (t = this.sliderProps_) === null || t === void 0 ? void 0 : t.get("min"), r = (n = this.sliderProps_) === null || n === void 0 ? void 0 : n.get("max");
    let a = e;
    return s !== void 0 && (a = Math.max(a, s)), r !== void 0 && (a = Math.min(a, r)), a;
  }
  onInputChange_(e) {
    const n = e.currentTarget.value, s = this.parser_(n);
    ct(s) || (this.value.rawValue = this.constrainValue_(s)), this.view.refresh();
  }
  onInputKeyDown_(e) {
    const t = Kt(this.props.get("keyScale"), Zs(e));
    t !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + t), {
      forceEmit: !1,
      last: !1
    });
  }
  onInputKeyUp_(e) {
    Kt(this.props.get("keyScale"), Zs(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
  onPointerDown_() {
    this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
  }
  computeDraggingValue_(e) {
    if (!e.point)
      return null;
    const t = e.point.x - e.bounds.width / 2;
    return this.constrainValue_(this.originRawValue_ + t * this.props.get("pointerScale"));
  }
  onPointerMove_(e) {
    const t = this.computeDraggingValue_(e.data);
    t !== null && (this.value.setRawValue(t, {
      forceEmit: !1,
      last: !1
    }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
  }
  onPointerUp_(e) {
    const t = this.computeDraggingValue_(e.data);
    t !== null && (this.value.setRawValue(t, {
      forceEmit: !0,
      last: !0
    }), this.dragging_.rawValue = null);
  }
}
const ho = Xe("sld");
class J0 {
  constructor(e, t) {
    this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(ho()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("div");
    n.classList.add(ho("t")), t.viewProps.bindTabIndex(n), this.element.appendChild(n), this.trackElement = n;
    const s = e.createElement("div");
    s.classList.add(ho("k")), this.trackElement.appendChild(s), this.knobElement = s, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.update_();
  }
  update_() {
    const e = yt(nt(this.value.rawValue, this.props_.get("min"), this.props_.get("max"), 0, 100), 0, 100);
    this.knobElement.style.width = `${e}%`;
  }
  onChange_() {
    this.update_();
  }
}
class Z0 {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.props = t.props, this.view = new J0(e, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    }), this.ptHandler_ = new Oi(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    e.point && this.value.setRawValue(nt(yt(e.point.x, 0, e.bounds.width), 0, e.bounds.width, this.props.get("min"), this.props.get("max")), t);
  }
  onPointerDownOrMove_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !0,
      last: !0
    });
  }
  onKeyDown_(e) {
    const t = Kt(this.props.get("keyScale"), jn(e));
    t !== 0 && this.value.setRawValue(this.value.rawValue + t, {
      forceEmit: !1,
      last: !1
    });
  }
  onKeyUp_(e) {
    Kt(this.props.get("keyScale"), jn(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
}
const uo = Xe("sldtxt");
class $0 {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(uo());
    const n = e.createElement("div");
    n.classList.add(uo("s")), this.sliderView_ = t.sliderView, n.appendChild(this.sliderView_.element), this.element.appendChild(n);
    const s = e.createElement("div");
    s.classList.add(uo("t")), this.textView_ = t.textView, s.appendChild(this.textView_.element), this.element.appendChild(s);
  }
}
class na {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.sliderC_ = new Z0(e, {
      props: t.sliderProps,
      value: t.value,
      viewProps: this.viewProps
    }), this.textC_ = new lr(e, {
      parser: t.parser,
      props: t.textProps,
      sliderProps: t.sliderProps,
      value: t.value,
      viewProps: t.viewProps
    }), this.view = new $0(e, {
      sliderView: this.sliderC_.view,
      textView: this.textC_.view
    });
  }
  get sliderController() {
    return this.sliderC_;
  }
  get textController() {
    return this.textC_;
  }
  importProps(e) {
    return $t(e, null, (t) => ({
      max: t.required.number,
      min: t.required.number
    }), (t) => {
      const n = this.sliderC_.props;
      return n.set("max", t.max), n.set("min", t.min), !0;
    });
  }
  exportProps() {
    const e = this.sliderC_.props;
    return en(null, {
      max: e.get("max"),
      min: e.get("min")
    });
  }
}
function Yu(i) {
  return {
    sliderProps: new ke({
      keyScale: i.keyScale,
      max: i.max,
      min: i.min
    }),
    textProps: new ke({
      formatter: dt(i.formatter),
      keyScale: i.keyScale,
      pointerScale: dt(i.pointerScale)
    })
  };
}
const eC = {
  containerUnitSize: "cnt-usz"
};
function Ku(i) {
  return `--${eC[i]}`;
}
function $s(i) {
  return Ru(i);
}
function ui(i) {
  if (xo(i))
    return ft(i, $s);
}
function Vn(i, e) {
  if (!i)
    return;
  const t = [], n = Su(i, e);
  n && t.push(n);
  const s = Bu(i);
  return s && t.push(s), new rr(t);
}
function tC(i) {
  return i ? i.major === ws.major : !1;
}
function Xu(i) {
  if (i === "inline" || i === "popup")
    return i;
}
function cr(i, e) {
  i.write(e);
}
const zr = Xe("ckb");
class nC {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(zr()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("label");
    n.classList.add(zr("l")), this.element.appendChild(n), this.labelElement = n;
    const s = e.createElement("input");
    s.classList.add(zr("i")), s.type = "checkbox", this.labelElement.appendChild(s), this.inputElement = s, t.viewProps.bindDisabled(this.inputElement);
    const r = e.createElement("div");
    r.classList.add(zr("w")), this.labelElement.appendChild(r);
    const a = ha(e, "check");
    r.appendChild(a), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
  }
  update_() {
    this.inputElement.checked = this.value.rawValue;
  }
  onValueChange_() {
    this.update_();
  }
}
class iC {
  constructor(e, t) {
    this.onInputChange_ = this.onInputChange_.bind(this), this.onLabelMouseDown_ = this.onLabelMouseDown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new nC(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.labelElement.addEventListener("mousedown", this.onLabelMouseDown_);
  }
  onInputChange_(e) {
    const t = e.currentTarget;
    this.value.rawValue = t.checked, e.preventDefault(), e.stopPropagation();
  }
  onLabelMouseDown_(e) {
    e.preventDefault();
  }
}
function sC(i) {
  const e = [], t = pl(i.options);
  return t && e.push(t), new rr(e);
}
const rC = zt({
  id: "input-bool",
  type: "input",
  accept: (i, e) => {
    if (typeof i != "boolean")
      return null;
    const t = ft(e, (n) => ({
      options: n.optional.custom(or),
      readonly: n.optional.constant(!1)
    }));
    return t ? {
      initialValue: i,
      params: t
    } : null;
  },
  binding: {
    reader: (i) => zu,
    constraint: (i) => sC(i.params),
    writer: (i) => cr
  },
  controller: (i) => {
    const e = i.document, t = i.value, n = i.constraint, s = n && ea(n, ar);
    return s ? new Ai(e, {
      props: new ke({
        options: s.values.value("options")
      }),
      value: t,
      viewProps: i.viewProps
    }) : new iC(e, {
      value: t,
      viewProps: i.viewProps
    });
  },
  api(i) {
    return typeof i.controller.value.rawValue != "boolean" ? null : i.controller.valueController instanceof Ai ? new ul(i.controller) : null;
  }
}), yi = Xe("col");
class aC {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(yi()), t.foldable.bindExpandedClass(this.element, yi(void 0, "expanded")), Sn(t.foldable, "completed", xs(this.element, yi(void 0, "cpl")));
    const n = e.createElement("div");
    n.classList.add(yi("h")), this.element.appendChild(n);
    const s = e.createElement("div");
    s.classList.add(yi("s")), n.appendChild(s), this.swatchElement = s;
    const r = e.createElement("div");
    if (r.classList.add(yi("t")), n.appendChild(r), this.textElement = r, t.pickerLayout === "inline") {
      const a = e.createElement("div");
      a.classList.add(yi("p")), this.element.appendChild(a), this.pickerElement = a;
    } else
      this.pickerElement = null;
  }
}
function oC(i, e, t) {
  const n = yt(i / 255, 0, 1), s = yt(e / 255, 0, 1), r = yt(t / 255, 0, 1), a = Math.max(n, s, r), o = Math.min(n, s, r), l = a - o;
  let c = 0, h = 0;
  const u = (o + a) / 2;
  return l !== 0 && (h = l / (1 - Math.abs(a + o - 1)), n === a ? c = (s - r) / l : s === a ? c = 2 + (r - n) / l : c = 4 + (n - s) / l, c = c / 6 + (c < 0 ? 1 : 0)), [c * 360, h * 100, u * 100];
}
function lC(i, e, t) {
  const n = (i % 360 + 360) % 360, s = yt(e / 100, 0, 1), r = yt(t / 100, 0, 1), a = (1 - Math.abs(2 * r - 1)) * s, o = a * (1 - Math.abs(n / 60 % 2 - 1)), l = r - a / 2;
  let c, h, u;
  return n >= 0 && n < 60 ? [c, h, u] = [a, o, 0] : n >= 60 && n < 120 ? [c, h, u] = [o, a, 0] : n >= 120 && n < 180 ? [c, h, u] = [0, a, o] : n >= 180 && n < 240 ? [c, h, u] = [0, o, a] : n >= 240 && n < 300 ? [c, h, u] = [o, 0, a] : [c, h, u] = [a, 0, o], [(c + l) * 255, (h + l) * 255, (u + l) * 255];
}
function cC(i, e, t) {
  const n = yt(i / 255, 0, 1), s = yt(e / 255, 0, 1), r = yt(t / 255, 0, 1), a = Math.max(n, s, r), o = Math.min(n, s, r), l = a - o;
  let c;
  l === 0 ? c = 0 : a === n ? c = 60 * (((s - r) / l % 6 + 6) % 6) : a === s ? c = 60 * ((r - n) / l + 2) : c = 60 * ((n - s) / l + 4);
  const h = a === 0 ? 0 : l / a, u = a;
  return [c, h * 100, u * 100];
}
function ju(i, e, t) {
  const n = yu(i, 360), s = yt(e / 100, 0, 1), r = yt(t / 100, 0, 1), a = r * s, o = a * (1 - Math.abs(n / 60 % 2 - 1)), l = r - a;
  let c, h, u;
  return n >= 0 && n < 60 ? [c, h, u] = [a, o, 0] : n >= 60 && n < 120 ? [c, h, u] = [o, a, 0] : n >= 120 && n < 180 ? [c, h, u] = [0, a, o] : n >= 180 && n < 240 ? [c, h, u] = [0, o, a] : n >= 240 && n < 300 ? [c, h, u] = [o, 0, a] : [c, h, u] = [a, 0, o], [(c + l) * 255, (h + l) * 255, (u + l) * 255];
}
function hC(i, e, t) {
  const n = t + e * (100 - Math.abs(2 * t - 100)) / 200;
  return [
    i,
    n !== 0 ? e * (100 - Math.abs(2 * t - 100)) / n : 0,
    t + e * (100 - Math.abs(2 * t - 100)) / (2 * 100)
  ];
}
function uC(i, e, t) {
  const n = 100 - Math.abs(t * (200 - e) / 100 - 100);
  return [i, n !== 0 ? e * t / n : 0, t * (200 - e) / (2 * 100)];
}
function Bn(i) {
  return [i[0], i[1], i[2]];
}
function da(i, e) {
  return [i[0], i[1], i[2], e];
}
const dC = {
  hsl: {
    hsl: (i, e, t) => [i, e, t],
    hsv: hC,
    rgb: lC
  },
  hsv: {
    hsl: uC,
    hsv: (i, e, t) => [i, e, t],
    rgb: ju
  },
  rgb: {
    hsl: oC,
    hsv: cC,
    rgb: (i, e, t) => [i, e, t]
  }
};
function gs(i, e) {
  return [
    e === "float" ? 1 : i === "rgb" ? 255 : 360,
    e === "float" ? 1 : i === "rgb" ? 255 : 100,
    e === "float" ? 1 : i === "rgb" ? 255 : 100
  ];
}
function pC(i, e) {
  return i === e ? e : yu(i, e);
}
function Ju(i, e, t) {
  var n;
  const s = gs(e, t);
  return [
    e === "rgb" ? yt(i[0], 0, s[0]) : pC(i[0], s[0]),
    yt(i[1], 0, s[1]),
    yt(i[2], 0, s[2]),
    yt((n = i[3]) !== null && n !== void 0 ? n : 1, 0, 1)
  ];
}
function gh(i, e, t, n) {
  const s = gs(e, t), r = gs(e, n);
  return i.map((a, o) => a / s[o] * r[o]);
}
function Zu(i, e, t) {
  const n = gh(i, e.mode, e.type, "int"), s = dC[e.mode][t.mode](...n);
  return gh(s, t.mode, "int", t.type);
}
class Je {
  static black() {
    return new Je([0, 0, 0], "rgb");
  }
  constructor(e, t) {
    this.type = "int", this.mode = t, this.comps_ = Ju(e, t, this.type);
  }
  getComponents(e) {
    return da(Zu(Bn(this.comps_), { mode: this.mode, type: this.type }, { mode: e ?? this.mode, type: this.type }), this.comps_[3]);
  }
  toRgbaObject() {
    const e = this.getComponents("rgb");
    return {
      r: e[0],
      g: e[1],
      b: e[2],
      a: e[3]
    };
  }
}
const oi = Xe("colp");
class AC {
  constructor(e, t) {
    this.alphaViews_ = null, this.element = e.createElement("div"), this.element.classList.add(oi()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("div");
    n.classList.add(oi("hsv"));
    const s = e.createElement("div");
    s.classList.add(oi("sv")), this.svPaletteView_ = t.svPaletteView, s.appendChild(this.svPaletteView_.element), n.appendChild(s);
    const r = e.createElement("div");
    r.classList.add(oi("h")), this.hPaletteView_ = t.hPaletteView, r.appendChild(this.hPaletteView_.element), n.appendChild(r), this.element.appendChild(n);
    const a = e.createElement("div");
    if (a.classList.add(oi("rgb")), this.textsView_ = t.textsView, a.appendChild(this.textsView_.element), this.element.appendChild(a), t.alphaViews) {
      this.alphaViews_ = {
        palette: t.alphaViews.palette,
        text: t.alphaViews.text
      };
      const o = e.createElement("div");
      o.classList.add(oi("a"));
      const l = e.createElement("div");
      l.classList.add(oi("ap")), l.appendChild(this.alphaViews_.palette.element), o.appendChild(l);
      const c = e.createElement("div");
      c.classList.add(oi("at")), c.appendChild(this.alphaViews_.text.element), o.appendChild(c), this.element.appendChild(o);
    }
  }
  get allFocusableElements() {
    const e = [
      this.svPaletteView_.element,
      this.hPaletteView_.element,
      this.textsView_.modeSelectElement,
      ...this.textsView_.inputViews.map((t) => t.inputElement)
    ];
    return this.alphaViews_ && e.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), e;
  }
}
function fC(i) {
  return i === "int" ? "int" : i === "float" ? "float" : void 0;
}
function Al(i) {
  return ft(i, (e) => ({
    color: e.optional.object({
      alpha: e.optional.boolean,
      type: e.optional.custom(fC)
    }),
    expanded: e.optional.boolean,
    picker: e.optional.custom(Xu),
    readonly: e.optional.constant(!1)
  }));
}
function Qi(i) {
  return i ? 0.1 : 1;
}
function $u(i) {
  var e;
  return (e = i.color) === null || e === void 0 ? void 0 : e.type;
}
class fl {
  constructor(e, t) {
    this.type = "float", this.mode = t, this.comps_ = Ju(e, t, this.type);
  }
  getComponents(e) {
    return da(Zu(Bn(this.comps_), { mode: this.mode, type: this.type }, { mode: e ?? this.mode, type: this.type }), this.comps_[3]);
  }
  toRgbaObject() {
    const e = this.getComponents("rgb");
    return {
      r: e[0],
      g: e[1],
      b: e[2],
      a: e[3]
    };
  }
}
const mC = {
  int: (i, e) => new Je(i, e),
  float: (i, e) => new fl(i, e)
};
function ml(i, e, t) {
  return mC[t](i, e);
}
function gC(i) {
  return i.type === "float";
}
function bC(i) {
  return i.type === "int";
}
function vC(i) {
  const e = i.getComponents(), t = gs(i.mode, "int");
  return new Je([
    Math.round(nt(e[0], 0, 1, 0, t[0])),
    Math.round(nt(e[1], 0, 1, 0, t[1])),
    Math.round(nt(e[2], 0, 1, 0, t[2])),
    e[3]
  ], i.mode);
}
function EC(i) {
  const e = i.getComponents(), t = gs(i.mode, "int");
  return new fl([
    nt(e[0], 0, t[0], 0, 1),
    nt(e[1], 0, t[1], 0, 1),
    nt(e[2], 0, t[2], 0, 1),
    e[3]
  ], i.mode);
}
function Vt(i, e) {
  if (i.type === e)
    return i;
  if (bC(i) && e === "float")
    return EC(i);
  if (gC(i) && e === "int")
    return vC(i);
  throw bt.shouldNeverHappen();
}
function CC(i, e) {
  return i.alpha === e.alpha && i.mode === e.mode && i.notation === e.notation && i.type === e.type;
}
function un(i, e) {
  const t = i.match(/^(.+)%$/);
  return Math.min(t ? parseFloat(t[1]) * 0.01 * e : parseFloat(i), e);
}
const xC = {
  deg: (i) => i,
  grad: (i) => i * 360 / 400,
  rad: (i) => i * 360 / (2 * Math.PI),
  turn: (i) => i * 360
};
function ed(i) {
  const e = i.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
  if (!e)
    return parseFloat(i);
  const t = parseFloat(e[1]), n = e[2];
  return xC[n](t);
}
function td(i) {
  const e = i.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!e)
    return null;
  const t = [
    un(e[1], 255),
    un(e[2], 255),
    un(e[3], 255)
  ];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function wC(i) {
  const e = td(i);
  return e ? new Je(e, "rgb") : null;
}
function nd(i) {
  const e = i.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!e)
    return null;
  const t = [
    un(e[1], 255),
    un(e[2], 255),
    un(e[3], 255),
    un(e[4], 1)
  ];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function yC(i) {
  const e = nd(i);
  return e ? new Je(e, "rgb") : null;
}
function id(i) {
  const e = i.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!e)
    return null;
  const t = [
    ed(e[1]),
    un(e[2], 100),
    un(e[3], 100)
  ];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function IC(i) {
  const e = id(i);
  return e ? new Je(e, "hsl") : null;
}
function sd(i) {
  const e = i.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!e)
    return null;
  const t = [
    ed(e[1]),
    un(e[2], 100),
    un(e[3], 100),
    un(e[4], 1)
  ];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function MC(i) {
  const e = sd(i);
  return e ? new Je(e, "hsl") : null;
}
function rd(i) {
  const e = i.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (e)
    return [
      parseInt(e[1] + e[1], 16),
      parseInt(e[2] + e[2], 16),
      parseInt(e[3] + e[3], 16)
    ];
  const t = i.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
  return t ? [
    parseInt(t[1], 16),
    parseInt(t[2], 16),
    parseInt(t[3], 16)
  ] : null;
}
function SC(i) {
  const e = rd(i);
  return e ? new Je(e, "rgb") : null;
}
function ad(i) {
  const e = i.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (e)
    return [
      parseInt(e[1] + e[1], 16),
      parseInt(e[2] + e[2], 16),
      parseInt(e[3] + e[3], 16),
      nt(parseInt(e[4] + e[4], 16), 0, 255, 0, 1)
    ];
  const t = i.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
  return t ? [
    parseInt(t[1], 16),
    parseInt(t[2], 16),
    parseInt(t[3], 16),
    nt(parseInt(t[4], 16), 0, 255, 0, 1)
  ] : null;
}
function BC(i) {
  const e = ad(i);
  return e ? new Je(e, "rgb") : null;
}
function od(i) {
  const e = i.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
  if (!e)
    return null;
  const t = [
    parseFloat(e[1]),
    parseFloat(e[2]),
    parseFloat(e[3])
  ];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function TC(i) {
  return (e) => {
    const t = od(e);
    return t ? ml(t, "rgb", i) : null;
  };
}
function ld(i) {
  const e = i.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
  if (!e)
    return null;
  const t = [
    parseFloat(e[1]),
    parseFloat(e[2]),
    parseFloat(e[3]),
    parseFloat(e[4])
  ];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function RC(i) {
  return (e) => {
    const t = ld(e);
    return t ? ml(t, "rgb", i) : null;
  };
}
const DC = [
  {
    parser: rd,
    result: {
      alpha: !1,
      mode: "rgb",
      notation: "hex"
    }
  },
  {
    parser: ad,
    result: {
      alpha: !0,
      mode: "rgb",
      notation: "hex"
    }
  },
  {
    parser: td,
    result: {
      alpha: !1,
      mode: "rgb",
      notation: "func"
    }
  },
  {
    parser: nd,
    result: {
      alpha: !0,
      mode: "rgb",
      notation: "func"
    }
  },
  {
    parser: id,
    result: {
      alpha: !1,
      mode: "hsl",
      notation: "func"
    }
  },
  {
    parser: sd,
    result: {
      alpha: !0,
      mode: "hsl",
      notation: "func"
    }
  },
  {
    parser: od,
    result: {
      alpha: !1,
      mode: "rgb",
      notation: "object"
    }
  },
  {
    parser: ld,
    result: {
      alpha: !0,
      mode: "rgb",
      notation: "object"
    }
  }
];
function PC(i) {
  return DC.reduce((e, { parser: t, result: n }) => e || (t(i) ? n : null), null);
}
function LC(i, e = "int") {
  const t = PC(i);
  return t ? t.notation === "hex" && e !== "float" ? Object.assign(Object.assign({}, t), { type: "int" }) : t.notation === "func" ? Object.assign(Object.assign({}, t), { type: e }) : null : null;
}
function hr(i) {
  const e = [
    SC,
    BC,
    wC,
    yC,
    IC,
    MC
  ];
  e.push(TC("int"), RC("int"));
  const t = Y0(e);
  return (n) => {
    const s = t(n);
    return s ? Vt(s, i) : null;
  };
}
function FC(i) {
  const e = hr("int");
  if (typeof i != "string")
    return Je.black();
  const t = e(i);
  return t ?? Je.black();
}
function cd(i) {
  const e = yt(Math.floor(i), 0, 255).toString(16);
  return e.length === 1 ? `0${e}` : e;
}
function gl(i, e = "#") {
  const t = Bn(i.getComponents("rgb")).map(cd).join("");
  return `${e}${t}`;
}
function bl(i, e = "#") {
  const t = i.getComponents("rgb"), n = [t[0], t[1], t[2], t[3] * 255].map(cd).join("");
  return `${e}${n}`;
}
function hd(i) {
  const e = Xt(0), t = Vt(i, "int");
  return `rgb(${Bn(t.getComponents("rgb")).map((s) => e(s)).join(", ")})`;
}
function Wr(i) {
  const e = Xt(2), t = Xt(0);
  return `rgba(${Vt(i, "int").getComponents("rgb").map((r, a) => (a === 3 ? e : t)(r)).join(", ")})`;
}
function NC(i) {
  const e = [
    Xt(0),
    ta,
    ta
  ], t = Vt(i, "int");
  return `hsl(${Bn(t.getComponents("hsl")).map((s, r) => e[r](s)).join(", ")})`;
}
function UC(i) {
  const e = [
    Xt(0),
    ta,
    ta,
    Xt(2)
  ];
  return `hsla(${Vt(i, "int").getComponents("hsl").map((s, r) => e[r](s)).join(", ")})`;
}
function ud(i, e) {
  const t = Xt(e === "float" ? 2 : 0), n = ["r", "g", "b"], s = Vt(i, e);
  return `{${Bn(s.getComponents("rgb")).map((a, o) => `${n[o]}: ${t(a)}`).join(", ")}}`;
}
function QC(i) {
  return (e) => ud(e, i);
}
function dd(i, e) {
  const t = Xt(2), n = Xt(e === "float" ? 2 : 0), s = ["r", "g", "b", "a"];
  return `{${Vt(i, e).getComponents("rgb").map((o, l) => {
    const c = l === 3 ? t : n;
    return `${s[l]}: ${c(o)}`;
  }).join(", ")}}`;
}
function kC(i) {
  return (e) => dd(e, i);
}
const _C = [
  {
    format: {
      alpha: !1,
      mode: "rgb",
      notation: "hex",
      type: "int"
    },
    stringifier: gl
  },
  {
    format: {
      alpha: !0,
      mode: "rgb",
      notation: "hex",
      type: "int"
    },
    stringifier: bl
  },
  {
    format: {
      alpha: !1,
      mode: "rgb",
      notation: "func",
      type: "int"
    },
    stringifier: hd
  },
  {
    format: {
      alpha: !0,
      mode: "rgb",
      notation: "func",
      type: "int"
    },
    stringifier: Wr
  },
  {
    format: {
      alpha: !1,
      mode: "hsl",
      notation: "func",
      type: "int"
    },
    stringifier: NC
  },
  {
    format: {
      alpha: !0,
      mode: "hsl",
      notation: "func",
      type: "int"
    },
    stringifier: UC
  },
  ...["int", "float"].reduce((i, e) => [
    ...i,
    {
      format: {
        alpha: !1,
        mode: "rgb",
        notation: "object",
        type: e
      },
      stringifier: QC(e)
    },
    {
      format: {
        alpha: !0,
        mode: "rgb",
        notation: "object",
        type: e
      },
      stringifier: kC(e)
    }
  ], [])
];
function pd(i) {
  return _C.reduce((e, t) => e || (CC(t.format, i) ? t.stringifier : null), null);
}
const Os = Xe("apl");
class OC {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Os()), t.viewProps.bindClassModifiers(this.element), t.viewProps.bindTabIndex(this.element);
    const n = e.createElement("div");
    n.classList.add(Os("b")), this.element.appendChild(n);
    const s = e.createElement("div");
    s.classList.add(Os("c")), n.appendChild(s), this.colorElem_ = s;
    const r = e.createElement("div");
    r.classList.add(Os("m")), this.element.appendChild(r), this.markerElem_ = r;
    const a = e.createElement("div");
    a.classList.add(Os("p")), this.markerElem_.appendChild(a), this.previewElem_ = a, this.update_();
  }
  update_() {
    const e = this.value.rawValue, t = e.getComponents("rgb"), n = new Je([t[0], t[1], t[2], 0], "rgb"), s = new Je([t[0], t[1], t[2], 255], "rgb"), r = [
      "to right",
      Wr(n),
      Wr(s)
    ];
    this.colorElem_.style.background = `linear-gradient(${r.join(",")})`, this.previewElem_.style.backgroundColor = Wr(e);
    const a = nt(t[3], 0, 1, 0, 100);
    this.markerElem_.style.left = `${a}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class GC {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new OC(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.ptHandler_ = new Oi(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point)
      return;
    const n = e.point.x / e.bounds.width, s = this.value.rawValue, [r, a, o] = s.getComponents("hsv");
    this.value.setRawValue(new Je([r, a, o, n], "hsv"), t);
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !0,
      last: !0
    });
  }
  onKeyDown_(e) {
    const t = Kt(Qi(!0), jn(e));
    if (t === 0)
      return;
    const n = this.value.rawValue, [s, r, a, o] = n.getComponents("hsv");
    this.value.setRawValue(new Je([s, r, a, o + t], "hsv"), {
      forceEmit: !1,
      last: !1
    });
  }
  onKeyUp_(e) {
    Kt(Qi(!0), jn(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
}
const ss = Xe("coltxt");
function HC(i) {
  const e = i.createElement("select"), t = [
    { text: "RGB", value: "rgb" },
    { text: "HSL", value: "hsl" },
    { text: "HSV", value: "hsv" },
    { text: "HEX", value: "hex" }
  ];
  return e.appendChild(t.reduce((n, s) => {
    const r = i.createElement("option");
    return r.textContent = s.text, r.value = s.value, n.appendChild(r), n;
  }, i.createDocumentFragment())), e;
}
class VC {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(ss()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("div");
    n.classList.add(ss("m")), this.modeElem_ = HC(e), this.modeElem_.classList.add(ss("ms")), n.appendChild(this.modeSelectElement), t.viewProps.bindDisabled(this.modeElem_);
    const s = e.createElement("div");
    s.classList.add(ss("mm")), s.appendChild(ha(e, "dropdown")), n.appendChild(s), this.element.appendChild(n);
    const r = e.createElement("div");
    r.classList.add(ss("w")), this.element.appendChild(r), this.inputsElem_ = r, this.inputViews_ = t.inputViews, this.applyInputViews_(), Yn(t.mode, (a) => {
      this.modeElem_.value = a;
    });
  }
  get modeSelectElement() {
    return this.modeElem_;
  }
  get inputViews() {
    return this.inputViews_;
  }
  set inputViews(e) {
    this.inputViews_ = e, this.applyInputViews_();
  }
  applyInputViews_() {
    Lu(this.inputsElem_);
    const e = this.element.ownerDocument;
    this.inputViews_.forEach((t) => {
      const n = e.createElement("div");
      n.classList.add(ss("c")), n.appendChild(t.element), this.inputsElem_.appendChild(n);
    });
  }
}
function zC(i) {
  return Xt(i === "float" ? 2 : 0);
}
function qC(i, e, t) {
  const n = gs(i, e)[t];
  return new nr({
    min: 0,
    max: n
  });
}
function WC(i, e, t) {
  return new lr(i, {
    arrayPosition: t === 0 ? "fst" : t === 2 ? "lst" : "mid",
    parser: e.parser,
    props: ke.fromObject({
      formatter: zC(e.colorType),
      keyScale: Qi(!1),
      pointerScale: e.colorType === "float" ? 0.01 : 1
    }),
    value: dt(0, {
      constraint: qC(e.colorMode, e.colorType, t)
    }),
    viewProps: e.viewProps
  });
}
function YC(i, e) {
  const t = {
    colorMode: e.colorMode,
    colorType: e.colorType,
    parser: Xn,
    viewProps: e.viewProps
  };
  return [0, 1, 2].map((n) => {
    const s = WC(i, t, n);
    return Is({
      primary: e.value,
      secondary: s.value,
      forward(r) {
        return Vt(r, e.colorType).getComponents(e.colorMode)[n];
      },
      backward(r, a) {
        const o = e.colorMode, c = Vt(r, e.colorType).getComponents(o);
        c[n] = a;
        const h = ml(da(Bn(c), c[3]), o, e.colorType);
        return Vt(h, "int");
      }
    }), s;
  });
}
function KC(i, e) {
  const t = new Js(i, {
    parser: hr("int"),
    props: ke.fromObject({
      formatter: gl
    }),
    value: dt(Je.black()),
    viewProps: e.viewProps
  });
  return Is({
    primary: e.value,
    secondary: t.value,
    forward: (n) => new Je(Bn(n.getComponents()), n.mode),
    backward: (n, s) => new Je(da(Bn(s.getComponents(n.mode)), n.getComponents()[3]), n.mode)
  }), [t];
}
function XC(i) {
  return i !== "hex";
}
class jC {
  constructor(e, t) {
    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = t.colorType, this.value = t.value, this.viewProps = t.viewProps, this.colorMode = dt(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(e), this.view = new VC(e, {
      mode: this.colorMode,
      inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
      viewProps: this.viewProps
    }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
  }
  createComponentControllers_(e) {
    const t = this.colorMode.rawValue;
    return XC(t) ? YC(e, {
      colorMode: t,
      colorType: this.colorType_,
      value: this.value,
      viewProps: this.viewProps
    }) : KC(e, {
      value: this.value,
      viewProps: this.viewProps
    });
  }
  onModeSelectChange_(e) {
    const t = e.currentTarget;
    this.colorMode.rawValue = t.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.inputViews = this.ccs_.map((n) => n.view);
  }
}
const po = Xe("hpl");
class JC {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(po()), t.viewProps.bindClassModifiers(this.element), t.viewProps.bindTabIndex(this.element);
    const n = e.createElement("div");
    n.classList.add(po("c")), this.element.appendChild(n);
    const s = e.createElement("div");
    s.classList.add(po("m")), this.element.appendChild(s), this.markerElem_ = s, this.update_();
  }
  update_() {
    const e = this.value.rawValue, [t] = e.getComponents("hsv");
    this.markerElem_.style.backgroundColor = hd(new Je([t, 100, 100], "hsv"));
    const n = nt(t, 0, 360, 0, 100);
    this.markerElem_.style.left = `${n}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class ZC {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new JC(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.ptHandler_ = new Oi(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point)
      return;
    const n = nt(yt(e.point.x, 0, e.bounds.width), 0, e.bounds.width, 0, 360), s = this.value.rawValue, [, r, a, o] = s.getComponents("hsv");
    this.value.setRawValue(new Je([n, r, a, o], "hsv"), t);
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !0,
      last: !0
    });
  }
  onKeyDown_(e) {
    const t = Kt(Qi(!1), jn(e));
    if (t === 0)
      return;
    const n = this.value.rawValue, [s, r, a, o] = n.getComponents("hsv");
    this.value.setRawValue(new Je([s + t, r, a, o], "hsv"), {
      forceEmit: !1,
      last: !1
    });
  }
  onKeyUp_(e) {
    Kt(Qi(!1), jn(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
}
const Ao = Xe("svp"), bh = 64;
class $C {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Ao()), t.viewProps.bindClassModifiers(this.element), t.viewProps.bindTabIndex(this.element);
    const n = e.createElement("canvas");
    n.height = bh, n.width = bh, n.classList.add(Ao("c")), this.element.appendChild(n), this.canvasElement = n;
    const s = e.createElement("div");
    s.classList.add(Ao("m")), this.element.appendChild(s), this.markerElem_ = s, this.update_();
  }
  update_() {
    const e = ZE(this.canvasElement);
    if (!e)
      return;
    const n = this.value.rawValue.getComponents("hsv"), s = this.canvasElement.width, r = this.canvasElement.height, a = e.getImageData(0, 0, s, r), o = a.data;
    for (let h = 0; h < r; h++)
      for (let u = 0; u < s; u++) {
        const d = nt(u, 0, s, 0, 100), A = nt(h, 0, r, 100, 0), m = ju(n[0], d, A), g = (h * s + u) * 4;
        o[g] = m[0], o[g + 1] = m[1], o[g + 2] = m[2], o[g + 3] = 255;
      }
    e.putImageData(a, 0, 0);
    const l = nt(n[1], 0, 100, 0, 100);
    this.markerElem_.style.left = `${l}%`;
    const c = nt(n[2], 0, 100, 100, 0);
    this.markerElem_.style.top = `${c}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class ex {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new $C(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.ptHandler_ = new Oi(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point)
      return;
    const n = nt(e.point.x, 0, e.bounds.width, 0, 100), s = nt(e.point.y, 0, e.bounds.height, 100, 0), [r, , , a] = this.value.rawValue.getComponents("hsv");
    this.value.setRawValue(new Je([r, n, s, a], "hsv"), t);
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !0,
      last: !0
    });
  }
  onKeyDown_(e) {
    Wu(e.key) && e.preventDefault();
    const [t, n, s, r] = this.value.rawValue.getComponents("hsv"), a = Qi(!1), o = Kt(a, jn(e)), l = Kt(a, Zs(e));
    o === 0 && l === 0 || this.value.setRawValue(new Je([t, n + o, s + l, r], "hsv"), {
      forceEmit: !1,
      last: !1
    });
  }
  onKeyUp_(e) {
    const t = Qi(!1), n = Kt(t, jn(e)), s = Kt(t, Zs(e));
    n === 0 && s === 0 || this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
}
class tx {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.hPaletteC_ = new ZC(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.svPaletteC_ = new ex(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.alphaIcs_ = t.supportsAlpha ? {
      palette: new GC(e, {
        value: this.value,
        viewProps: this.viewProps
      }),
      text: new lr(e, {
        parser: Xn,
        props: ke.fromObject({
          pointerScale: 0.01,
          keyScale: 0.1,
          formatter: Xt(2)
        }),
        value: dt(0, {
          constraint: new nr({ min: 0, max: 1 })
        }),
        viewProps: this.viewProps
      })
    } : null, this.alphaIcs_ && Is({
      primary: this.value,
      secondary: this.alphaIcs_.text.value,
      forward: (n) => n.getComponents()[3],
      backward: (n, s) => {
        const r = n.getComponents();
        return r[3] = s, new Je(r, n.mode);
      }
    }), this.textsC_ = new jC(e, {
      colorType: t.colorType,
      value: this.value,
      viewProps: this.viewProps
    }), this.view = new AC(e, {
      alphaViews: this.alphaIcs_ ? {
        palette: this.alphaIcs_.palette.view,
        text: this.alphaIcs_.text.view
      } : null,
      hPaletteView: this.hPaletteC_.view,
      supportsAlpha: t.supportsAlpha,
      svPaletteView: this.svPaletteC_.view,
      textsView: this.textsC_.view,
      viewProps: this.viewProps
    });
  }
  get textsController() {
    return this.textsC_;
  }
}
const fo = Xe("colsw");
class nx {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.element = e.createElement("div"), this.element.classList.add(fo()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("div");
    n.classList.add(fo("sw")), this.element.appendChild(n), this.swatchElem_ = n;
    const s = e.createElement("button");
    s.classList.add(fo("b")), t.viewProps.bindDisabled(s), this.element.appendChild(s), this.buttonElement = s, this.update_();
  }
  update_() {
    const e = this.value.rawValue;
    this.swatchElem_.style.backgroundColor = bl(e);
  }
  onValueChange_() {
    this.update_();
  }
}
class ix {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.view = new nx(e, {
      value: this.value,
      viewProps: this.viewProps
    });
  }
}
class vl {
  constructor(e, t) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = sr.create(t.expanded), this.swatchC_ = new ix(e, {
      value: this.value,
      viewProps: this.viewProps
    });
    const n = this.swatchC_.view.buttonElement;
    n.addEventListener("blur", this.onButtonBlur_), n.addEventListener("click", this.onButtonClick_), this.textC_ = new Js(e, {
      parser: t.parser,
      props: ke.fromObject({
        formatter: t.formatter
      }),
      value: this.value,
      viewProps: this.viewProps
    }), this.view = new aC(e, {
      foldable: this.foldable_,
      pickerLayout: t.pickerLayout
    }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = t.pickerLayout === "popup" ? new Vu(e, {
      viewProps: this.viewProps
    }) : null;
    const s = new tx(e, {
      colorType: t.colorType,
      supportsAlpha: t.supportsAlpha,
      value: this.value,
      viewProps: this.viewProps
    });
    s.view.allFocusableElements.forEach((r) => {
      r.addEventListener("blur", this.onPopupChildBlur_), r.addEventListener("keydown", this.onPopupChildKeydown_);
    }), this.pickerC_ = s, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(s.view.element), Is({
      primary: this.foldable_.value("expanded"),
      secondary: this.popC_.shows,
      forward: (r) => r,
      backward: (r, a) => a
    })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), hl(this.foldable_, this.view.pickerElement));
  }
  get textController() {
    return this.textC_;
  }
  onButtonBlur_(e) {
    if (!this.popC_)
      return;
    const t = this.view.element, n = e.relatedTarget;
    (!n || !t.contains(n)) && (this.popC_.shows.rawValue = !1);
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
  }
  onPopupChildBlur_(e) {
    if (!this.popC_)
      return;
    const t = this.popC_.view.element, n = Fu(e);
    n && t.contains(n) || n && n === this.swatchC_.view.buttonElement && !sl(t.ownerDocument) || (this.popC_.shows.rawValue = !1);
  }
  onPopupChildKeydown_(e) {
    this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && e.key === "Escape" && this.swatchC_.view.buttonElement.focus();
  }
}
function sx(i) {
  return Bn(i.getComponents("rgb")).reduce((e, t) => e << 8 | Math.floor(t) & 255, 0);
}
function rx(i) {
  return i.getComponents("rgb").reduce((e, t, n) => {
    const s = Math.floor(n === 3 ? t * 255 : t) & 255;
    return e << 8 | s;
  }, 0) >>> 0;
}
function ax(i) {
  return new Je([i >> 16 & 255, i >> 8 & 255, i & 255], "rgb");
}
function ox(i) {
  return new Je([
    i >> 24 & 255,
    i >> 16 & 255,
    i >> 8 & 255,
    nt(i & 255, 0, 255, 0, 1)
  ], "rgb");
}
function lx(i) {
  return typeof i != "number" ? Je.black() : ax(i);
}
function cx(i) {
  return typeof i != "number" ? Je.black() : ox(i);
}
function Yr(i, e) {
  return typeof i != "object" || ct(i) ? !1 : e in i && typeof i[e] == "number";
}
function Ad(i) {
  return Yr(i, "r") && Yr(i, "g") && Yr(i, "b");
}
function fd(i) {
  return Ad(i) && Yr(i, "a");
}
function md(i) {
  return Ad(i);
}
function El(i, e) {
  if (i.mode !== e.mode || i.type !== e.type)
    return !1;
  const t = i.getComponents(), n = e.getComponents();
  for (let s = 0; s < t.length; s++)
    if (t[s] !== n[s])
      return !1;
  return !0;
}
function vh(i) {
  return "a" in i ? [i.r, i.g, i.b, i.a] : [i.r, i.g, i.b];
}
function hx(i) {
  const e = pd(i);
  return e ? (t, n) => {
    cr(t, e(n));
  } : null;
}
function ux(i) {
  const e = i ? rx : sx;
  return (t, n) => {
    cr(t, e(n));
  };
}
function dx(i, e, t) {
  const s = Vt(e, t).toRgbaObject();
  i.writeProperty("r", s.r), i.writeProperty("g", s.g), i.writeProperty("b", s.b), i.writeProperty("a", s.a);
}
function px(i, e, t) {
  const s = Vt(e, t).toRgbaObject();
  i.writeProperty("r", s.r), i.writeProperty("g", s.g), i.writeProperty("b", s.b);
}
function Ax(i, e) {
  return (t, n) => {
    i ? dx(t, n, e) : px(t, n, e);
  };
}
function fx(i) {
  var e;
  return !!(!((e = i == null ? void 0 : i.color) === null || e === void 0) && e.alpha);
}
function mx(i) {
  return i ? (e) => bl(e, "0x") : (e) => gl(e, "0x");
}
function gx(i) {
  return "color" in i || i.view === "color";
}
const bx = zt({
  id: "input-color-number",
  type: "input",
  accept: (i, e) => {
    if (typeof i != "number" || !gx(e))
      return null;
    const t = Al(e);
    return t ? {
      initialValue: i,
      params: Object.assign(Object.assign({}, t), { supportsAlpha: fx(e) })
    } : null;
  },
  binding: {
    reader: (i) => i.params.supportsAlpha ? cx : lx,
    equals: El,
    writer: (i) => ux(i.params.supportsAlpha)
  },
  controller: (i) => {
    var e, t;
    return new vl(i.document, {
      colorType: "int",
      expanded: (e = i.params.expanded) !== null && e !== void 0 ? e : !1,
      formatter: mx(i.params.supportsAlpha),
      parser: hr("int"),
      pickerLayout: (t = i.params.picker) !== null && t !== void 0 ? t : "popup",
      supportsAlpha: i.params.supportsAlpha,
      value: i.value,
      viewProps: i.viewProps
    });
  }
});
function vx(i, e) {
  if (!md(i))
    return Vt(Je.black(), e);
  if (e === "int") {
    const t = vh(i);
    return new Je(t, "rgb");
  }
  if (e === "float") {
    const t = vh(i);
    return new fl(t, "rgb");
  }
  return Vt(Je.black(), "int");
}
function Ex(i) {
  return fd(i);
}
function Cx(i) {
  return (e) => {
    const t = vx(e, i);
    return Vt(t, "int");
  };
}
function xx(i, e) {
  return (t) => i ? dd(t, e) : ud(t, e);
}
const wx = zt({
  id: "input-color-object",
  type: "input",
  accept: (i, e) => {
    var t;
    if (!md(i))
      return null;
    const n = Al(e);
    return n ? {
      initialValue: i,
      params: Object.assign(Object.assign({}, n), { colorType: (t = $u(e)) !== null && t !== void 0 ? t : "int" })
    } : null;
  },
  binding: {
    reader: (i) => Cx(i.params.colorType),
    equals: El,
    writer: (i) => Ax(Ex(i.initialValue), i.params.colorType)
  },
  controller: (i) => {
    var e, t;
    const n = fd(i.initialValue);
    return new vl(i.document, {
      colorType: i.params.colorType,
      expanded: (e = i.params.expanded) !== null && e !== void 0 ? e : !1,
      formatter: xx(n, i.params.colorType),
      parser: hr("int"),
      pickerLayout: (t = i.params.picker) !== null && t !== void 0 ? t : "popup",
      supportsAlpha: n,
      value: i.value,
      viewProps: i.viewProps
    });
  }
}), yx = zt({
  id: "input-color-string",
  type: "input",
  accept: (i, e) => {
    if (typeof i != "string" || e.view === "text")
      return null;
    const t = LC(i, $u(e));
    if (!t)
      return null;
    const n = pd(t);
    if (!n)
      return null;
    const s = Al(e);
    return s ? {
      initialValue: i,
      params: Object.assign(Object.assign({}, s), { format: t, stringifier: n })
    } : null;
  },
  binding: {
    reader: () => FC,
    equals: El,
    writer: (i) => {
      const e = hx(i.params.format);
      if (!e)
        throw bt.notBindable();
      return e;
    }
  },
  controller: (i) => {
    var e, t;
    return new vl(i.document, {
      colorType: i.params.format.type,
      expanded: (e = i.params.expanded) !== null && e !== void 0 ? e : !1,
      formatter: i.params.stringifier,
      parser: hr("int"),
      pickerLayout: (t = i.params.picker) !== null && t !== void 0 ? t : "popup",
      supportsAlpha: i.params.format.alpha,
      value: i.value,
      viewProps: i.viewProps
    });
  }
});
class Cl {
  constructor(e) {
    this.components = e.components, this.asm_ = e.assembly;
  }
  constrain(e) {
    const t = this.asm_.toComponents(e).map((n, s) => {
      var r, a;
      return (a = (r = this.components[s]) === null || r === void 0 ? void 0 : r.constrain(n)) !== null && a !== void 0 ? a : n;
    });
    return this.asm_.fromComponents(t);
  }
}
const Eh = Xe("pndtxt");
class Ix {
  constructor(e, t) {
    this.textViews = t.textViews, this.element = e.createElement("div"), this.element.classList.add(Eh()), this.textViews.forEach((n) => {
      const s = e.createElement("div");
      s.classList.add(Eh("a")), s.appendChild(n.element), this.element.appendChild(s);
    });
  }
}
function Mx(i, e, t) {
  return new lr(i, {
    arrayPosition: t === 0 ? "fst" : t === e.axes.length - 1 ? "lst" : "mid",
    parser: e.parser,
    props: e.axes[t].textProps,
    value: dt(0, {
      constraint: e.axes[t].constraint
    }),
    viewProps: e.viewProps
  });
}
class xl {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.acs_ = t.axes.map((n, s) => Mx(e, t, s)), this.acs_.forEach((n, s) => {
      Is({
        primary: this.value,
        secondary: n.value,
        forward: (r) => t.assembly.toComponents(r)[s],
        backward: (r, a) => {
          const o = t.assembly.toComponents(r);
          return o[s] = a, t.assembly.fromComponents(o);
        }
      });
    }), this.view = new Ix(e, {
      textViews: this.acs_.map((n) => n.view)
    });
  }
  get textControllers() {
    return this.acs_;
  }
}
class Sx extends js {
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(e) {
    this.controller.valueController.sliderController.props.set("max", e);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(e) {
    this.controller.valueController.sliderController.props.set("min", e);
  }
}
function Bx(i, e) {
  const t = [], n = Su(i, e);
  n && t.push(n);
  const s = Bu(i);
  s && t.push(s);
  const r = pl(i.options);
  return r && t.push(r), new rr(t);
}
const Tx = zt({
  id: "input-number",
  type: "input",
  accept: (i, e) => {
    if (typeof i != "number")
      return null;
    const t = ft(e, (n) => Object.assign(Object.assign({}, Ru(n)), { options: n.optional.custom(or), readonly: n.optional.constant(!1) }));
    return t ? {
      initialValue: i,
      params: t
    } : null;
  },
  binding: {
    reader: (i) => wu,
    constraint: (i) => Bx(i.params, i.initialValue),
    writer: (i) => cr
  },
  controller: (i) => {
    const e = i.value, t = i.constraint, n = t && ea(t, ar);
    if (n)
      return new Ai(i.document, {
        props: new ke({
          options: n.values.value("options")
        }),
        value: e,
        viewProps: i.viewProps
      });
    const s = Tu(i.params, e.rawValue), r = t && ea(t, nr);
    return r ? new na(i.document, Object.assign(Object.assign({}, Yu(Object.assign(Object.assign({}, s), { keyScale: dt(s.keyScale), max: r.values.value("max"), min: r.values.value("min") }))), { parser: Xn, value: e, viewProps: i.viewProps })) : new lr(i.document, {
      parser: Xn,
      props: ke.fromObject(s),
      value: e,
      viewProps: i.viewProps
    });
  },
  api(i) {
    return typeof i.controller.value.rawValue != "number" ? null : i.controller.valueController instanceof na ? new Sx(i.controller) : i.controller.valueController instanceof Ai ? new ul(i.controller) : null;
  }
});
class pi {
  constructor(e = 0, t = 0) {
    this.x = e, this.y = t;
  }
  getComponents() {
    return [this.x, this.y];
  }
  static isObject(e) {
    if (ct(e))
      return !1;
    const t = e.x, n = e.y;
    return !(typeof t != "number" || typeof n != "number");
  }
  static equals(e, t) {
    return e.x === t.x && e.y === t.y;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y
    };
  }
}
const gd = {
  toComponents: (i) => i.getComponents(),
  fromComponents: (i) => new pi(...i)
}, rs = Xe("p2d");
class Rx {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(rs()), t.viewProps.bindClassModifiers(this.element), Yn(t.expanded, xs(this.element, rs(void 0, "expanded")));
    const n = e.createElement("div");
    n.classList.add(rs("h")), this.element.appendChild(n);
    const s = e.createElement("button");
    s.classList.add(rs("b")), s.appendChild(ha(e, "p2dpad")), t.viewProps.bindDisabled(s), n.appendChild(s), this.buttonElement = s;
    const r = e.createElement("div");
    if (r.classList.add(rs("t")), n.appendChild(r), this.textElement = r, t.pickerLayout === "inline") {
      const a = e.createElement("div");
      a.classList.add(rs("p")), this.element.appendChild(a), this.pickerElement = a;
    } else
      this.pickerElement = null;
  }
}
const li = Xe("p2dp");
class Dx {
  constructor(e, t) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onPropsChange_ = this.onPropsChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onPropsChange_), this.element = e.createElement("div"), this.element.classList.add(li()), t.layout === "popup" && this.element.classList.add(li(void 0, "p")), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("div");
    n.classList.add(li("p")), t.viewProps.bindTabIndex(n), this.element.appendChild(n), this.padElement = n;
    const s = e.createElementNS(wn, "svg");
    s.classList.add(li("g")), this.padElement.appendChild(s), this.svgElem_ = s;
    const r = e.createElementNS(wn, "line");
    r.classList.add(li("ax")), r.setAttributeNS(null, "x1", "0"), r.setAttributeNS(null, "y1", "50%"), r.setAttributeNS(null, "x2", "100%"), r.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(r);
    const a = e.createElementNS(wn, "line");
    a.classList.add(li("ax")), a.setAttributeNS(null, "x1", "50%"), a.setAttributeNS(null, "y1", "0"), a.setAttributeNS(null, "x2", "50%"), a.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(a);
    const o = e.createElementNS(wn, "line");
    o.classList.add(li("l")), o.setAttributeNS(null, "x1", "50%"), o.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(o), this.lineElem_ = o;
    const l = e.createElement("div");
    l.classList.add(li("m")), this.padElement.appendChild(l), this.markerElem_ = l, t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const [e, t] = this.value.rawValue.getComponents(), n = this.props_.get("max"), s = nt(e, -n, +n, 0, 100), r = nt(t, -n, +n, 0, 100), a = this.props_.get("invertsY") ? 100 - r : r;
    this.lineElem_.setAttributeNS(null, "x2", `${s}%`), this.lineElem_.setAttributeNS(null, "y2", `${a}%`), this.markerElem_.style.left = `${s}%`, this.markerElem_.style.top = `${a}%`;
  }
  onValueChange_() {
    this.update_();
  }
  onPropsChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
}
function Ch(i, e, t) {
  return [
    Kt(e[0], jn(i)),
    Kt(e[1], Zs(i)) * (t ? 1 : -1)
  ];
}
class Px {
  constructor(e, t) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new Dx(e, {
      layout: t.layout,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    }), this.ptHandler_ = new Oi(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point)
      return;
    const n = this.props.get("max"), s = nt(e.point.x, 0, e.bounds.width, -n, +n), r = nt(this.props.get("invertsY") ? e.bounds.height - e.point.y : e.point.y, 0, e.bounds.height, -n, +n);
    this.value.setRawValue(new pi(s, r), t);
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !0,
      last: !0
    });
  }
  onPadKeyDown_(e) {
    Wu(e.key) && e.preventDefault();
    const [t, n] = Ch(e, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
    t === 0 && n === 0 || this.value.setRawValue(new pi(this.value.rawValue.x + t, this.value.rawValue.y + n), {
      forceEmit: !1,
      last: !1
    });
  }
  onPadKeyUp_(e) {
    const [t, n] = Ch(e, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
    t === 0 && n === 0 || this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
}
class Lx {
  constructor(e, t) {
    var n, s;
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = sr.create(t.expanded), this.popC_ = t.pickerLayout === "popup" ? new Vu(e, {
      viewProps: this.viewProps
    }) : null;
    const r = new Px(e, {
      layout: t.pickerLayout,
      props: new ke({
        invertsY: dt(t.invertsY),
        max: dt(t.max),
        xKeyScale: t.axes[0].textProps.value("keyScale"),
        yKeyScale: t.axes[1].textProps.value("keyScale")
      }),
      value: this.value,
      viewProps: this.viewProps
    });
    r.view.allFocusableElements.forEach((a) => {
      a.addEventListener("blur", this.onPopupChildBlur_), a.addEventListener("keydown", this.onPopupChildKeydown_);
    }), this.pickerC_ = r, this.textC_ = new xl(e, {
      assembly: gd,
      axes: t.axes,
      parser: t.parser,
      value: this.value,
      viewProps: this.viewProps
    }), this.view = new Rx(e, {
      expanded: this.foldable_.value("expanded"),
      pickerLayout: t.pickerLayout,
      viewProps: this.viewProps
    }), this.view.textElement.appendChild(this.textC_.view.element), (n = this.view.buttonElement) === null || n === void 0 || n.addEventListener("blur", this.onPadButtonBlur_), (s = this.view.buttonElement) === null || s === void 0 || s.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Is({
      primary: this.foldable_.value("expanded"),
      secondary: this.popC_.shows,
      forward: (a) => a,
      backward: (a, o) => o
    })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), hl(this.foldable_, this.view.pickerElement));
  }
  get textController() {
    return this.textC_;
  }
  onPadButtonBlur_(e) {
    if (!this.popC_)
      return;
    const t = this.view.element, n = e.relatedTarget;
    (!n || !t.contains(n)) && (this.popC_.shows.rawValue = !1);
  }
  onPadButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
  }
  onPopupChildBlur_(e) {
    if (!this.popC_)
      return;
    const t = this.popC_.view.element, n = Fu(e);
    n && t.contains(n) || n && n === this.view.buttonElement && !sl(t.ownerDocument) || (this.popC_.shows.rawValue = !1);
  }
  onPopupChildKeydown_(e) {
    this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && e.key === "Escape" && this.view.buttonElement.focus();
  }
}
function Fx(i) {
  return pi.isObject(i) ? new pi(i.x, i.y) : new pi();
}
function Nx(i, e) {
  i.writeProperty("x", e.x), i.writeProperty("y", e.y);
}
function Ux(i, e) {
  return new Cl({
    assembly: gd,
    components: [
      Vn(Object.assign(Object.assign({}, i), i.x), e.x),
      Vn(Object.assign(Object.assign({}, i), i.y), e.y)
    ]
  });
}
function xh(i, e) {
  var t, n;
  if (!ct(i.min) || !ct(i.max))
    return Math.max(Math.abs((t = i.min) !== null && t !== void 0 ? t : 0), Math.abs((n = i.max) !== null && n !== void 0 ? n : 0));
  const s = Iu(i);
  return Math.max(Math.abs(s) * 10, Math.abs(e) * 10);
}
function Qx(i, e) {
  var t, n;
  const s = xh(Ni(i, (t = i.x) !== null && t !== void 0 ? t : {}), e.x), r = xh(Ni(i, (n = i.y) !== null && n !== void 0 ? n : {}), e.y);
  return Math.max(s, r);
}
function kx(i) {
  if (!("y" in i))
    return !1;
  const e = i.y;
  return e && "inverted" in e ? !!e.inverted : !1;
}
const _x = zt({
  id: "input-point2d",
  type: "input",
  accept: (i, e) => {
    if (!pi.isObject(i))
      return null;
    const t = ft(e, (n) => Object.assign(Object.assign({}, $s(n)), { expanded: n.optional.boolean, picker: n.optional.custom(Xu), readonly: n.optional.constant(!1), x: n.optional.custom(ui), y: n.optional.object(Object.assign(Object.assign({}, $s(n)), { inverted: n.optional.boolean })) }));
    return t ? {
      initialValue: i,
      params: t
    } : null;
  },
  binding: {
    reader: () => Fx,
    constraint: (i) => Ux(i.params, i.initialValue),
    equals: pi.equals,
    writer: () => Nx
  },
  controller: (i) => {
    var e, t;
    const n = i.document, s = i.value, r = i.constraint, a = [i.params.x, i.params.y];
    return new Lx(n, {
      axes: s.rawValue.getComponents().map((o, l) => {
        var c;
        return il({
          constraint: r.components[l],
          initialValue: o,
          params: Ni(i.params, (c = a[l]) !== null && c !== void 0 ? c : {})
        });
      }),
      expanded: (e = i.params.expanded) !== null && e !== void 0 ? e : !1,
      invertsY: kx(i.params),
      max: Qx(i.params, s.rawValue),
      parser: Xn,
      pickerLayout: (t = i.params.picker) !== null && t !== void 0 ? t : "popup",
      value: s,
      viewProps: i.viewProps
    });
  }
});
class hs {
  constructor(e = 0, t = 0, n = 0) {
    this.x = e, this.y = t, this.z = n;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  static isObject(e) {
    if (ct(e))
      return !1;
    const t = e.x, n = e.y, s = e.z;
    return !(typeof t != "number" || typeof n != "number" || typeof s != "number");
  }
  static equals(e, t) {
    return e.x === t.x && e.y === t.y && e.z === t.z;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z
    };
  }
}
const bd = {
  toComponents: (i) => i.getComponents(),
  fromComponents: (i) => new hs(...i)
};
function Ox(i) {
  return hs.isObject(i) ? new hs(i.x, i.y, i.z) : new hs();
}
function Gx(i, e) {
  i.writeProperty("x", e.x), i.writeProperty("y", e.y), i.writeProperty("z", e.z);
}
function Hx(i, e) {
  return new Cl({
    assembly: bd,
    components: [
      Vn(Object.assign(Object.assign({}, i), i.x), e.x),
      Vn(Object.assign(Object.assign({}, i), i.y), e.y),
      Vn(Object.assign(Object.assign({}, i), i.z), e.z)
    ]
  });
}
const Vx = zt({
  id: "input-point3d",
  type: "input",
  accept: (i, e) => {
    if (!hs.isObject(i))
      return null;
    const t = ft(e, (n) => Object.assign(Object.assign({}, $s(n)), { readonly: n.optional.constant(!1), x: n.optional.custom(ui), y: n.optional.custom(ui), z: n.optional.custom(ui) }));
    return t ? {
      initialValue: i,
      params: t
    } : null;
  },
  binding: {
    reader: (i) => Ox,
    constraint: (i) => Hx(i.params, i.initialValue),
    equals: hs.equals,
    writer: (i) => Gx
  },
  controller: (i) => {
    const e = i.value, t = i.constraint, n = [i.params.x, i.params.y, i.params.z];
    return new xl(i.document, {
      assembly: bd,
      axes: e.rawValue.getComponents().map((s, r) => {
        var a;
        return il({
          constraint: t.components[r],
          initialValue: s,
          params: Ni(i.params, (a = n[r]) !== null && a !== void 0 ? a : {})
        });
      }),
      parser: Xn,
      value: e,
      viewProps: i.viewProps
    });
  }
});
class us {
  constructor(e = 0, t = 0, n = 0, s = 0) {
    this.x = e, this.y = t, this.z = n, this.w = s;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  static isObject(e) {
    if (ct(e))
      return !1;
    const t = e.x, n = e.y, s = e.z, r = e.w;
    return !(typeof t != "number" || typeof n != "number" || typeof s != "number" || typeof r != "number");
  }
  static equals(e, t) {
    return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w
    };
  }
}
const vd = {
  toComponents: (i) => i.getComponents(),
  fromComponents: (i) => new us(...i)
};
function zx(i) {
  return us.isObject(i) ? new us(i.x, i.y, i.z, i.w) : new us();
}
function qx(i, e) {
  i.writeProperty("x", e.x), i.writeProperty("y", e.y), i.writeProperty("z", e.z), i.writeProperty("w", e.w);
}
function Wx(i, e) {
  return new Cl({
    assembly: vd,
    components: [
      Vn(Object.assign(Object.assign({}, i), i.x), e.x),
      Vn(Object.assign(Object.assign({}, i), i.y), e.y),
      Vn(Object.assign(Object.assign({}, i), i.z), e.z),
      Vn(Object.assign(Object.assign({}, i), i.w), e.w)
    ]
  });
}
const Yx = zt({
  id: "input-point4d",
  type: "input",
  accept: (i, e) => {
    if (!us.isObject(i))
      return null;
    const t = ft(e, (n) => Object.assign(Object.assign({}, $s(n)), { readonly: n.optional.constant(!1), w: n.optional.custom(ui), x: n.optional.custom(ui), y: n.optional.custom(ui), z: n.optional.custom(ui) }));
    return t ? {
      initialValue: i,
      params: t
    } : null;
  },
  binding: {
    reader: (i) => zx,
    constraint: (i) => Wx(i.params, i.initialValue),
    equals: us.equals,
    writer: (i) => qx
  },
  controller: (i) => {
    const e = i.value, t = i.constraint, n = [
      i.params.x,
      i.params.y,
      i.params.z,
      i.params.w
    ];
    return new xl(i.document, {
      assembly: vd,
      axes: e.rawValue.getComponents().map((s, r) => {
        var a;
        return il({
          constraint: t.components[r],
          initialValue: s,
          params: Ni(i.params, (a = n[r]) !== null && a !== void 0 ? a : {})
        });
      }),
      parser: Xn,
      value: e,
      viewProps: i.viewProps
    });
  }
});
function Kx(i) {
  const e = [], t = pl(i.options);
  return t && e.push(t), new rr(e);
}
const Xx = zt({
  id: "input-string",
  type: "input",
  accept: (i, e) => {
    if (typeof i != "string")
      return null;
    const t = ft(e, (n) => ({
      readonly: n.optional.constant(!1),
      options: n.optional.custom(or)
    }));
    return t ? {
      initialValue: i,
      params: t
    } : null;
  },
  binding: {
    reader: (i) => qu,
    constraint: (i) => Kx(i.params),
    writer: (i) => cr
  },
  controller: (i) => {
    const e = i.document, t = i.value, n = i.constraint, s = n && ea(n, ar);
    return s ? new Ai(e, {
      props: new ke({
        options: s.values.value("options")
      }),
      value: t,
      viewProps: i.viewProps
    }) : new Js(e, {
      parser: (r) => r,
      props: ke.fromObject({
        formatter: So
      }),
      value: t,
      viewProps: i.viewProps
    });
  },
  api(i) {
    return typeof i.controller.value.rawValue != "string" ? null : i.controller.valueController instanceof Ai ? new ul(i.controller) : null;
  }
}), ur = {
  monitor: {
    defaultInterval: 200,
    defaultRows: 3
  }
}, wh = Xe("mll");
class jx {
  constructor(e, t) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(wh()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("textarea");
    n.classList.add(wh("i")), n.style.height = `calc(var(${Ku("containerUnitSize")}) * ${t.rows})`, n.readOnly = !0, t.viewProps.bindDisabled(n), this.element.appendChild(n), this.textareaElem_ = n, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
  }
  update_() {
    const e = this.textareaElem_, t = e.scrollTop === e.scrollHeight - e.clientHeight, n = [];
    this.value.rawValue.forEach((s) => {
      s !== void 0 && n.push(this.formatter_(s));
    }), e.textContent = n.join(`
`), t && (e.scrollTop = e.scrollHeight);
  }
  onValueUpdate_() {
    this.update_();
  }
}
class wl {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.view = new jx(e, {
      formatter: t.formatter,
      rows: t.rows,
      value: this.value,
      viewProps: this.viewProps
    });
  }
}
const yh = Xe("sgl");
class Jx {
  constructor(e, t) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(yh()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("input");
    n.classList.add(yh("i")), n.readOnly = !0, n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
  }
  update_() {
    const e = this.value.rawValue, t = e[e.length - 1];
    this.inputElement.value = t !== void 0 ? this.formatter_(t) : "";
  }
  onValueUpdate_() {
    this.update_();
  }
}
class yl {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.view = new Jx(e, {
      formatter: t.formatter,
      value: this.value,
      viewProps: this.viewProps
    });
  }
}
const Zx = zt({
  id: "monitor-bool",
  type: "monitor",
  accept: (i, e) => {
    if (typeof i != "boolean")
      return null;
    const t = ft(e, (n) => ({
      readonly: n.required.constant(!0),
      rows: n.optional.number
    }));
    return t ? {
      initialValue: i,
      params: t
    } : null;
  },
  binding: {
    reader: (i) => zu
  },
  controller: (i) => {
    var e;
    return i.value.rawValue.length === 1 ? new yl(i.document, {
      formatter: mh,
      value: i.value,
      viewProps: i.viewProps
    }) : new wl(i.document, {
      formatter: mh,
      rows: (e = i.params.rows) !== null && e !== void 0 ? e : ur.monitor.defaultRows,
      value: i.value,
      viewProps: i.viewProps
    });
  }
});
class $x extends js {
  get max() {
    return this.controller.valueController.props.get("max");
  }
  set max(e) {
    this.controller.valueController.props.set("max", e);
  }
  get min() {
    return this.controller.valueController.props.get("min");
  }
  set min(e) {
    this.controller.valueController.props.set("min", e);
  }
}
const ci = Xe("grl");
class ew {
  constructor(e, t) {
    this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = e.createElement("div"), this.element.classList.add(ci()), t.viewProps.bindClassModifiers(this.element), this.formatter_ = t.formatter, this.props_ = t.props, this.cursor_ = t.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
    const n = e.createElementNS(wn, "svg");
    n.classList.add(ci("g")), n.style.height = `calc(var(${Ku("containerUnitSize")}) * ${t.rows})`, this.element.appendChild(n), this.svgElem_ = n;
    const s = e.createElementNS(wn, "polyline");
    this.svgElem_.appendChild(s), this.lineElem_ = s;
    const r = e.createElement("div");
    r.classList.add(ci("t"), Xe("tt")()), this.element.appendChild(r), this.tooltipElem_ = r, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
  }
  get graphElement() {
    return this.svgElem_;
  }
  update_() {
    const { clientWidth: e, clientHeight: t } = this.element, n = this.value.rawValue.length - 1, s = this.props_.get("min"), r = this.props_.get("max"), a = [];
    this.value.rawValue.forEach((u, d) => {
      if (u === void 0)
        return;
      const A = nt(d, 0, n, 0, e), m = nt(u, s, r, t, 0);
      a.push([A, m].join(","));
    }), this.lineElem_.setAttributeNS(null, "points", a.join(" "));
    const o = this.tooltipElem_, l = this.value.rawValue[this.cursor_.rawValue];
    if (l === void 0) {
      o.classList.remove(ci("t", "a"));
      return;
    }
    const c = nt(this.cursor_.rawValue, 0, n, 0, e), h = nt(l, s, r, t, 0);
    o.style.left = `${c}px`, o.style.top = `${h}px`, o.textContent = `${this.formatter_(l)}`, o.classList.contains(ci("t", "a")) || (o.classList.add(ci("t", "a"), ci("t", "in")), $r(o), o.classList.remove(ci("t", "in")));
  }
  onValueUpdate_() {
    this.update_();
  }
  onCursorChange_() {
    this.update_();
  }
}
class Ed {
  constructor(e, t) {
    if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.cursor_ = dt(-1), this.view = new ew(e, {
      cursor: this.cursor_,
      formatter: t.formatter,
      rows: t.rows,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    }), !sl(e))
      this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
    else {
      const n = new Oi(this.view.element);
      n.emitter.on("down", this.onGraphPointerDown_), n.emitter.on("move", this.onGraphPointerMove_), n.emitter.on("up", this.onGraphPointerUp_);
    }
  }
  importProps(e) {
    return $t(e, null, (t) => ({
      max: t.required.number,
      min: t.required.number
    }), (t) => (this.props.set("max", t.max), this.props.set("min", t.min), !0));
  }
  exportProps() {
    return en(null, {
      max: this.props.get("max"),
      min: this.props.get("min")
    });
  }
  onGraphMouseLeave_() {
    this.cursor_.rawValue = -1;
  }
  onGraphMouseMove_(e) {
    const { clientWidth: t } = this.view.element;
    this.cursor_.rawValue = Math.floor(nt(e.offsetX, 0, t, 0, this.value.rawValue.length));
  }
  onGraphPointerDown_(e) {
    this.onGraphPointerMove_(e);
  }
  onGraphPointerMove_(e) {
    if (!e.data.point) {
      this.cursor_.rawValue = -1;
      return;
    }
    this.cursor_.rawValue = Math.floor(nt(e.data.point.x, 0, e.data.bounds.width, 0, this.value.rawValue.length));
  }
  onGraphPointerUp_() {
    this.cursor_.rawValue = -1;
  }
}
function Bo(i) {
  return ct(i.format) ? Xt(2) : i.format;
}
function tw(i) {
  var e;
  return i.value.rawValue.length === 1 ? new yl(i.document, {
    formatter: Bo(i.params),
    value: i.value,
    viewProps: i.viewProps
  }) : new wl(i.document, {
    formatter: Bo(i.params),
    rows: (e = i.params.rows) !== null && e !== void 0 ? e : ur.monitor.defaultRows,
    value: i.value,
    viewProps: i.viewProps
  });
}
function nw(i) {
  var e, t, n;
  return new Ed(i.document, {
    formatter: Bo(i.params),
    rows: (e = i.params.rows) !== null && e !== void 0 ? e : ur.monitor.defaultRows,
    props: ke.fromObject({
      max: (t = i.params.max) !== null && t !== void 0 ? t : 100,
      min: (n = i.params.min) !== null && n !== void 0 ? n : 0
    }),
    value: i.value,
    viewProps: i.viewProps
  });
}
function Ih(i) {
  return i.view === "graph";
}
const iw = zt({
  id: "monitor-number",
  type: "monitor",
  accept: (i, e) => {
    if (typeof i != "number")
      return null;
    const t = ft(e, (n) => ({
      format: n.optional.function,
      max: n.optional.number,
      min: n.optional.number,
      readonly: n.required.constant(!0),
      rows: n.optional.number,
      view: n.optional.string
    }));
    return t ? {
      initialValue: i,
      params: t
    } : null;
  },
  binding: {
    defaultBufferSize: (i) => Ih(i) ? 64 : 1,
    reader: (i) => wu
  },
  controller: (i) => Ih(i.params) ? nw(i) : tw(i),
  api: (i) => i.controller.valueController instanceof Ed ? new $x(i.controller) : null
}), sw = zt({
  id: "monitor-string",
  type: "monitor",
  accept: (i, e) => {
    if (typeof i != "string")
      return null;
    const t = ft(e, (n) => ({
      multiline: n.optional.boolean,
      readonly: n.required.constant(!0),
      rows: n.optional.number
    }));
    return t ? {
      initialValue: i,
      params: t
    } : null;
  },
  binding: {
    reader: (i) => qu
  },
  controller: (i) => {
    var e;
    const t = i.value;
    return t.rawValue.length > 1 || i.params.multiline ? new wl(i.document, {
      formatter: So,
      rows: (e = i.params.rows) !== null && e !== void 0 ? e : ur.monitor.defaultRows,
      value: t,
      viewProps: i.viewProps
    }) : new yl(i.document, {
      formatter: So,
      value: t,
      viewProps: i.viewProps
    });
  }
});
class rw {
  constructor() {
    this.map_ = /* @__PURE__ */ new Map();
  }
  get(e) {
    var t;
    return (t = this.map_.get(e)) !== null && t !== void 0 ? t : null;
  }
  has(e) {
    return this.map_.has(e);
  }
  add(e, t) {
    return this.map_.set(e, t), e.viewProps.handleDispose(() => {
      this.map_.delete(e);
    }), t;
  }
}
class aw {
  constructor(e) {
    this.target = e.target, this.reader_ = e.reader, this.writer_ = e.writer;
  }
  read() {
    return this.reader_(this.target.read());
  }
  write(e) {
    this.writer_(this.target, e);
  }
  inject(e) {
    this.write(this.reader_(e));
  }
}
function ow(i, e) {
  var t;
  const n = i.accept(e.target.read(), e.params);
  if (ct(n))
    return null;
  const s = {
    target: e.target,
    initialValue: n.initialValue,
    params: n.params
  }, r = ft(e.params, (u) => ({
    disabled: u.optional.boolean,
    hidden: u.optional.boolean,
    label: u.optional.string,
    tag: u.optional.string
  })), a = i.binding.reader(s), o = i.binding.constraint ? i.binding.constraint(s) : void 0, l = new aw({
    reader: a,
    target: e.target,
    writer: i.binding.writer(s)
  }), c = new zE(dt(a(n.initialValue), {
    constraint: o,
    equals: i.binding.equals
  }), l), h = i.controller({
    constraint: o,
    document: e.document,
    initialValue: n.initialValue,
    params: n.params,
    value: c,
    viewProps: Zn.create({
      disabled: r == null ? void 0 : r.disabled,
      hidden: r == null ? void 0 : r.hidden
    })
  });
  return new r0(e.document, {
    blade: ys(),
    props: ke.fromObject({
      label: "label" in e.params ? (t = r == null ? void 0 : r.label) !== null && t !== void 0 ? t : null : e.target.key
    }),
    tag: r == null ? void 0 : r.tag,
    value: c,
    valueController: h
  });
}
class lw {
  constructor(e) {
    this.target = e.target, this.reader_ = e.reader;
  }
  read() {
    return this.reader_(this.target.read());
  }
}
function cw(i, e) {
  return e === 0 ? new G0() : new H0(i, e ?? ur.monitor.defaultInterval);
}
function hw(i, e) {
  var t, n, s;
  const r = i.accept(e.target.read(), e.params);
  if (ct(r))
    return null;
  const a = {
    target: e.target,
    initialValue: r.initialValue,
    params: r.params
  }, o = ft(e.params, (d) => ({
    bufferSize: d.optional.number,
    disabled: d.optional.boolean,
    hidden: d.optional.boolean,
    interval: d.optional.number,
    label: d.optional.string
  })), l = i.binding.reader(a), c = (n = (t = o == null ? void 0 : o.bufferSize) !== null && t !== void 0 ? t : i.binding.defaultBufferSize && i.binding.defaultBufferSize(r.params)) !== null && n !== void 0 ? n : 1, h = new h0({
    binding: new lw({
      reader: l,
      target: e.target
    }),
    bufferSize: c,
    ticker: cw(e.document, o == null ? void 0 : o.interval)
  }), u = i.controller({
    document: e.document,
    params: r.params,
    value: h,
    viewProps: Zn.create({
      disabled: o == null ? void 0 : o.disabled,
      hidden: o == null ? void 0 : o.hidden
    })
  });
  return u.viewProps.bindDisabled(h.ticker), u.viewProps.handleDispose(() => {
    h.ticker.dispose();
  }), new d0(e.document, {
    blade: ys(),
    props: ke.fromObject({
      label: "label" in e.params ? (s = o == null ? void 0 : o.label) !== null && s !== void 0 ? s : null : e.target.key
    }),
    value: h,
    valueController: u
  });
}
class uw {
  constructor(e) {
    this.pluginsMap_ = {
      blades: [],
      inputs: [],
      monitors: []
    }, this.apiCache_ = e;
  }
  getAll() {
    return [
      ...this.pluginsMap_.blades,
      ...this.pluginsMap_.inputs,
      ...this.pluginsMap_.monitors
    ];
  }
  register(e, t) {
    if (!tC(t.core))
      throw bt.notCompatible(e, t.id);
    t.type === "blade" ? this.pluginsMap_.blades.unshift(t) : t.type === "input" ? this.pluginsMap_.inputs.unshift(t) : t.type === "monitor" && this.pluginsMap_.monitors.unshift(t);
  }
  createInput_(e, t, n) {
    return this.pluginsMap_.inputs.reduce((s, r) => s ?? ow(r, {
      document: e,
      target: t,
      params: n
    }), null);
  }
  createMonitor_(e, t, n) {
    return this.pluginsMap_.monitors.reduce((s, r) => s ?? hw(r, {
      document: e,
      params: n,
      target: t
    }), null);
  }
  createBinding(e, t, n) {
    const s = t.read();
    if (ct(s))
      throw new bt({
        context: {
          key: t.key
        },
        type: "nomatchingcontroller"
      });
    const r = this.createInput_(e, t, n);
    if (r)
      return r;
    const a = this.createMonitor_(e, t, n);
    if (a)
      return a;
    throw new bt({
      context: {
        key: t.key
      },
      type: "nomatchingcontroller"
    });
  }
  createBlade(e, t) {
    const n = this.pluginsMap_.blades.reduce((s, r) => s ?? O0(r, {
      document: e,
      params: t
    }), null);
    if (!n)
      throw new bt({
        type: "nomatchingview",
        context: {
          params: t
        }
      });
    return n;
  }
  createInputBindingApi_(e) {
    const t = this.pluginsMap_.inputs.reduce((n, s) => {
      var r, a;
      return n || ((a = (r = s.api) === null || r === void 0 ? void 0 : r.call(s, {
        controller: e
      })) !== null && a !== void 0 ? a : null);
    }, null);
    return this.apiCache_.add(e, t ?? new js(e));
  }
  createMonitorBindingApi_(e) {
    const t = this.pluginsMap_.monitors.reduce((n, s) => {
      var r, a;
      return n || ((a = (r = s.api) === null || r === void 0 ? void 0 : r.call(s, {
        controller: e
      })) !== null && a !== void 0 ? a : null);
    }, null);
    return this.apiCache_.add(e, t ?? new js(e));
  }
  createBindingApi(e) {
    if (this.apiCache_.has(e))
      return this.apiCache_.get(e);
    if (a0(e))
      return this.createInputBindingApi_(e);
    if (p0(e))
      return this.createMonitorBindingApi_(e);
    throw bt.shouldNeverHappen();
  }
  createApi(e) {
    if (this.apiCache_.has(e))
      return this.apiCache_.get(e);
    if (s0(e))
      return this.createBindingApi(e);
    const t = this.pluginsMap_.blades.reduce((n, s) => n ?? s.api({
      controller: e,
      pool: this
    }), null);
    if (!t)
      throw bt.shouldNeverHappen();
    return this.apiCache_.add(e, t);
  }
}
const dw = new rw();
function pw() {
  const i = new uw(dw);
  return [
    _x,
    Vx,
    Yx,
    Xx,
    Tx,
    yx,
    wx,
    bx,
    rC,
    Zx,
    sw,
    iw,
    b0,
    D0,
    Hu
  ].forEach((e) => {
    i.register("core", e);
  }), i;
}
class Aw extends _i {
  /**
   * @hidden
   */
  constructor(e) {
    super(e), this.emitter_ = new wt(), this.controller.value.emitter.on("change", (t) => {
      this.emitter_.emit("change", new ir(this, t.rawValue));
    });
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(e) {
    this.controller.labelController.props.set("label", e);
  }
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(e) {
    this.controller.valueController.props.set("options", e);
  }
  get value() {
    return this.controller.value.rawValue;
  }
  set value(e) {
    this.controller.value.rawValue = e;
  }
  on(e, t) {
    const n = t.bind(this);
    return this.emitter_.on(e, (s) => {
      n(s);
    }, {
      key: t
    }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
}
class fw extends _i {
}
class mw extends _i {
  /**
   * @hidden
   */
  constructor(e) {
    super(e), this.emitter_ = new wt(), this.controller.value.emitter.on("change", (t) => {
      this.emitter_.emit("change", new ir(this, t.rawValue));
    });
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(e) {
    this.controller.labelController.props.set("label", e);
  }
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(e) {
    this.controller.valueController.sliderController.props.set("max", e);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(e) {
    this.controller.valueController.sliderController.props.set("min", e);
  }
  get value() {
    return this.controller.value.rawValue;
  }
  set value(e) {
    this.controller.value.rawValue = e;
  }
  on(e, t) {
    const n = t.bind(this);
    return this.emitter_.on(e, (s) => {
      n(s);
    }, {
      key: t
    }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
}
class gw extends _i {
  /**
   * @hidden
   */
  constructor(e) {
    super(e), this.emitter_ = new wt(), this.controller.value.emitter.on("change", (t) => {
      this.emitter_.emit("change", new ir(this, t.rawValue));
    });
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(e) {
    this.controller.labelController.props.set("label", e);
  }
  get formatter() {
    return this.controller.valueController.props.get("formatter");
  }
  set formatter(e) {
    this.controller.valueController.props.set("formatter", e);
  }
  get value() {
    return this.controller.value.rawValue;
  }
  set value(e) {
    this.controller.value.rawValue = e;
  }
  on(e, t) {
    const n = t.bind(this);
    return this.emitter_.on(e, (s) => {
      n(s);
    }, {
      key: t
    }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
}
const bw = /* @__PURE__ */ function() {
  return {
    id: "list",
    type: "blade",
    core: ws,
    accept(i) {
      const e = ft(i, (t) => ({
        options: t.required.custom(or),
        value: t.required.raw,
        view: t.required.constant("list"),
        label: t.optional.string
      }));
      return e ? { params: e } : null;
    },
    controller(i) {
      const e = new ar(dl(i.params.options)), t = dt(i.params.value, {
        constraint: e
      }), n = new Ai(i.document, {
        props: new ke({
          options: e.values.value("options")
        }),
        value: t,
        viewProps: i.viewProps
      });
      return new Ui(i.document, {
        blade: i.blade,
        props: ke.fromObject({
          label: i.params.label
        }),
        value: t,
        valueController: n
      });
    },
    api(i) {
      return !(i.controller instanceof Ui) || !(i.controller.valueController instanceof Ai) ? null : new Aw(i.controller);
    }
  };
}();
class vw extends Ou {
  /**
   * @hidden
   */
  constructor(e, t) {
    super(e, t);
  }
  get element() {
    return this.controller.view.element;
  }
}
class Ew extends Io {
  constructor(e, t) {
    super(e, {
      expanded: t.expanded,
      blade: t.blade,
      props: t.props,
      root: !0,
      viewProps: t.viewProps
    });
  }
}
const Mh = Xe("spr");
class Cw {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Mh()), t.viewProps.bindClassModifiers(this.element);
    const n = e.createElement("hr");
    n.classList.add(Mh("r")), this.element.appendChild(n);
  }
}
class Sh extends ua {
  /**
   * @hidden
   */
  constructor(e, t) {
    super(Object.assign(Object.assign({}, t), { view: new Cw(e, {
      viewProps: t.viewProps
    }) }));
  }
}
const xw = {
  id: "separator",
  type: "blade",
  core: ws,
  accept(i) {
    const e = ft(i, (t) => ({
      view: t.required.constant("separator")
    }));
    return e ? { params: e } : null;
  },
  controller(i) {
    return new Sh(i.document, {
      blade: i.blade,
      viewProps: i.viewProps
    });
  },
  api(i) {
    return i.controller instanceof Sh ? new fw(i.controller) : null;
  }
}, ww = {
  id: "slider",
  type: "blade",
  core: ws,
  accept(i) {
    const e = ft(i, (t) => ({
      max: t.required.number,
      min: t.required.number,
      view: t.required.constant("slider"),
      format: t.optional.function,
      label: t.optional.string,
      value: t.optional.number
    }));
    return e ? { params: e } : null;
  },
  controller(i) {
    var e, t;
    const n = (e = i.params.value) !== null && e !== void 0 ? e : 0, s = new nr({
      max: i.params.max,
      min: i.params.min
    }), r = dt(n, {
      constraint: s
    }), a = new na(i.document, Object.assign(Object.assign({}, Yu({
      formatter: (t = i.params.format) !== null && t !== void 0 ? t : _E,
      keyScale: dt(1),
      max: s.values.value("max"),
      min: s.values.value("min"),
      pointerScale: Mu(i.params, n)
    })), { parser: Xn, value: r, viewProps: i.viewProps }));
    return new Ui(i.document, {
      blade: i.blade,
      props: ke.fromObject({
        label: i.params.label
      }),
      value: r,
      valueController: a
    });
  },
  api(i) {
    return !(i.controller instanceof Ui) || !(i.controller.valueController instanceof na) ? null : new mw(i.controller);
  }
}, yw = /* @__PURE__ */ function() {
  return {
    id: "text",
    type: "blade",
    core: ws,
    accept(i) {
      const e = ft(i, (t) => ({
        parse: t.required.function,
        value: t.required.raw,
        view: t.required.constant("text"),
        format: t.optional.function,
        label: t.optional.string
      }));
      return e ? { params: e } : null;
    },
    controller(i) {
      var e;
      const t = dt(i.params.value), n = new Js(i.document, {
        parser: i.params.parse,
        props: ke.fromObject({
          formatter: (e = i.params.format) !== null && e !== void 0 ? e : (s) => String(s)
        }),
        value: t,
        viewProps: i.viewProps
      });
      return new Ui(i.document, {
        blade: i.blade,
        props: ke.fromObject({
          label: i.params.label
        }),
        value: t,
        valueController: n
      });
    },
    api(i) {
      return !(i.controller instanceof Ui) || !(i.controller.valueController instanceof Js) ? null : new gw(i.controller);
    }
  };
}();
function Iw(i) {
  const e = i.createElement("div");
  return e.classList.add(Xe("dfw")()), i.body && i.body.appendChild(e), e;
}
function Mw(i, e, t) {
  if (i.querySelector(`style[data-tp-style=${e}]`))
    return;
  const n = i.createElement("style");
  n.dataset.tpStyle = e, n.textContent = t, i.head.appendChild(n);
}
class Sw extends vw {
  constructor(e) {
    var t, n;
    const s = e ?? {}, r = (t = s.document) !== null && t !== void 0 ? t : JE(), a = pw(), o = new Ew(r, {
      expanded: s.expanded,
      blade: ys(),
      props: ke.fromObject({
        title: s.title
      }),
      viewProps: Zn.create()
    });
    super(o, a), this.pool_ = a, this.containerElem_ = (n = s.container) !== null && n !== void 0 ? n : Iw(r), this.containerElem_.appendChild(this.element), this.doc_ = r, this.usesDefaultWrapper_ = !s.container, this.setUpDefaultPlugins_();
  }
  get document() {
    if (!this.doc_)
      throw bt.alreadyDisposed();
    return this.doc_;
  }
  dispose() {
    const e = this.containerElem_;
    if (!e)
      throw bt.alreadyDisposed();
    if (this.usesDefaultWrapper_) {
      const t = e.parentElement;
      t && t.removeChild(e);
    }
    this.containerElem_ = null, this.doc_ = null, super.dispose();
  }
  registerPlugin(e) {
    e.css && Mw(this.document, `plugin-${e.id}`, e.css), ("plugin" in e ? [e.plugin] : "plugins" in e ? e.plugins : []).forEach((n) => {
      this.pool_.register(e.id, n);
    });
  }
  setUpDefaultPlugins_() {
    this.registerPlugin({
      id: "default",
      // NOTE: This string literal will be replaced with the default CSS by Rollup at the compilation time
      css: '.tp-tbiv_b,.tp-coltxtv_ms,.tp-colswv_b,.tp-ckbv_i,.tp-sglv_i,.tp-mllv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-rotv_b,.tp-fldv_b,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--bld-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--cnt-usz);line-height:var(--cnt-usz);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tbpv_c>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-vp))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tbpv_c>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--cnt-usp)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tbpv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tbpv_c>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tbpv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tbpv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tbpv_c>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tbpv_c>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--bld-br);border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tbpv_c .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tbpv_c>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tbpv_c>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--bld-br)}.tp-tbpv_c .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--bld-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);overflow:hidden;padding-left:var(--cnt-hp);padding-right:calc(4px + var(--cnt-usz) + var(--cnt-hp));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-hp) + (var(--cnt-usz) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-vp);padding-top:var(--cnt-vp);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--cnt-usz);line-height:var(--cnt-usz);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-sglv_i,.tp-mllv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--mo-fg);height:var(--cnt-usz);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-sglv_i::-webkit-scrollbar,.tp-mllv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-sglv_i::-webkit-scrollbar-corner,.tp-mllv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-sglv_i::-webkit-scrollbar-thumb,.tp-mllv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-rotv{--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-br: var(--tp-base-border-radius, 6px);--bs-ff: var(--tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--bld-br: var(--tp-blade-border-radius, 2px);--bld-hp: var(--tp-blade-horizontal-padding, 4px);--bld-vw: var(--tp-blade-value-width, 160px);--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--cnt-hp: var(--tp-container-horizontal-padding, 4px);--cnt-vp: var(--tp-container-vertical-padding, 4px);--cnt-usp: var(--tp-container-unit-spacing, 4px);--cnt-usz: var(--tp-container-unit-size, 20px);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--bld-br);cursor:pointer;display:block;height:var(--cnt-usz);position:relative;width:var(--cnt-usz)}.tp-ckbv_w svg{display:block;height:16px;inset:0;margin:auto;opacity:0;position:absolute;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--cnt-usz)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--cnt-usp);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--cnt-usp)}.tp-colpv_rgb{display:flex;margin-top:var(--cnt-usp);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-vp);padding-top:calc(var(--cnt-vp) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-hp));position:absolute;right:calc(-1*var(--cnt-hp));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--bld-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--cnt-usz)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{inset:0;position:absolute}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--bld-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;inset:0;position:absolute}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--bld-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{cursor:pointer;display:block;height:var(--cnt-usz);left:0;position:absolute;top:0;width:var(--cnt-usz)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--bld-br);content:"";display:block;inset:0;position:absolute}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--bld-br);color:var(--lbl-fg);cursor:pointer;height:var(--cnt-usz);line-height:var(--cnt-usz);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--cnt-usz)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-hp);padding-right:var(--cnt-hp)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:var(--bld-vw)}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 var(--bld-hp);width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--cnt-usz)*3);line-height:var(--cnt-usz);padding-left:var(--bld-hp);padding-right:var(--bld-hp);resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--cnt-usz);margin-right:4px;position:relative;width:var(--cnt-usz)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--cnt-usp);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-p2dpv{padding-left:calc(var(--cnt-usz) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:var(--bld-vw);padding:var(--cnt-vp) var(--cnt-hp);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--cnt-usz);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";display:block;height:2px;inset:0;margin:auto;position:absolute}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;content:"";display:block;height:2px;inset:0;margin-bottom:auto;margin-top:auto;position:absolute}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--bld-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--cnt-usz) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-hp) + 4px);padding-right:calc(var(--cnt-hp) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);content:"";inset:0 0 2px;pointer-events:none;position:absolute}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);opacity:.5;overflow:hidden;position:relative;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-tbpv_c{padding-bottom:var(--cnt-vp);padding-left:4px;padding-top:var(--cnt-vp)}.tp-txtv{position:relative}.tp-txtv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:calc(var(--bld-hp) - 5px);position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--cnt-usz) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--bld-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--bs-ff);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--cnt-usz) + var(--cnt-hp));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0;transition-delay:0s;transition-duration:0s}.tp-rotv.tp-rotv-not>.tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst.tp-fldv-expanded>.tp-fldv_b{transition-delay:0s;transition-duration:0s}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}',
      plugins: [
        bw,
        xw,
        ww,
        Hu,
        yw
      ]
    });
  }
}
new _u("4.0.5");
new T();
const Bh = `void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`, Th = `// Clouds shader.
// Based on https://www.shadertoy.com/view/ll2SWd

// If MERGE_COLOR is defined, this shader will read a color value from pre-rendered frame texture and merge it with
// clouds image, resulting in an opaque image.
// Otherwise, the shader will render clouds only, saving accumulated clouds transparency in alpha channel of resulting image.
#ifdef MERGE_COLOR
uniform sampler2D tDiffuse;
#endif
uniform sampler2D tDepth;
uniform vec2 viewportSizeInverse;
uniform vec3 worldCameraPosition;
uniform mat4 worldCameraUnprojectionMatrix;
uniform float timeSeconds;

uniform float densityThreshold;
uniform float transparencyThreshold;
uniform float ditherDepth;
uniform float cloudsScale;
uniform float maxRMDistance;
uniform float minRMStep;
uniform float rmStepScale;
uniform float cloudsAltitude;
uniform float cloudsTransitionalLayerScale;
uniform vec3 color1;
uniform vec3 color2;
uniform vec3 color3;
uniform vec3 color4;

uniform float alpha1;
uniform float alpha2;

uniform float densityColorGradientLength;
uniform float densityAlphaGradientLength;

uniform float detailsScale;
uniform float detailsIntensity;
uniform vec3 detailsOffset;

uniform vec3 fogColor;
uniform float fogTransparency;
uniform bool fogEnabled;

uniform sampler2D noiseTexture;

uniform float cameraNear;
uniform float cameraFar;

// iq's noise
float pn(vec3 x)
{
  vec3 p = floor(x);
  vec3 f = fract(x);
	f = f*f*(3.0-2.0*f);
	vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
	vec2 rg = textureLod( noiseTexture, (uv+ 0.5)/256.0, 0.0 ).yx;
	return -1.0+2.4*mix( rg.x, rg.y, f.z );
}

float fpn(vec3 p) 
{
   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;
}

// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html
float random(vec2 co) {
  return fract(sin(dot(co * 0.123, vec2(12.9898, 78.233))) * 43758.5453);
}

// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK
//--------------------------------------------------------------
// This spiral noise works by successively adding and rotating sin waves while increasing frequency.
// It should work the same on all computers since it's not based on a hash function like some other noises.
// It can be much faster than other noise functions if you're ok with some repetition.
const float nudge = 0.739513; // size of perpendicular vector
float normalizer = 1.0 / sqrt(1.0 + nudge * nudge); // pythagorean theorem on that perpendicular to maintain scale
float SpiralNoiseC(vec3 p) {
  float n = 0.0;  // noise amount
  float iter = 1.0;
    
  for (int i = 0; i < 8; i++) {
    // add sin and cos scaled inverse with the frequency
    n += -abs(sin(p.y * iter) + cos(p.x * iter)) / iter; // abs for a ridged look

    // rotate by adding perpendicular and scaling down
    p.xy += vec2(p.y, -p.x) * nudge;
    p.xy *= normalizer;
      
    // rotate on other axis
    p.xz += vec2(p.z, -p.x) * nudge;
    p.xz *= normalizer;

    // increase the frequency
    iter *= 1.733733;
  }
  
  return n;
}

float SpiralNoise3D(vec3 p) {
  float n = 0.0;
  float iter = 1.0;
    
  for (int i = 0; i < 5; i++) {
    n += (sin(p.y * iter) + cos(p.x * iter)) / iter;
    
    //p.xy += vec2(p.y, -p.x) * nudge;
    //p.xy *= normalizer;
    p.xz += vec2(p.z, -p.x) * nudge;
    p.xz *= normalizer;
    
    iter *= 1.33733;
  }
  
  return n;
}

// Returns a value correlating with distance towards a surface of a cloud from fiven point in world space.
// Negative value is returned for points inside the cloud, positive for points outside.
// This is similar to Signed Distance Field (SDF), but the value does not (or does it?) represent exact distance to the surface.
float get_cloud_distance(vec3 p) {
  // Offset clouds field along vertical axis, scale along all axes
  p.y -= cloudsAltitude;
  p /= cloudsScale;

  // Change clouds density depending on altitude
  float final = p.y * cloudsTransitionalLayerScale;

  final -= SpiralNoiseC(p.xyz);  // mid-range noise
  final += SpiralNoiseC(p.zxy * 0.123 + 100.0) * 3.0; // large scale terrain features
  final -= SpiralNoise3D(p); // more large scale features, but 3d, so not just a height map.
  // final -= SpiralNoise3D(p*49.0 + vec3(timeSeconds))*0.0625*0.125; // small scale noise for variation

  // Add texture-based noise
  final += detailsIntensity * fpn(p * detailsScale + detailsOffset);

  // scale result back, so it's closer to distance to cloud surface, 0.326 - magic number from the original shader.
  return final * cloudsScale * 0.326;
}

// Conversion from logarithmic depth to linear depth.
// Based on answer to this question on SO: https://stackoverflow.com/questions/40373184/world-space-position-from-logarithmic-depth-buffer
float linearize_depth(float depth){
  depth = pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
  float a = cameraFar / (cameraFar - cameraNear);
  float b = cameraFar * cameraNear / (cameraNear - cameraFar);
  return a + b / depth;
}

void main() {
    // Integer screenspace coordinates for texelFetch calls
    ivec2 texelCoords = ivec2(gl_FragCoord.xy);

#ifdef MERGE_COLOR
    // Pixel of previously rendered scene
    vec3 color = texelFetch(tDiffuse, texelCoords, 0).rgb;
#else
    vec3 color = vec3(0.0);
#endif

    // Value from depth buffer
    float depthTexel = texelFetch(tDepth, texelCoords * DEPTH_COORD_MULTIPLIER, 0).r;
    //// Alternative if texelFetch won't work everywhere
    //float depthTexel = texture2D(tDepth, gl_FragCoord.xy * viewportSizeInverse).r;

#ifdef USE_LOGDEPTHBUF
  depthTexel = linearize_depth(depthTexel);
#endif

    vec2 frag_coord = gl_FragCoord.xy;
#ifdef DITHERING
    frag_coord += vec2(random(frag_coord.xy * timeSeconds), random(frag_coord.yx * timeSeconds)) - vec2(0.5);
#endif
    // Screenspace coordinates in range [(-1, -1), (1, 1)]
    vec2 screen_offset = frag_coord * viewportSizeInverse;

    // The point in world space this pixel is looking at
    highp vec4 p = worldCameraUnprojectionMatrix * (vec4(screen_offset, depthTexel, 1.0) * 2.0 - 1.0);
    p = vec4(p.xyz / p.w, 1.0);

    // Direction from camera thru this pixel
    highp vec3 dir = p.xyz - worldCameraPosition;

    // Distance from camera to the point thhis pixel represents (all in world space)
    highp float l = length(dir);
    dir /= l;

    // Cloud transparency/opacity accumulator
    float transparency = 1.0;

    // Current step position in world space
    highp vec3 pos = worldCameraPosition;

    // Current distance from camera in world units
    float dist = 0.0;

    // Max. distance from camera in world units
    float max_dist = maxRMDistance;
    max_dist = min(max_dist, l);

    dist = 1.0 + ditherDepth * random(screen_offset + fract(timeSeconds));
    pos += dist * dir;

    float prev_transparency = 1.0, prev_dist = dist;
    vec3 color_acc = vec3(0.0);

    while (true) {
        float d = get_cloud_distance(pos);

        if (d < densityThreshold) {
          vec3 sun_dir = normalize(vec3(1.0));
          float d_sun = get_cloud_distance(pos + sun_dir);
          float k_sun = clamp(d_sun - d, 0.0, 1.0);

          float local_transparency = mix(alpha1, alpha2, smoothstep(densityThreshold, densityThreshold - densityAlphaGradientLength, d));
          vec3 local_color = mix(color1, color2, smoothstep(densityThreshold, densityThreshold - densityColorGradientLength, d));

          // local_color = mix(local_color, color3 * k_sun, 0.5);

          float step_transparency = pow(local_transparency * prev_transparency, (dist - prev_dist) / 10.0);
          color_acc += local_color * (transparency - transparency * step_transparency);
          transparency *= step_transparency;

          if (transparency < transparencyThreshold) {
            break;
          }

          prev_transparency = local_transparency;
        } else {
          prev_transparency = 1.0;
        }

        if (fogEnabled) {
          float fog_dst = min(dist, max_dist) - prev_dist;
          float fog_step_transparency = pow(fogTransparency, fog_dst / 10.0);
          color_acc += fogColor * (transparency * (1.0 - fog_step_transparency));
          transparency *= fog_step_transparency;
        }

        if (dist > max_dist) {
          break;
        }

        d *= rmStepScale;
        d = min(d, max_dist - dist - 0.01);
        d = max(d, minRMStep);
        d *= 1.0 + ditherDepth * random(screen_offset * dist);
        prev_dist = dist;
        dist += d;
        pos += dir * d;
    }

    color_acc /= max(1.0 - transparency, 0.0001); // max() to prevent division by zero on non-cloudy pixels
    transparency = max(0.0, (transparency - transparencyThreshold) / (1.0 - transparencyThreshold));

#ifdef MERGE_COLOR
    gl_FragColor.rgb = mix(color_acc, color, transparency);
    gl_FragColor.a = 1.0;
#else
    gl_FragColor.rgb = color_acc;
    gl_FragColor.a = 1.0 - transparency;
#endif
}
`, Bw = `uniform sampler2D sceneTexture;
uniform sampler2D cloudsTexture;
uniform vec2 viewportSizeInverse;

void main() {
    vec4 sceneSample = texelFetch(sceneTexture, ivec2(gl_FragCoord.xy), 0);
    vec4 cloudsSample = texture2D(cloudsTexture, gl_FragCoord.xy * viewportSizeInverse);
    gl_FragColor.rgb = mix(sceneSample.rgb, cloudsSample.rgb, cloudsSample.a);
    gl_FragColor.a = 1.0;
}
`, Tw = "data:image/png;base64,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";
var Ws = function() {
  var i = 0, e = document.createElement("div");
  e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", e.addEventListener("click", function(h) {
    h.preventDefault(), n(++i % e.children.length);
  }, !1);
  function t(h) {
    return e.appendChild(h.dom), h;
  }
  function n(h) {
    for (var u = 0; u < e.children.length; u++)
      e.children[u].style.display = u === h ? "block" : "none";
    i = h;
  }
  var s = (performance || Date).now(), r = s, a = 0, o = t(new Ws.Panel("FPS", "#0ff", "#002")), l = t(new Ws.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory)
    var c = t(new Ws.Panel("MB", "#f08", "#201"));
  return n(0), {
    REVISION: 16,
    dom: e,
    addPanel: t,
    showPanel: n,
    begin: function() {
      s = (performance || Date).now();
    },
    end: function() {
      a++;
      var h = (performance || Date).now();
      if (l.update(h - s, 200), h >= r + 1e3 && (o.update(a * 1e3 / (h - r), 100), r = h, a = 0, c)) {
        var u = performance.memory;
        c.update(u.usedJSHeapSize / 1048576, u.jsHeapSizeLimit / 1048576);
      }
      return h;
    },
    update: function() {
      s = this.end();
    },
    // Backwards Compatibility
    domElement: e,
    setMode: n
  };
};
Ws.Panel = function(i, e, t) {
  var n = 1 / 0, s = 0, r = Math.round, a = r(window.devicePixelRatio || 1), o = 80 * a, l = 48 * a, c = 3 * a, h = 2 * a, u = 3 * a, d = 15 * a, A = 74 * a, m = 30 * a, g = document.createElement("canvas");
  g.width = o, g.height = l, g.style.cssText = "width:80px;height:48px";
  var f = g.getContext("2d");
  return f.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif", f.textBaseline = "top", f.fillStyle = t, f.fillRect(0, 0, o, l), f.fillStyle = e, f.fillText(i, c, h), f.fillRect(u, d, A, m), f.fillStyle = t, f.globalAlpha = 0.9, f.fillRect(u, d, A, m), {
    dom: g,
    update: function(p, v) {
      n = Math.min(n, p), s = Math.max(s, p), f.fillStyle = t, f.globalAlpha = 1, f.fillRect(0, 0, o, d), f.fillStyle = e, f.fillText(r(p) + " " + i + " (" + r(n) + "-" + r(s) + ")", c, h), f.drawImage(g, u + a, d, A - a, m, u, d, A - a, m), f.fillRect(u + A - a, d, a, m), f.fillStyle = t, f.globalAlpha = 0.9, f.fillRect(u + A - a, d, a, r((1 - p / v) * m));
    }
  };
};
const Rw = new Wh().load(Tw, (i) => {
  i.magFilter = 1006, i.minFilter = 1006, i.wrapS = 1e3, i.wrapT = 1e3;
});
class Pw {
  constructor(e) {
    this.container = e, this.undersampling = 2, this.detailsWindSpeed = 800, this.detailsWindChangeSpeed = 0.05, this.init3D(), this.initPost(), this.initLevel(), this.pane = new Sw(), this.initPane(), this.clock = new mc(!0), this.update();
  }
  init3D() {
    this.renderer = new Kb({
      powerPreference: "high-performance",
      antialias: !0,
      alpha: !1,
      logarithmicDepthBuffer: !0
    }), this.container.appendChild(this.renderer.domElement), this.stats = new Ws(), this.container.appendChild(this.stats.dom), this.showStats = !0, this.scene = new Na(), this.scene.background = new we(10800116), this.renderer.toneMapping = 7, this.renderer.toneMappingExposure = 1.5, this.clock = new mc(), this.camera = new Gt(60, 1, 0.1, 1e5), this.controls = new sE(this.camera.position, this.camera.quaternion, this.renderer.domElement), this.controls.settings.general.mode = fu.FIRST_PERSON, this.controls.settings.pointer.behaviour = mu.LOCK, this.controls.settings.translation.sensitivity = 100, this.controls.settings.translation.boostMultiplier = 10, this.controls.settings.rotation.sensitivity = 2.5, this.camera.position.set(0, 50, 100), this.camera.rotation.set(
      0,
      0,
      0
    ), location.search.includes("upisfree") && (this.camera.position.set(
      80,
      9,
      -135
    ), this.camera.rotation.set(
      -2.8565540938041662,
      0.4430787851422483,
      3.01662397220497
    )), this.resize(), window.addEventListener("resize", this.resize.bind(this)), window.addEventListener("resize", () => this.initPost()), this.gridHelper = new uA(1e4, 150), this.scene.add(this.gridHelper), this.gridHelper.visible = !1, this.initLights();
  }
  initPane() {
    const e = this.pane.addFolder({ title: "Clouds" }), t = e.addFolder({ title: "Shape", expanded: !1 });
    t.addBinding(this.postMaterial.uniforms.cloudsScale, "value", {
      label: "Scale",
      min: 1,
      max: 500
    }), t.addBinding(this.postMaterial.uniforms.cloudsAltitude, "value", {
      label: "Altitude",
      min: -500,
      max: 500
    }), t.addBinding(this.postMaterial.uniforms.cloudsTransitionalLayerScale, "value", {
      label: "Tr. layer",
      min: 0.1,
      max: 1.8
    });
    const n = e.addFolder({ title: "Coloring" });
    n.addBinding(this.postMaterial.uniforms.densityThreshold, "value", {
      label: "Density thres.",
      min: 0,
      max: 10
    }), n.addBinding(this.postMaterial.uniforms.transparencyThreshold, "value", {
      label: "α thres.",
      min: 1e-5,
      max: 0.5
    }), n.addBinding(this.postMaterial.uniforms.color1, "value", {
      label: "Color 1",
      color: { type: "float" }
    }), n.addBinding(this.postMaterial.uniforms.color2, "value", {
      label: "Color 2",
      color: { type: "float" }
    }), n.addBinding(this.postMaterial.uniforms.densityColorGradientLength, "value", {
      label: "Color gradient depth",
      min: 0.5,
      max: 150
    }), n.addBinding(this.postMaterial.uniforms.alpha1, "value", {
      label: "α 1",
      min: 0.9,
      max: 0.999
    }), n.addBinding(this.postMaterial.uniforms.alpha2, "value", {
      label: "α 2",
      min: 0.9,
      max: 0.999
    }), n.addBinding(this.postMaterial.uniforms.densityAlphaGradientLength, "value", {
      label: "α gradient depth",
      min: 0.5,
      max: 150
    });
    const s = e.addFolder({ title: "Quality" });
    s.addBinding(this.postMaterial.uniforms.maxRMDistance, "value", {
      label: "Max distance",
      min: 1e4,
      max: this.camera.far
    }), s.addBinding(this.postMaterial.uniforms.minRMStep, "value", {
      label: "Min step",
      min: 0.04,
      max: 20
    }), s.addBinding(this.postMaterial.uniforms.rmStepScale, "value", {
      label: "Step size",
      min: 0.2,
      max: 4
    }), s.addBinding(this.postMaterial.uniforms.ditherDepth, "value", {
      label: "Dithering depth",
      min: 0,
      max: 1
    }), s.addBinding(this, "undersampling", {
      label: "Undersampling",
      min: 0,
      max: 4,
      step: 1
    }).on("change", () => this.initPost());
    const r = e.addFolder({ title: "Details" });
    r.addBinding(this.postMaterial.uniforms.detailsScale, "value", {
      label: "Scale",
      min: 10,
      max: 70
    }), r.addBinding(this.postMaterial.uniforms.detailsIntensity, "value", {
      label: "Intensity",
      min: 1,
      max: 10
    }), r.addBinding(this, "detailsWindSpeed", {
      label: "Wind speed",
      min: 100,
      max: 5e3
    }), r.addBinding(this, "detailsWindChangeSpeed", {
      label: "Wind change speed",
      min: 0.05,
      max: 1
    });
    const a = this.pane.addFolder({ title: "Fog", expanded: !1 });
    a.addBinding(this.postMaterial.uniforms.fogEnabled, "value", {
      label: "Enabled"
    }), a.addBinding(this.postMaterial.uniforms.fogColor, "value", {
      label: "Color",
      color: { type: "float" }
    }), a.addBinding(this.postMaterial.uniforms.fogTransparency, "value", {
      label: "Transparency",
      min: 0.99,
      max: 0.9999
    });
    const o = this.pane.addFolder({ title: "Helpers", expanded: !1 });
    o.addBinding(this.gridHelper, "visible", { label: "Show grid" }), o.addBinding(this, "showStats", { label: "Show stats" }).on("change", (l) => l.value ? this.container.appendChild(this.stats.dom) : this.stats.dom.remove()), o.addBinding(this.scene, "background", {
      label: "Background",
      color: { type: "float" }
    });
  }
  initPost() {
    const [e, t] = [this.renderer.getPixelRatio() * window.innerWidth, this.renderer.getPixelRatio() * window.innerHeight];
    this.rt = new Kn(e, t), this.rt.depthTexture = new Qo(e, t);
    let [n, s] = [e, t], r = `
    #define DEPTH_COORD_MULTIPLIER 1
    #define MERGE_COLOR
    `;
    if (this.undersampling > 0) {
      this.undersampling = Math.ceil(this.undersampling);
      const a = 2 ** this.undersampling;
      [n, s] = [Math.ceil(e / a), Math.ceil(t / a)], this.cloudsRt = new Kn(n, s), r = `
      #define DEPTH_COORD_MULTIPLIER ${a}
      `, this.metaMaterial = new Mn({
        vertexShader: Bh,
        fragmentShader: Bw,
        uniforms: {
          sceneTexture: { value: null },
          cloudsTexture: { value: null },
          viewportSizeInverse: { value: new Ie(1 / e, 1 / t) }
        }
      }), this.metaScene = new Na(), this.metaScene.add(new ot(new Li(2, 2), this.metaMaterial));
    }
    this.postCamera = new oa(-1, 1, 1, -1, 0, 1), this.postMaterial ? (this.postMaterial.fragmentShader = r + Th, this.postMaterial.uniforms.viewportSizeInverse.value = new Ie(1 / n, 1 / s), this.postMaterial.needsUpdate = !0) : this.postMaterial = new Mn({
      vertexShader: Bh,
      fragmentShader: r + Th,
      uniforms: {
        cameraFar: { value: this.camera.far },
        cameraNear: { value: this.camera.near },
        worldCameraPosition: { value: this.camera.getWorldPosition(new T()) },
        viewportSizeInverse: { value: new Ie(1 / n, 1 / s) },
        worldCameraUnprojectionMatrix: { value: this.camera.matrixWorld.clone().multiply(this.camera.projectionMatrixInverse) },
        tDiffuse: { value: null },
        tDepth: { value: null },
        timeSeconds: { value: 0 },
        noiseTexture: { value: Rw },
        ditherDepth: { value: 1 },
        densityThreshold: { value: 4 },
        cloudsScale: { value: 50 },
        cloudsAltitude: { value: -100 },
        cloudsTransitionalLayerScale: { value: 1 },
        maxRMDistance: { value: 1e4 },
        minRMStep: { value: 10 },
        rmStepScale: { value: 1 },
        transparencyThreshold: { value: 0.3 },
        detailsScale: { value: 30 },
        detailsIntensity: { value: 1 },
        detailsOffset: { value: new T(0, 0, 0) },
        color1: { value: new we().setRGB(0.874509804, 0.874509804, 0.796078431) },
        // #dfdfcb
        color2: { value: new we().setRGB(1, 1, 0.870588235) },
        // #ffffde
        color3: { value: new we().setRGB(1, 0.95, 0.8) },
        color4: { value: new we() },
        alpha1: { value: 0.99 },
        alpha2: { value: 0.95 },
        densityColorGradientLength: { value: 100 },
        densityAlphaGradientLength: { value: 100 },
        fogColor: { value: new we().setRGB(0.5, 0, 0) },
        fogTransparency: { value: 0.99 },
        fogEnabled: { value: !1 }
      }
    }), this.postScene = new Na(), this.postScene.add(new ot(new Li(2, 2), this.postMaterial));
  }
  initLights() {
    this.ambientLight = new $p(16777215, 2), this.scene.add(this.ambientLight);
  }
  async initLevel() {
    const e = new iv(), t = new hn();
    t.setTranscoderPath("./lib/basis/"), t.detectSupport(this.renderer), e.setKTX2Loader(t), e.setMeshoptDecoder(zv);
    const s = (await e.loadAsync("./assets/level.glb")).scene;
    s.getObjectByName("PHYSICS_GEOMETRY").visible = !1, s.getObjectByName("PLAYER_SPAWN_POINT").visible = !1, s.traverse((r) => {
      r.isMesh && r.material && (r.material.map && (r.material.map.magFilter = 1003, r.material.map.minFilter = 1003, r.material.map.anisotropy = this.renderer.capabilities.getMaxAnisotropy()), this.convertMaterialStandardToBasic(r));
    }), this.scene.add(s);
  }
  convertMaterialStandardToBasic(e) {
    let t = e.material;
    e.material = new Hn(), Hn.prototype.copy.call(e.material, t);
  }
  update(e) {
    requestAnimationFrame(this.update.bind(this)), this.controls.update(e), this.render(), this.stats.update();
  }
  render() {
    this.renderer.setRenderTarget(this.rt), this.renderer.render(this.scene, this.camera), this.postMaterial.uniforms.tDiffuse.value = this.rt.texture, this.postMaterial.uniforms.tDepth.value = this.rt.depthTexture, this.postMaterial.uniforms.worldCameraPosition.value = this.camera.getWorldPosition(new T()), this.postMaterial.uniforms.worldCameraUnprojectionMatrix.value = this.camera.matrixWorld.clone().multiply(this.camera.projectionMatrixInverse), this.postMaterial.uniforms.timeSeconds.value = this.clock.getElapsedTime(), this.postMaterial.uniforms.detailsOffset.value = new T(
      Math.cos(this.clock.getElapsedTime() * this.detailsWindChangeSpeed),
      Math.sin(this.clock.getElapsedTime() * this.detailsWindChangeSpeed * 0.3421),
      Math.sin(this.clock.getElapsedTime() * this.detailsWindChangeSpeed)
    ).multiplyScalar(this.detailsWindSpeed), this.undersampling > 0 ? (this.renderer.setRenderTarget(this.cloudsRt), this.renderer.setClearColor("black", 0), this.renderer.clear(!0), this.renderer.render(this.postScene, this.postCamera), this.renderer.setRenderTarget(null), this.metaMaterial.uniforms.sceneTexture.value = this.rt.texture, this.metaMaterial.uniforms.cloudsTexture.value = this.cloudsRt.texture, this.renderer.render(this.metaScene, this.postCamera)) : (this.renderer.setRenderTarget(null), this.renderer.render(this.postScene, this.postCamera));
  }
  resize() {
    this.containerBounds = this.container.getBoundingClientRect(), this.camera.aspect = this.containerBounds.width / this.containerBounds.height, this.camera.updateProjectionMatrix();
    let e = window.devicePixelRatio;
    this.renderer.setPixelRatio(e), this.renderer.setSize(this.containerBounds.width, this.containerBounds.height);
  }
  initObjects() {
    const e = new ra({
      color: 5748215,
      roughness: 1,
      // metalness: 1,
      flatShading: !0,
      side: 2
    });
    let t = new ot(new zo(75, 20, 10), e);
    t.position.set(-300, 0, 200), this.scene.add(t), t = new ot(new Go(75, 1), e), t.position.set(-100, 0, 200), this.scene.add(t), t = new ot(new Ho(75, 2), e), t.position.set(100, 0, 200), this.scene.add(t), t = new ot(new qo(75, 0), e), t.position.set(300, 0, 200), this.scene.add(t), t = new ot(new Li(100, 100, 4, 4), e), t.position.set(-300, 0, 0), this.scene.add(t), t = new ot(new bs(100, 100, 100, 4, 4, 4), e), t.position.set(-100, 0, 0), this.scene.add(t), t = new ot(new _o(50, 20, 0, Math.PI * 2), e), t.position.set(100, 0, 0), this.scene.add(t), t = new ot(new Vo(10, 50, 20, 5, 0, Math.PI * 2), e), t.position.set(300, 0, 0), this.scene.add(t), t = new ot(new Oo(25, 75, 100, 40, 5), e), t.position.set(-300, 0, -200), this.scene.add(t);
    const n = [];
    for (let s = 0; s < 50; s++)
      n.push(new Ie(Math.sin(s * 0.2) * Math.sin(s * 0.1) * 15 + 50, (s - 5) * 2));
    t = new ot(new ko(n, 20), e), t.position.set(-100, 0, -200), this.scene.add(t), t = new ot(new Wo(50, 20, 20, 20), e), t.position.set(100, 0, -200), this.scene.add(t), t = new ot(new Jr(50, 10, 50, 20), e), t.position.set(300, 0, -200), this.scene.add(t), t = new ot(new Jr(50, 10, 50, 20), e), t.position.set(0, 0, 1e4), this.scene.add(t);
  }
}
export {
  Pw as default
};
